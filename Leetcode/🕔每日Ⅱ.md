🔴🔁✅

### 11/12 [790. 多米诺和托米诺平铺](https://leetcode.cn/problems/domino-and-tromino-tiling/)🔴

> 有两种形状的瓷砖：一种是 `2 x 1` 的多米诺形，另一种是形如 "L" 的托米诺形。两种形状都可以旋转。
>
> <img src="../Resources/lc-domino.jpg" alt="img" style="zoom:80%;" />
>
> 给定整数 n ，返回可以平铺 `2 x n` 的面板的方法的数量。**返回对** `109 + 7` **取模** 的值。
>
> 平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。
>
> **示例 1:**
>
> <img src="../Resources/lc-domino1.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入: n = 3
> 输出: 5
> 解释: 五种不同的方法如上所示。
> ```
>
> **示例 2:**
>
> ```
> 输入: n = 1
> 输出: 1
> ```

### [805. 数组的均值分割](https://leetcode.cn/problems/split-array-with-same-average/)🔴

> 给定你一个整数数组 `nums`
>
> 我们要将 `nums` 数组中的每个元素移动到 `A` 数组 或者 `B` 数组中，使得 `A` 数组和 `B` 数组不为空，并且 `average(A) == average(B)` 。
>
> 如果可以完成则返回`true` ， 否则返回 `false` 。
>
> **注意：**对于数组 `arr` ,  `average(arr)` 是 `arr` 的所有元素除以 `arr` 长度的和。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,4,5,6,7,8]
> 输出: true
> 解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [3,1]
> 输出: false
> ```

### 11.15/[1710. 卡车上的最大单元数🔁](https://leetcode.cn/problems/maximum-units-on-a-truck/)

> 请你将一些箱子装在 **一辆卡车** 上。给你一个二维数组 `boxTypes` ，其中 `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]` ：
>
> - `numberOfBoxesi` 是类型 `i` 的箱子的数量。
> - `numberOfUnitsPerBoxi` 是类型 `i` 每个箱子可以装载的单元数量。
>
> 整数 `truckSize` 表示卡车上可以装载 **箱子** 的 **最大数量** 。只要箱子数量不超过 `truckSize` ，你就可以选择任意箱子装到卡车上。
>
> 返回卡车可以装载 **单元** 的 **最大** 总数*。*
>
>  
>
> **示例 1：**
>
> ```
> 输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
> 输出：8
> 解释：箱子的情况如下：
> - 1 个第一类的箱子，里面含 3 个单元。
> - 2 个第二类的箱子，每个里面含 2 个单元。
> - 3 个第三类的箱子，每个里面含 1 个单元。
> 可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
> 单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
> ```

计数排序：很好的方法！

```java
class Solution {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
        int count = 0;
		int[] ans = new int[1001];
		for (int[] is : boxTypes) {
			ans[is[1]] += is[0];
		}
		for (int i = ans.length - 1; i > 0; i--) {
			if (ans[i] != 0) {
				if (truckSize > ans[i]) {
					count += ans[i] * i;
					truckSize -= ans[i];
				} else {
					return count + truckSize * i;
				}
			}
		}
		return count;
    }
}
```

### 11.16/[775. 全局倒置与局部倒置🔴](https://leetcode.cn/problems/global-and-local-inversions/)

> 给你一个长度为 `n` 的整数数组 `nums` ，表示由范围 `[0, n - 1]` 内所有整数组成的一个排列。
>
> **全局倒置** 的数目等于满足下述条件不同下标对 `(i, j)` 的数目：
>
> - `0 <= i < j < n`
> - `nums[i] > nums[j]`
>
> **局部倒置** 的数目等于满足下述条件的下标 `i` 的数目：
>
> - `0 <= i < n - 1`
> - `nums[i] > nums[i + 1]`
>
> 当数组 `nums` 中 **全局倒置** 的数量等于 **局部倒置** 的数量时，返回 `true` ；否则，返回 `false` 。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,0,2]
> 输出：true
> 解释：有 1 个全局倒置，和 1 个局部倒置。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,0]
> 输出：false
> 解释：有 2 个全局倒置，和 1 个局部倒置。
> ```

```java
//维护后缀最小值
class Solution {
    public boolean isIdealPermutation(int[] nums) {
        int n = nums.length, minSuff = nums[n - 1];
        for (int i = n - 3; i >= 0; i--) {
            if (nums[i] > minSuff) {
                return false;
            }
            minSuff = Math.min(minSuff, nums[i + 1]);
        }
        return true;
    }
}
```







### [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

> 给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
>
> **示例 1：**
>
> ```
> 输入：nums = [5,2,6,1]
> 输出：[2,1,1,0] 
> 解释：
> 5 的右侧有 2 个更小的元素 (2 和 1)
> 2 的右侧仅有 1 个更小的元素 (1)
> 6 的右侧有 1 个更小的元素 (1)
> 1 的右侧有 0 个更小的元素
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-1]
> 输出：[0]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [-1,-1]
> 输出：[0,0]
> ```

#### 二分法

#### 归并排序

#### 树状数组

[算法学习笔记(2) : 树状数组 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93795692)

​	BIT(Binary Index Tree)

#### 线段树

#### 二叉搜索树

### [11.17/792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

> 给定字符串 `s` 和字符串数组 `words`, 返回 *`words[i]` 中是`s`的子序列的单词个数* 。
>
> 字符串的 **子序列** 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。
>
> - 例如， `“ace”` 是 `“abcde”` 的子序列。
>
> **示例 1:**
>
> ```
> 输入: s = "abcde", words = ["a","bb","acd","ace"]
> 输出: 3
> 解释: 有三个是 s 的子序列的单词: "a", "acd", "ace"。
> ```
>
> **Example 2:**
>
> ```
> 输入: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
> 输出: 2
> ```

二分 

```java
public int numMatchSubseq(String s,String[] words){
    List<Integer> pos[] = new List[26];//存26个字母的列表数组，每个下标存ArrayList
    char c[] = s.toCharArray();
    for(int i = 0;i<26;i++){
        pos[i] =new ArrayList<>();
        pos[i].add(-1);
    }
    for(int i = 0;i<c.length;i++){
        pos[c[i]-'a'].add(i);//每个字母出现的位置
    }
    int ans = words.length;
    for(int i =0;i<words.length;i++){
        int pre = -1;
        for(char ch:words[i].toCharArray()){5
            int next = nextPos(pos,pre,ch-'a');
            if(next==-1){
                ans--;break;
            }
            pre = next;
        }
    }
    return ans;
}

//二分查找
int nextPos(List<Integer> pos[],int idx ,int ch){
    if(pos[ch].get(pos[ch].size()-1)<=idx){return -1;}
        int l=0,r=pos[ch].size()-1;
        while(l<r){
            int mid=(l+r)>>1;
            if(pos[ch].get(mid)>idx){r=mid;}
            else{l=mid+1;}
            if(l==r-1){
                if(pos[ch].get(l)>idx){r=l;}
                break;
            }
        }
        return pos[ch].get(r);
}
```

```java
//next数组
class Solution {
    public int numMatchingSubseq(String s, String[] words) {
        char c[]=s.toCharArray();
        int next[][]=new int[c.length+1][26];
        int pos[]=new int[26];//每个字母第一次出现的位置，匹配符合贪心
        Arrays.fill(pos,-1);
        for(int i=0;i<=c.length;i++){Arrays.fill(next[i],-1);}
        for(int i=c.length-1;i>=0;i--){//倒叙
            pos[c[i]-'a']=i;
            for(int j=0;j<26;j++){next[i][j]=pos[j];}            
        }
        int ans=words.length;
        for(int i=0;i<words.length;i++){
            int pre=0;
            char c1[]=words[i].toCharArray();
            for(int j=0;j<c1.length;j++){
                pre=next[pre][c1[j]-'a'];
                if(pre<0){
                    ans--;
                    break;
                }
                pre++;
            }
        }
        return ans;
    }
}
```

### 392.判断子序列

DP做法:

预处理t中每一个字符下一次出现的位置

```java
int n = s.length(), m = t.length();
int[][] f = new int[m+1][26];
for(int i = 0;i<26;i++){
    f[m][i] = m;//初始化：第一次出现的位置为末尾
}


```

### [799. 香槟塔](https://leetcode.cn/problems/champagne-tower/)

> 我们把玻璃杯摆成金字塔的形状，其中 **第一层** 有 `1` 个玻璃杯， **第二层** 有 `2` 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。
>
> 从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）
>
> 例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。
>
> <img src="../Resources/tower.png" alt="img" style="zoom:33%;" />
>
> 现在当倾倒了非负整数杯香槟后，返回第 `i` 行 `j` 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ `i` 和 `j` 都从0开始）。
>
> ```
> 示例 1:
> 输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
> 输出: 0.00000
> 解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。
> 
> 示例 2:
> 输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
> 输出: 0.50000
> 解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。
> ```
>
> **示例 3:**
>
> ```
> 输入: poured = 100000009, query_row = 33, query_glass = 17
> 输出: 1.00000
> ```

模拟：将所有一次性倒入第一杯

```java
public double champagneTower(int poured, int query_row, int query_glass) {
    double[] row = {poured};//将所有一次性倒入第一杯
    for(int i= 1;i<=query_row;i++){
        double[] nextRow = new double[i+1];
        for(int j = 0;j<i;j++){
            double volume = row[j];
            if(volume>1){
                nextRow[j] +=(volume-1)/2;
                nextRow[j+1] += (volume-1)/2;
            }
        }
        row = nextRow;
    }
    return Math.min(1,row[query_glass]);
}
```

