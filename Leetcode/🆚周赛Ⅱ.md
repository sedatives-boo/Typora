## 320

### [6243. 到达首都的最少油耗](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/)

> 给你一棵 `n` 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 `0` 到 `n - 1` ，且恰好有 `n - 1` 条路。`0` 是首都。给你一个二维整数数组 `roads` ，其中 `roads[i] = [ai, bi]` ，表示城市 `ai` 和 `bi` 之间有一条 **双向路** 。
>
> 每个城市里有一个代表，他们都要去首都参加一个会议。
>
> 每座城市里有一辆车。给你一个整数 `seats` 表示每辆车里面座位的数目。
>
> 城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。
>
> 请你返回到达首都最少需要多少升汽油。
>
> **示例 1：**
>
> <img src="../Resources/a4c380025e3ff0c379525e96a7d63a3.png" alt="img" style="zoom:67%;" />
>
> ```
> 输入：roads = [[0,1],[0,2],[0,3]], seats = 5
> 输出：3
> 解释：
> - 代表 1 直接到达首都，消耗 1 升汽油。
> - 代表 2 直接到达首都，消耗 1 升汽油。
> - 代表 3 直接到达首都，消耗 1 升汽油。
> 最少消耗 3 升汽油。
> ```
>
> **示例 2：**
>
> <img src="../Resources/2.png" alt="img" style="zoom:67%;" />
>
> ```
> 输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
> 输出：7
> 解释：
> - 代表 2 到达城市 3 ，消耗 1 升汽油。
> - 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。
> - 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。
> - 代表 1 直接到达首都，消耗 1 升汽油。
> - 代表 5 直接到达首都，消耗 1 升汽油。
> - 代表 6 到达城市 4 ，消耗 1 升汽油。
> - 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。
> 最少消耗 7 升汽油。
> ```

```java
class Solution {
    List<Integer>[] edges = new List[100010];
    long ret = 0;
    public long minimumFuelCost(int[][] roads, int seats) {
        for(int i = 0 ; i < 100010 ; i ++){
            edges[i] = new ArrayList<>();
        }
        for(int i = 0 ; i < roads.length ; i ++){
            edges[roads[i][0]].add(roads[i][1]);
            edges[roads[i][1]].add(roads[i][0]);
        }
        for(int i = 0 ; i < edges[0].size() ; i++){
            dfs(edges[0].get(i) ,0,seats);//起始位置：0号，遍历0连接的节点DFS，即1和4
        }
        
        return ret;
    }
    int dfs(int cur , int fa ,int seat){
        int all = 1;
        for(int i = 0 ; i < edges[cur].size() ; i ++){
            if(edges[cur].get(i) == fa) continue;
            all += dfs(edges[cur].get(i) , cur , seat);//子树的个数
        }
        ret = ret +(all + seat - 1) / seat;
        return all;
    }
}
```

其他方法：拆分成以0为根节点的树

<img src="../Resources/1668949731-hWioKe-1.png" alt="1.png" style="zoom: 67%;" />

```java
class Solution {
    long ans = 0;
    public long minimumFuelCost(int[][] roads, int seats) {
        int n = roads.length + 1;
        List<List<Integer>> map = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            map.add(new ArrayList<>());
        }
        for (int i = 0; i < roads.length; i++) {
            map.get(roads[i][0]).add(roads[i][1]);
            map.get(roads[i][1]).add(roads[i][0]);
        }
        dfs(map,0,-1,seats);
        return ans;
    }

    public int dfs(List<List<Integer>> map,int cur,int father,int seats){
        int size = 1;
        for (int node : map.get(cur)){
            if (node != father){
                size += dfs(map,node,cur,seats);
            }
        }
        if (cur != 0) ans+=(int)Math.ceil((double) size/seats);
        return size;
    }
}
```

```java
long ans;
    public long minimumFuelCost(int[][] roads, int seats) {
        ans = 0;
        int n = roads.length + 1;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] road : roads) {
            graph[road[0]].add(road[1]);
            graph[road[1]].add(road[0]);
        }
        BiFunction<Integer, Integer, Integer> function = new BiFunction<Integer, Integer, Integer>() {
            @Override
            public Integer apply(Integer x, Integer fa) {
                int ret = 1;
                for (int c : graph[x]) {
                    if (c != fa) {
                        ret += apply(c, x);
                    }
                }
                if (x != 0) {
                    ans += (ret + seats - 1) / seats;
                }
                return ret;
            }
        };
        function.apply(0, -1);
        return ans;
    }
```

```java
class Solution {
    List<Integer>[] g;
    long res;
    int seats;
    public long minimumFuelCost(int[][] roads, int seats) {
        if(roads.length==0){
            return 0L;
        }
        int num=0;
        this.seats=seats;
        for(int i=0;i<roads.length;i++){
            for(int j=0;j<2;j++){
                num=Math.max(num, roads[i][j]);
            }
        }

        g=new List[num+1];
        for(int i=0;i<roads.length;i++){
            if(g[roads[i][0]]==null){
                g[roads[i][0]]=new ArrayList<>();
            }
            if(g[roads[i][1]]==null){
                g[roads[i][1]]=new ArrayList<>();
            }
            g[roads[i][0]].add(roads[i][1]);
            g[roads[i][1]].add(roads[i][0]);
        }

        dfs(0,-1);
        return res;
    }

    public long dfs(int i, int fa){
        List<Integer> ch=g[i];
        long subres=1L;
        for(int j=0;j<ch.size();j++){
            if(ch.get(j)!=fa){
                subres += dfs(ch.get(j), i);
            }
        }
        if(i!=0){
            res+=(long)Math.ceil(((double)subres)/seats);
        }
        return subres;
    }

}
```

### [2478. 完美分割的方案数](https://leetcode.cn/problems/number-of-beautiful-partitions/)

> 给你一个字符串 `s` ，每个字符是数字 `'1'` 到 `'9'` ，再给你两个整数 `k` 和 `minLength` 。
>
> 如果对 `s` 的分割满足以下条件，那么我们认为它是一个 **完美** 分割：
>
> - `s` 被分成 `k` 段互不相交的子字符串。
> - 每个子字符串长度都 **至少** 为 `minLength` 。
> - 每个子字符串的第一个字符都是一个 **质数** 数字，最后一个字符都是一个 **非质数** 数字。质数数字为 `'2'` ，`'3'` ，`'5'` 和 `'7'` ，剩下的都是非质数数字。
>
> 请你返回 `s` 的 **完美** 分割数目。由于答案可能很大，请返回答案对 `109 + 7` **取余** 后的结果。
>
> 一个 **子字符串** 是字符串中一段连续字符串序列。
>
> **示例 1：**
>
> ```
> 输入：s = "23542185131", k = 3, minLength = 2
> 输出：3
> 解释：存在 3 种完美分割方案：
> "2354 | 218 | 5131"
> "2354 | 21851 | 31"
> "2354218 | 51 | 31"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "23542185131", k = 3, minLength = 3
> 输出：1
> 解释：存在一种完美分割方案："2354 | 218 | 5131" 。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "3312958", k = 3, minLength = 1
> 输出：1
> 解释：存在一种完美分割方案："331 | 29 | 58" 。
> ```
