



## 回溯法

### 77.组合🟥🟨🟩🟨🟥

> 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
>
> 你可以按 任何顺序 返回答案。
>
> 示例 1：
>
> ```
> 输入：n = 4, k = 2
> 输出：
> [[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]
> ```
>
> 示例 2：
>
> ```
> 输入：n = 1, k = 1
> 输出：[[1]]
> ```

> <font color=red>二刷关键点</font>：
>
> - 声明List 和声明LinkedList，能使用的方法不同！
> - 将List转ArrayList
> - 注意下次的迭代的起始下标
> - 剪枝：
>   - i<=n
>   - i <= n - (k-path.size())+1

> <font color=red>五刷关键点</font>：
>
> 完全没有掌握

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));//注意这里添加
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){  //提交 i <=n 也行，但是消耗时间巨大！ 这是没有剪枝
            path.add(i);
            combineHelper(n, k, i + 1);
            path.removeLast();
        }
    }
}
```

### 39.组合总和🟥🟨🟥

> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
>
> candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 target 的不同组合数少于 150 个。
>
> 示例 1：
>
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```
>
> 示例 2：
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```
>
> 示例 3：
>
> ```
> 输入: candidates = [2], target = 1
> 输出: []
> ```
>
> <font color=red>二刷关键点</font>：
>
> - 别以为可重复就不需要index！！！  注意startindex 和 for 起始位置上的关系
> - poll 默认 removeFirst

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target,0,0);
        return res;
    }

    public void backtracking(int[] candidates, int target, int sum ,int startIndex){
        if(sum > target) return;
        if(sum == target){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = startIndex;i<candidates.length;i++){
            path.addFirst(candidates[i]);		//注意下addFirst和poll对应
            sum+=candidates[i];
            backtracking(candidates,target,sum,i);
            sum -= candidates[i];
            path.poll();
        }
    }
}
```



### 216.组合总和Ⅲ🟥🟨

相当于39题：确定了数组 ，确定了树的深度

> 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
>
> 只使用数字1到9
> 每个数字 最多使用一次 
> 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
> 示例 1:
>
> ```
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> 解释:
> 1 + 2 + 4 = 7
> 没有其他符合的组合了。
> ```
>
> 示例 2:
>
> ```
> 输入: k = 3, n = 9
> 输出: [[1,2,6], [1,3,5], [2,3,4]]
> 解释:
> 1 + 2 + 6 = 9
> 1 + 3 + 5 = 9
> 2 + 3 + 4 = 9
> 没有其他符合的组合了。
> ```
>
> 示例 3:
>
> ```
> 输入: k = 4, n = 1
> 输出: []
> 解释: 不存在有效的组合。
> 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
> ```

```java
//模仿39题做出
class Solution {
    int[] nums = {1,2,3,4,5,6,7,8,9};
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    //n = target;
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(nums,n,0,k,0);
        return res;
    }

    public void backtracking(int[] nums,int n,int sum,int k, int startIndex){
        if(sum>n || path.size()>k) return;//这里的剪枝可以省去大量时间
        if(sum==n && path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = startIndex; i < 9;i++){
            path.addFirst(nums[i]);
            sum += nums[i];
            backtracking(nums,n,sum, k,i+1);
            sum -= nums[i];
            path.poll();
        }
    }
}
```

### 17.电话号码字母组合🟥

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> 电话九宫格对应按键：
>
> | 1 -        | 2 abc     | 3 def      |
> | ---------- | --------- | ---------- |
> | **4 ghi**  | **5 jkl** | **6 mno**  |
> | **7 pqrs** | **8 tuv** | **9 wxyz** |
> | *          | **0**     | #          |
>
> 示例 1：
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> 示例 2：
>
> ```
> 输入：digits = ""
> 输出：[]
> ```
>
> 示例 3：
>
> ```
> 输入：digits = "2"
> 输出：["a","b","c"]
> ```

```java
/**
*@param : list： 存结果的list
		digits： 题目给定的号码
		numString： 预先存好的号码对应关系
		temp： 用来存结果的StringBuilder
		num：当前遍历到号码的第几个数字，和index不太一样
		str：该号码的对应字符串
*/
//先存一个号码和字符串映射
class Solution{
   List<String> list = new ArrayList<>();
    
    public List<String> letterCombination(String digits){
        if(digits ==null || digits.length()==0) return list;//不符合返回空
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backtracking(digits,numString,0);
        return list;
    }
    
    StringBuilder temp = new StringBuilder();  //这个要放在外面，不然先遇到结束检查就找不到temp
    
    public void backtracking(String digits, String[] numString, int num){
        //结束条件
        if(num == digits.length()){
            list.add(temp.toString());
            return;
        }
        //先从映射表里读出来该数字对应的字符串
        String str = numString[digits.charAt(num) -'0']; // -'0' 是转为int型
        //回溯内容：
        for(int i = 0;i<str.length();i++){//根本没理解 num和i表示什么
            temp.append(str.charAt(i));
            backtracking(digits,numString, num+1);
            temp.deleteCharAt(temp.length()-1);//注意删除stringbuilder末尾元素
        }
        
    }
}
```

### 40.组合总和Ⅱ🟨

**该题写两次都是超时报错，缺少剪枝！！！**

> 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用 一次 。
>
> 注意：解集不能包含重复的组合。 
>
> 示例 1:
>
> ```
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 输出:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> ```
>
> 示例 2:
>
> ```
> 输入: candidates = [2,5,2,1,2], target = 5,
> 输出:
> [
> [1,2,2],
> [5]
> ]
> ```

```java
//和39一样，只是不能重复，递归下标+1
//[[1, 2, 5], [2, 1, 5]] 会重复输出，而set集合不能分辨，除非按顺序排好
//把所有集合求出来再去重容易超时，因此需要在搜寻过程去重
```

```java
//题解：使用标记数组
class Solution {
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> deque = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        //为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        //加标志数组，用来辅助判断同层节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        backTracking(candidates, target, 0, flag);
        return lists;
    }

    public void backTracking(int[] arr, int target, int index, boolean[] flag) {
        if (sum == target) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = index; i < arr.length && arr[i] + sum <= target; i++) {//arr[i] + sum <= target 是剪枝，不能不加！！！
            //出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && arr[i] == arr[i - 1] && !flag[i - 1]) {
                continue;
            }
            flag[i] = true;
            sum += arr[i];
            deque.push(arr[i]);
            //每个节点仅能选择一次，所以从下一位开始
            backTracking(arr, target, i + 1, flag);
            int temp = deque.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```

```java
//自己重写，但是超时！🔴🔴🔴🔴🔴缺少剪枝！！
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        boolean[] flag = new boolean[candidates.length];
        backtracking(candidates, target, 0, flag);
        return res;
    }
    public void backtracking(int[] candidates, int target, int index, boolean[] flag){
        if(sum == target){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i= index;i <candidates.length;i++){//这里缺少剪枝过程
            //先判断是否是重复元素
            if(i>0&&candidates[i]==candidates[i-1]&&!flag[i-1]) continue;
            flag[i] = true;
            sum += candidates[i];
            path.addLast(candidates[i]);
            backtracking(candidates,target,i+1,flag);
            sum -= candidates[i];
            flag[i] = false;
            path.pollLast();
        }
    }
}
```



```java
//题解：不使用标记数组
class Solution {
  List<List<Integer>> res = new ArrayList<>();
  LinkedList<Integer> path = new LinkedList<>();
  int sum = 0;
  
  public List<List<Integer>> combinationSum2( int[] candidates, int target ) {
    //为了将重复的数字都放到一起，所以先进行排序
    Arrays.sort( candidates );
    backTracking( candidates, target, 0 );
    return res;
  }
  
  private void backTracking( int[] candidates, int target, int start ) {
    if ( sum == target ) {
      res.add( new ArrayList<>(path));
      return;
    }
    for (int i = start; i < candidates.length && sum + candidates[i] <= target; i++ ) {
      //正确剔除重复解的办法
      //跳过同一树层使用过的元素
      if ( i > start && candidates[i] == candidates[i - 1] ) {
        continue;
      }
      sum += candidates[i];
      path.add( candidates[i] );
      // i+1 代表当前组内元素只选取一次
      backTracking( candidates, target, i + 1 );

      int temp = path.getLast();
      sum -= temp;
      path.removeLast();
    }
  }
}
```

### 131.分割回文串🔁🔁🔴🔴

> 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
>
> 回文串 是正着读和反着读都一样的字符串。
>
> 示例 1：
>
> ```
> 输入：s = "aab"
> 输出：[["a","a","b"],["aa","b"]]
> ```
>
> 示例 2：
>
> ```
> 输入：s = "a"
> 输出：[["a"]]
> ```

```java
class Solution{
    List<List<String>> res = new ArrayList<>();
    Deque<String> path = new LinkedList<>();
    
    //回文判断
    public boolean isPalindrome(String s, int start, int end){//左闭右闭的区间
        for(int i =start,j = end;i<j; i++,j--){
            if(s.charAt(i)!=s.charAt(j))
                return false;
        }
        return true;
    }
   //backtracking
    public void backtracking(String s,int index){
        //结束条件：已经分割到字符串尾部
        if(index >= s.length()){
            res.add(new ArrayList<>(path));
            return;
        }
        //递归
        for(int i = index;i < s.length(); i++){
            //先检查是否是回文
            if(isPalindrome(s,index,i)){//是的就将这个字串加入path
                String str = s.substring(index, i +1);//左闭右开的区间
                path.addLast(str);
            }else{//不是的直接跳过
                continue;
            }
            //回溯
            backtracking(s,i+1);
            path.pollLast();
        }
    }
    //
    public List<List<String>> partition(String s){
        backtracking(s,0);
        return res;
    }
}
```

### 93.复原IP地址🔁🔁🔁🔴

> 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
> 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
>
> 示例 1：
>
> ```
> 输入：s = "25525511135"
> 输出：["255.255.11.135","255.255.111.35"]
> ```
>
> 示例 2：
>
> ```
> 输入：s = "0000"
> 输出：["0.0.0.0"]
> ```
>
> 示例 3：
>
> ```
> 输入：s = "101023"
> 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
> ```

```java
//和131.分割回文串类似，每次都要检查分割后的是否满足条件
List<String> res = new ArrayList<>();
//判断数值
public boolean isValid(String s,int start, int end){
    /*1.检查start和end
    2.不能以0开头
    3.比0小或比9大的字符
    4.计算和不大于255*/
    if(start>end) return false;
    if(s.charAt(start)=='0'&&start!=end) return false;
    int num = 0;
    for(int i = start;i<=end;i++){
        if(s.charAt(i)<'0'||s.charAt(i)>'9')
            return false;
        num = num*10 +(s.charAt(i)-'0');
        if(num>255)
            return false;
    }
    return true;
    
}
//回溯
public void backtracking(String s, int index, int pointNum){
    //逗号3个时，进行最后一段字串检查和返回
    if(pointNum==3){
        if(isValid(s,index,s.length()-1)){
            result.add(s);
        }
        return;
    }
    for(int i = index;i<s.length()-1;i++){
        //更新i之后都要进行检查，然后才能进行下面的步骤
        if(isValid(s,index,i)){
            s = s.substring(0,i+1)+"."+s.substring(i+1);//在str后面加入一个逗号
            pointNum++;
            backtracking(s,i+2,pointNum);
            pointNum--;
            s = s.substring(0,i+1)+s.substring(i+2);
        }else{
            break;
        }
    }
}


public List<String> restoreIpAddress(String s){
    if(s.length()>12) return res;//初步的检查
    backtracking(s,0,0);
    return res;
}
```

```java
//效率更好的方式
```

### 78.子集🟥

> 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
>
> 
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums,0);
        return res;
    }
    public void backtracking(int[] nums,int index){

        res.add(new ArrayList<>(temp));//这里不需要出口条件，不是组合问题，而是所有的情况都加进去

        for(int i = index;i<nums.length;i++){
            temp.addFirst(nums[i]);
            backtracking(nums,i+1);
            temp.pollFirst();
        }
    }
}
```

### 90.子集Ⅱ✅

> 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,2]
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```

```java
//类似于40题，需要flag来判断
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length];
        backtracking(nums,flag,0);
        return res;
    }
     public void backtracking(int[] nums,boolean[]flag,int index){

        res.add(new ArrayList<>(temp));//这里不需要出口条件，不是组合问题，而是所有的情况都加进去

        for(int i = index;i<nums.length;i++){
            if(i>0&&nums[i]==nums[i-1]&&!flag[i-1]){
                continue;
            }else{
                temp.addFirst(nums[i]);
                flag[i]=true;
                backtracking(nums,flag,i+1);
                flag[i]=false;
                temp.pollFirst();
            }
        }
    } 
}
```

### 491.递增子序列🔴

> 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
>
> 示例 1：
>
> ```
> 输入：nums = [4,6,7,7]
> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [4,4,3,2,1]
> 输出：[[4,4]]
> ```

```java
//出口条件：长度>1
List<List<Integer>> res = new ArrayList<>();
Deque<Integer> path = new LinkedList<>();

public List<List<Integer>> findSubsequences(int[] nums) {
 	backtracking(nums,0);
    return res;
}

 public void backtracking(int[] nums,){
     if(path.size()>1){
         res.add(new ArrayList<>(path));
         //不要加return
     }
     //单层搜索逻辑：同一层相同元素不能复用：使用set去重
     int[] used = new int[201];
     for(int i=start;i<nums.length;i++){
         if(!path.isEmpty(i)&&nums[i]<path.get(path.size()-1)||(used[nums[i]]+100==1)) continue;
         used[nums[i]+100] =1;
         path.add(nums[i]);
         backtracking(nums,i+1);
         path.remove(path.size()-1);
     }
 }
```

```java
//法二：使用map
class Solution {
    //结果集合
    List<List<Integer>> res = new ArrayList<>();
    //路径集合
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        getSubsequences(nums,0);
        return res;
    }
    private void getSubsequences( int[] nums, int start ) {
        if(path.size()>1 ){
            res.add( new ArrayList<>(path) );
            // 注意这里不要加return，要取树上的节点
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=start ;i < nums.length ;i++){
            if(!path.isEmpty() && nums[i]< path.getLast()){
                continue;
            }
            // 使用过了当前数字
            if ( map.getOrDefault( nums[i],0 ) >=1 ){
                continue;
            }
            map.put(nums[i],map.getOrDefault( nums[i],0 )+1);
            path.add(nums[i]);
            getSubsequences(nums,i+1);
            path.removeLast();
        }
    }
}
```




### 46.全排列🟥

> 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [1]
> 输出：[[1]]
> ```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] flag = new boolean[nums.length];//全排列每次都是从0开始搜，因此需要记录有没有用过这个数
        backtracking(nums,flag);
        return res;

    }

    public void backtracking(int[] nums,boolean[] flag){
        if(path.size()==nums.length){
            res.add(new ArrayList<>(path));
        }
        for(int i = 0;i<nums.length;i++){
            if(!flag[i]){
                path.addFirst(nums[i]);
                flag[i] = true;
                backtracking(nums,flag);
                flag[i] = false;
                path.pollFirst();
            }
        }
    }
}
```

### 47.全排列Ⅱ✅

> 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
>
> 示例 1：
>
> ```
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
> [1,2,1],
> [2,1,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```

```java
//首先全排列就要将自己给排除，然后这里还要检查
//去重一定对元素排列，比较相邻元素
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length];
        backtracking(nums,flag);
        return res;
    }

    public void backtracking(int[] nums,boolean[] flag){
        if(path.size()==nums.length){
            res.add(new ArrayList<>(path));
        }
        for(int i = 0;i< nums.length;i++){
            //去重检查,和之前的一样
            if(i>0&&nums[i]==nums[i-1]&&!flag[i-1]){
                continue;
            }
            if(!flag[i]){
                path.addFirst(nums[i]);
                flag[i] = true;
                backtracking(nums,flag);
                flag[i] = false;
                path.pollFirst();
            }
        }
    }
}
```

### [22. 括号生成🔴](https://leetcode.cn/problems/generate-parentheses/)

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> **示例 1：**
>
> ```
> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：["()"]
> ```

```java
//递归
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        dfs(n,n,"");
        return res;
    }

    public void dfs(int left,int right,String curStr){
        if(left==0&&right==0){
            res.add(curStr);
            return;
        }
        if(left>0){
            dfs(left-1,right,curStr+"(");
        }
        if(right>left){
            dfs(left,right-1,curStr+")");
        }
    }
}
```

```java
//回溯
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        backtrack(new StringBuilder(),0,0,n);
        return res;
    }

    public void backtrack(StringBuilder cur,int left,int right,int n){
        if(cur.length()==n*2){
            res.add(cur.toString());return;
        }
        if(left<n){
            cur.append("(");
            backtrack(cur,left+1,right,n);
            cur.deleteCharAt(cur.length()-1);
        }
        if(right<left){//注意这里是左右括号条件满足
            cur.append(")");
            backtrack(cur,left,right+1,n);
            cur.deleteCharAt(cur.length()-1);
        }
    }
}
```



### 332.重新安排行程🔴

> 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
>
> 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
>
> 例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
>
> 
>
> 示例 1：
>
> ```
> 输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
> 输出：["JFK","MUC","LHR","SFO","SJC"]
> ```
>
>
> 示例 2：
>
> ```
> 输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
> 输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
> 解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
> ```

```java
class Solution {
    private Deque<String> res;
    private Map<String, Map<String, Integer>> map; 

    private boolean backTracking(int ticketNum){
        if(res.size() == ticketNum + 1){
            return true;
        }
        String last = res.getLast();
        if(map.containsKey(last)){//防止出现null
            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){
                int count = target.getValue();
                if(count > 0){
                    res.add(target.getKey());
                    target.setValue(count - 1);
                    if(backTracking(ticketNum)) return true;
                    res.removeLast();
                    target.setValue(count);
                }
                
            }
        }
        return false;
    }

    public List<String> findItinerary(List<List<String>> tickets) {
        map = new HashMap<String, Map<String, Integer>>();
        res = new LinkedList<>();
        for(List<String> t : tickets){
            Map<String, Integer> temp;
            if(map.containsKey(t.get(0))){
                temp = map.get(t.get(0));
                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);
            }else{
                temp = new TreeMap<>();//升序Map
                temp.put(t.get(1), 1);
            }
            map.put(t.get(0), temp);

        }
        res.add("JFK");
        backTracking(tickets.size());
        return new ArrayList<>(res);
    }
}
```

### 51.N皇后✅🔁🔁🔴🔴

> n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
>
> 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
>
> 1. 不能同行
> 2. 不能同列
> 3. 不能同斜线
>
> ```
> 输入：n = 4
> 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
> 解释：如上图所示，4 皇后问题存在两个不同的解法。
> ```
>
> 示例 2：
>
> ```
> 输入：n = 1
> 输出：[["Q"]]
> ```

```c
//回溯三部曲
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
///////////////////////////////////////
void backtracking(棋盘大小n，当前行数row，结果矩阵chessboard){//一行一行取，到最后一行即结束
    if(row==n){
        result.add(chessboard);return;
    }
    //每次从新的一行开始，col控制列
    for(int col = 0;col<n;col++){
        if(isValid(row,col,chessboard,n)){
            chessboard[row][col] = 'Q';
            backtracking(n,row+1,chessboard);//确定本行的皇后后，开始进入下一行
            chessboard[row][col] = '.';
        }
    }
}
/////////////////验证是否合法
bool isValid(行，列，棋盘chessboard，大小n){
    //三步检测：本列；45°；135°//注意只有左上和右上需要检查，下面的行还不会有皇后
    for(int i = 0;i<row;i++){
        if(chessboard[i][col]=='Q') return false;
    }
    for(int i = row-1,j = col -1; i>=0&&j>=0;i--,j--){
        if(chessboard[i][j]=='Q') return false;
    }
    for(int i = row-1,j =col+1;i>=0&&j<n;i--,j++){
         if(chessboard[i][j]=='Q') return false;
    }
    return true;
}
///////////////////还需要一个方法将char[][]转化为list
 public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }
```

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for(char[] c : chessboard){//棋盘初始化
            Arrays.fill(c,'.');
        }
        backtracking(n,0,chessboard);
        return res;
    }
    //
    public void backtracking(int n,int row,char[][] chessboard){//当前第几行
        if(row == n){
            res.add(Array2List(chessboard));
            return;
        }
        //单层递归
        for(int col = 0;col<n;col++){
            if(isValid(n,row,col,chessboard)){//当前位置有效,把Q放下，进入下一次递归，然后取出Q
                chessboard[row][col] = 'Q';
                backtracking(n,row+1,chessboard);
                chessboard[row][col] = '.';
            }//不需要else continue，因为后面没有代码了
        }
    }

    public boolean isValid(int n,int row, int col, char[][] chessboard){
        //检查本列是否存在
        for(int i = 0;i<row;i++){
            if(chessboard[i][col]=='Q') return false;
        }
        //45°区域
        for(int i = row-1,j = col-1;i>=0&&j>=0;i--,j--){
            if(chessboard[i][j] == 'Q') return false;
        }
        //135°区域
        for(int i = row-1,j = col+1;i>=0&&j<=n-1;i--,j++){
            if(chessboard[i][j] == 'Q') return false;
        }
        return true;
    }
    //将数组转化为list的函数
    public List Array2List(char[][] chessboard){
        List<String> list = new ArrayList<>();
        for(char[] c : chessboard){
            list.add(String.copyValueOf(c));
        }
        return list;
    }
}
```

### 37.解数独🔁🔴🔴

> 编写一个程序，通过填充空格来解决数独问题。
>
> 数独的解法需 遵循如下规则：
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。
>
> ```
> 输入：
> board = 
> [["5","3",".",".","7",".",".",".","."],
> ["6",".",".","1","9","5",".",".","."],
> [".","9","8",".",".",".",".","6","."],
> ["8",".",".",".","6",".",".",".","3"],
> ["4",".",".","8",".","3",".",".","1"],
> ["7",".",".",".","2",".",".",".","6"],
> [".","6",".",".",".",".","2","8","."],
> [".",".",".","4","1","9",".",".","5"],
> [".",".",".",".","8",".",".","7","9"]]
> 输出：
> [["5","3","4","6","7","8","9","1","2"],
> ["6","7","2","1","9","5","3","4","8"],
> ["1","9","8","3","4","2","5","6","7"],
> ["8","5","9","7","6","1","4","2","3"],
> ["4","2","6","8","5","3","7","9","1"],
> ["7","1","3","9","2","4","8","5","6"],
> ["9","6","1","5","3","7","2","8","4"],
> ["2","8","7","4","1","9","6","3","5"],
> ["3","4","5","2","8","6","1","7","9"]]
> ```

```java
class Solution {
    public void solveSudoku(char[][] board) {
        dfs(board);
    }

    public boolean dfs(char[][] board){
        for(int i = 0;i<9;i++){
            for(int j = 0;j<9;j++){
                if(board[i][j]!='.') continue;
                for(char k ='1';k<='9';k++){
                    if(isValid(i,j,k,board)){
                        board[i][j] = k;
                        if(dfs(board)){
                            return true;
                        }
                        board[i][j]='.';
                    }
                }
                return false;//9个位置都试了还没找到说明棋盘无解
            }
        }
        return true;
    }

    /////////////////////////////////
    public boolean isValid(int row,int col, char val,char[][] board){
        for(int i = 0;i<9;i++){
            if(board[row][i]==val) return false;
        }
        for(int j = 0;j<9;j++){
            if(board[j][col]==val) return false;
        }
        //检查宫
        int startRow = (row/3)*3;
        int startCol = (col/3)*3;
        for(int i = startRow;i<startRow+3;i++){
            for(int j = startCol;j<startCol+3;j++){
                if(board[i][j]==val) return false;
            }
        }
        return true;
    }
}
```



## 贪心算法

### 455.分发饼干✅

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
>
> 示例 1:
>
> ```
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```
>
> 示例 2:
>
> ```
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
> ```

```java
class Solution {
     public int findContentChildren(int[] g, int[] s) {
            Arrays.sort(g);
            Arrays.sort(s);
            int j = 0;
            //要求s>=g,
            int num = 0;//以满足的数量
            for(int i = 0;i<s.length;i++){
                if(g[j]<=s[i]){
                    num++;j++;
                }
                if(j==g.length) break;
            }

            return num;
        }
}
```



### 376.摆动序列✅🔁🔁

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
>
> 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
> 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
>
> 
>
> 示例 1：
>
> ```
> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
> ```

局部最优：当前差值和上一次差值一正一负

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            //得到当前差值
            curDiff = nums[i] - nums[i - 1];
            //如果当前差值和上一个差值为一正一负
            //等于0的情况表示初始时的preDiff
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {//注意在preDiff为0时
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```


### 53.最大子数组和🟩

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 子数组 是数组中的一个连续部分。
>
> 示例 1：
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [5,4,-1,7,8]
> 输出：23
> ```

局部最优：当连续和为负时立刻放弃

全局最优：选取最大的局部连续和

```java
//本题返回值即可，不需要记录位置
class Solution {
    public int maxSubArray(int[] nums) {
        int count = 0  ;
        int result = Integer.MIN_VALUE;
        for(int i = 0;i<nums.length;i++){
            count += nums[i];
            if(count> result){
                result = count;
            }
            if(count<=0){
                count=0;
            }
        }
        return result;
    }
}
```



### 122.买股票最佳时机Ⅱ✅🔁

> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
>
> 返回 你能获得的 最大利润 。
>
> 示例 1：
>
> ```
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>   总利润为 4 + 3 = 7 。
> ```
>
> 示例 2：
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>   总利润为 4 。
> ```
>
> 示例 3：
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
> ```

```java
//？？？已崩溃：只要今天比昨天大，就计入利润
```

### 55.跳跃游戏🔁🔴

> 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
> 数组中的每个元素代表你在该位置可以跳跃的**最大**长度。
>
> 判断你是否能够到达最后一个下标。
>
> 
>
> 示例 1：
>
> ```
> 输入：nums = [2,3,1,1,4]
> 输出：true
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [3,2,1,0,4]
> 输出：false
> 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
> ```

```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length==1) return true;
        int range = nums[0];
        for(int i = 0;i<=range;i++){
            if(nums[i]+i>range) range = nums[i]+i;
            if(range>=nums.length-1) return true;
        }
        return false;
    }
}
```

### 45.跳跃游戏Ⅱ🔁🔴

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。
>
> 
>
> 示例 1:
>
> ```
> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>   从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```
>
> 示例 2:
>
> ```
> 输入: nums = [2,3,0,1,4]
> 输出: 2
> ```

每跳一次更新下覆盖范围，直到可接触到终点，没到就步数+1

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length==1) return 0; 
        int curRange = 0;
        int nextRange = 0;
        int step = 0;
        for(int i = 0;i<nums.length-1;i++){
            nextRange = Math.max(i +nums[i],nextRange);
            if(i==curRange){
                curRange = nextRange;
                step++;
            }
        }
        return step;
    }
}
```




### 1005.K次取反后最大化的数组和🔁

> 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
>
> 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
> 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
>
> 以这种方式修改数组后，返回数组 可能的最大和 。
>
> 示例 1：
>
> ```
> 输入：nums = [4,2,3], k = 1
> 输出：5
> 解释：选择下标 1 ，nums 变为 [4,-2,3] 。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [3,-1,0,2], k = 3
> 输出：6
> 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [2,-3,-1,5,-4], k = 2
> 输出：13
> 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
> ```

```java
class Solution {
    public int largestSumAfterKNegations(int[] A, int k) {
        if (A.length == 1) return k % 2 == 0 ? A[0] : -A[0];
        Arrays.sort(A);
        int sum = 0;
        int idx = 0;
        for (int i = 0; i < K; i++) {
            if (i < A.length - 1 && A[idx] < 0) {
                A[idx] = -A[idx];
                if (A[idx] >= Math.abs(A[idx + 1])) idx++;
                continue;
            }
            A[idx] = -A[idx];
        }

        for (int i = 0; i < A.length; i++) {
            sum += A[i];
        }
        return sum;
    }
}
```

```java
//解法二 效率很低
class Solution {
    public int largestSumAfterKNegations(int[] nums, int K) {
    	// 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
	nums = IntStream.of(nums)
		     .boxed()
		     .sorted((o1, o2) -> Math.abs(o2) - Math.abs(o1))
		     .mapToInt(Integer::intValue).toArray();
	int len = nums.length;	    
	for (int i = 0; i < len; i++) {
	    //从前向后遍历，遇到负数将其变为正数，同时K--
	    if (nums[i] < 0 && K > 0) {
	    	nums[i] = -nums[i];
	    	K--;
	    }
	}
	// 如果K还大于0，那么反复转变数值最小的元素，将K用完

	if (K % 2 == 1) nums[len - 1] = -nums[len - 1];
	return Arrays.stream(nums).sum();

    }
}
```

### 134.加油站✅

> 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
>
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
>
> 
>
> 示例 1:
>
> ```
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> ```
>
> 示例 2:
>
> ```
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
> ```

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //初始检查
        int len = gas.length;
        int sum = 0;
        int curRest = 0;
        int start = 0;

        for(int i = 0;i<len;i++){
            curRest += (gas[i]-cost[i]);
            sum +=(gas[i]-cost[i]);
            if(curRest<0){
                curRest = 0;
                start = i+1;
            }
        }
        if(sum<0) return -1;
        if(start>=len) return -1;
        return start;
    }
}
```



### 135.分发糖果🔁

> n 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
>
> 你需要按照以下要求，给这些孩子分发糖果：
>
> 每个孩子至少分配到 1 个糖果。
> 相邻两个孩子评分更高的孩子会获得更多的糖果。
> 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
>
> 示例 1：
>
> ```
> 输入：ratings = [1,0,2]
> 输出：5
> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
> ```
>
> 示例 2：
>
> ```
> 输入：ratings = [1,2,2]
> 输出：4
> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
>   第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
> ```

```java
//思路一样，出错,都是前后循环一遍，注意
class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] candy = new int[len];
        candy[0] = 1;
        for(int i = 1;i<len;i++){
            if(ratings[i]>ratings[i-1]){
                candy[i] = candy[i-1]+1;
            }else{
                candy[i] = 1;
            }
        }
        for(int j = len-2;j>=0;j--){
            if(ratings[j]>ratings[j+1]){
                candy[j] = Math.max(candy[j],candy[j+1]+1);
            }
        }
        int sum=0;
        for(int c : candy){
            sum+=c;
        }
        return sum;
    }
}
```



### 860.柠檬水找零✅

> 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
>
> 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
>
> 注意，一开始你手头没有任何零钱。
>
> 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
>
> 示例 1：
>
> ```
> 输入：bills = [5,5,5,10,20]
> 输出：true
> 解释：
> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
> 由于所有客户都得到了正确的找零，所以我们输出 true。
> ```
>
> 示例 2：
>
> ```
> 输入：bills = [5,5,10,10,20]
> 输出：false
> 解释：
> 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
> 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
> 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
> 由于不是每位顾客都得到了正确的找零，所以答案是 false。
> ```

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        //纯模拟
    int five = 0;
    int ten =0;
    int twenty = 0;
    for(int i : bills){
        if(i ==5 ) five++;
        if(i == 10){
            five--;
            if(five<0) return false;
            ten++;
        }
        if(i == 20){
            //先用10块的找
            if(ten>0&&five>0){
                ten--;five--;
            }else if(five<=0){
                return false;
            }else if(ten<=0&&five>=3){
                five-=3;
            }else{
                return false;
            }
        }
    }
    return true;
    }
}
```

### 406.根据身高重建队列🔁🔁

> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
>
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
>
> 示例 1：
>
> ```
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> 解释：
> 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
> 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
> 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
> 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
> 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
> ```
>
> 示例 2：
>
> ```
> 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
> 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
> ```

```java
//先学习Arrays.sort
Arrays.sort(people,(a,b)->{
    if(a[0]==b[0])return a[1]-b[1];//这是升序
    return b[0]-a[0];//这是降序
})
```

```java
LinkedList<int[]> que = new LinkedList<>();
for(int[] p : people){
    que.add(p[1],p);//插到第几个位置就保证了前面有几个更大的。
}
return que.toArray(new int[people.length][]);
```

### 452.用最少数量的箭引爆气球🔁🔁🔴

> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。
>
> 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。
>
> 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。
>
>
> 示例 1：
>
> ```
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> -在x = 6处射出箭，击破气球[2,8]和[1,6]。
> -在x = 11处发射箭，击破气球[10,16]和[7,12]。
> ```
>
> 示例 2：
>
> ```
> 输入：points = [[1,2],[3,4],[5,6],[7,8]]
> 输出：4
> 解释：每个气球需要射出一支箭，总共需要4支箭。
> ```
>
> 示例 3：
>
> ```
> 输入：points = [[1,2],[2,3],[3,4],[4,5]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> 
> 在x = 2处发射箭，击破气球[1,2]和[2,3]。
> 在x = 4处射出箭，击破气球[3,4]和[4,5]。
> ```

```java
if(points.length==0) return 0;
Arrays.sort(points,(o1,o2)->Integer.compare(o1[0],o2[0]));

int count =1;
for(int i = 1;i<points.length;i++){
    if(points[i][0]>points[i-1][1]){
        count++;
    }else{
        points[i][1] = Math.min(points[i][1],points[i-1][1]);//很关键的点，每次处理最小的点就能
    }
}
return count;
```



```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length ==0) return 0;
        Arrays.sort(points,(o1,o2)->Integer.compare(o1[0]-o2[0]));

        int res = 1;
        for(int i = 1;i<points.length;i++){
            if(points[i-1][1]<points[i][0]){
                res++;
            }else{
                points[i][1] = Math.min(points[i-1][1],points[i][1]);
            }
        }
        return res;
    }
}
```



### 435.无重叠区间🔴

> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。
>
> 示例 1:
>
> ```
> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
> 输出: 1
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。
> ```
>
> 示例 2:
>
> ```
> 输入: intervals = [[1,2], [1,2],[1,2]]
> 输出: 2
> 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
> ```
>
> 示例 3:
>
> ```
> 输入: intervals = [[1,2],[2,3]]
> 输出: 0
> 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
> ```
>
> 

### 763.划分字母区间✅

> 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
>
> 示例：
>
> ```
> 输入：S = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca", "defegde", "hijhklij"。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
> ```

```java
//自己想的
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> result = new ArrayList<>();
        if(s.length()==1){
            result.add(1);
            return result;
        }
        List<List<Integer>> range = getRange(s);
        int start = 0;
        int end = 0;
        int startP = range.get(0).get(0);
        for(List<Integer> arr : range){
            if(arr.get(0)>end) {
                result.add(end-startP+1);
                startP = arr.get(0);
            }        
            end = Math.max(end,arr.get(1));
        }
        result.add(end-startP+1);
         return result;
    }
    public List<List<Integer>> getRange(String s){
            boolean[] flag = new boolean[26];//用于存放所有字母之后出现的set
            List<List<Integer>> range = new ArrayList<>();
            for(int i = 0;i<s.length();i++){
                char c = s.charAt(i);
                if(!flag[c - 'a']){//第一次出现
                    //1、修改flag数组
                    //2、得出最后的坐标，写入range
                    flag[c-'a'] = true;
                    List<Integer> temp = new ArrayList<>();
                    temp.add(i);
                    temp.add(s.lastIndexOf(c));
                    range.add(temp);
                }
            }
            return range;//得到的已经是按起始位置排好序的
        }
}
```

```java
//他人解法
class Solution {
    public List<Integer> partitionLabels(String S) {
        List<Integer> list = new LinkedList<>();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }
        int idx = 0;
        int last = -1;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i] - 'a']);
            if (i == idx) {
                list.add(i - last);
                last = i;
            }
        }
        return list;
    }
}
```

### 56.合并区间🔴 

> 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
>
> 示例 1：
>
> ```
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```
>
> 示例 2：
>
> ```
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        List<int[]> ans = new ArrayList<>();
        //  先对区间进行排序
        Arrays.sort(intervals,(o1,o2)->{
            if(o1[0]==o2[0]){
                return o1[1]-o2[1];//升序
            }
            return o1[0]-o2[0];
        });
        for(int i=0;i<n;){
            int[] inval = intervals[i];
            int l = inval[0], r = inval[1];
            while(i<n && intervals[i][0] <= r){
                r =  Math.max(r, intervals[i][1]);
                i++;
            }
            ans.add(new int[]{l, r});
        }
        int[][] res = new int[ans.size()][2];
        int idx = 0;
        for(int[] tmp : ans){
            res[idx][0] = tmp[0];
            res[idx++][1] = tmp[1];
        }
        return res;
    }
}
```



### 738.单调递增的数字🔁

> 复习 `String.valueOf()`
>
> ​	`Integer.parseInt()`

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);//整型转string
        int len = s.length();
        char[] chars = s.toCharArray();
        int flag = len;
        for(int i = len-1;i>=1;i--){
            if(chars[i]<chars[i-1]){
                flag = i;
                chars[i-1]--;
            }
        }
        for(int i  = flag;i<len;i++){
            chars[i] ='9';
        }
        return Integer.parseInt(new String(chars));
    }
}
```



### 714.买股票最佳时机含手续费

### 968.监控二叉树

### 



## 前缀树

### 208.实现前缀树🔁

> **[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
>
> 请你实现 Trie 类：
>
> - `Trie()` 初始化前缀树对象。
> - `void insert(String word)` 向前缀树中插入字符串 `word` 。
> - `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
> - `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。
>
> **示例：**
>
> ```
> 输入
> ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
> [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
> 输出
> [null, null, true, false, true, null, true]
> 
> 解释
> Trie trie = new Trie();
> trie.insert("apple");
> trie.search("apple");   // 返回 True
> trie.search("app");     // 返回 False
> trie.startsWith("app"); // 返回 True
> trie.insert("app");
> trie.search("app");     // 返回 True
> ```
>
> 

```java
class Trie {

private class TrieNode{
    private boolean isEnd;
    private TrieNode[] son ;
    public TrieNode(){
        isEnd = false;
        son = new TrieNode[26];
    }
}

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        //拆入单词
        TrieNode cur = root;//都是从根节点开始
        for(int i = 0,len = word.length(),ch;i<len;i++){
            ch = word.charAt(i)-'a';
            if(cur.son[ch]==null){
                cur.son[ch] = new TrieNode();
            }
            cur = cur.son[ch];
        }
        //结束后加上end
        cur.isEnd = true;
    }
    
    public boolean search(String word) {
        //一直找下去，返回end
        TrieNode cur = root;
        for(char c:word.toCharArray()){
            c-='a';
            if(cur.son[c]==null){
                return false;
            }
            cur = cur.son[c];
        }
        return cur.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for(char c:prefix.toCharArray()){
            c -='a';
            if(cur.son[c]==null){
                return false;
            }
            cur = cur.son[c];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

### [648. 单词替换](https://leetcode.cn/problems/replace-words/)

> 在英语中，我们有一个叫做 `词根`(root) 的概念，可以词根**后面**添加其他一些词组成另一个较长的单词——我们称这个词为 `继承词`(successor)。例如，词根`an`，跟随着单词 `other`(其他)，可以形成新的单词 `another`(另一个)。
>
> 现在，给定一个由许多**词根**组成的词典 `dictionary` 和一个用空格分隔单词形成的句子 `sentence`。你需要将句子中的所有**继承词**用**词根**替换掉。如果**继承词**有许多可以形成它的**词根**，则用**最短**的词根替换它。
>
> 你需要输出替换之后的句子。
>
> 
>
> **示例 1：**
>
> ```
> 输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
> 输出："the cat was rat by the bat"
> ```
>
> **示例 2：**
>
> ```
> 输入：dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
> 输出："a a b c"
> ```

### [1894. 找到需要补充粉笔的学生编号](https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/)

> 一个班级里有 `n` 个学生，编号为 `0` 到 `n - 1` 。每个学生会依次回答问题，编号为 `0` 的学生先回答，然后是编号为 `1` 的学生，以此类推，直到编号为 `n - 1` 的学生，然后老师会重复这个过程，重新从编号为 `0` 的学生开始回答问题。
>
> 给你一个长度为 `n` 且下标从 `0` 开始的整数数组 `chalk` 和一个整数 `k` 。一开始粉笔盒里总共有 `k` 支粉笔。当编号为 `i` 的学生回答问题时，他会消耗 `chalk[i]` 支粉笔。如果剩余粉笔数量 **严格小于** `chalk[i]` ，那么学生 `i` 需要 **补充** 粉笔。
>
> 请你返回需要 **补充** 粉笔的学生 **编号** 。
>
> **示例 1：**
>
> ```
> 输入：chalk = [5,1,5], k = 22
> 输出：0
> 解释：学生消耗粉笔情况如下：
> - 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。
> - 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。
> - 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。
> - 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。
> - 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。
> - 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。
> 编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。
> ```
>
> **示例 2：**
>
> ```
> 输入：chalk = [3,4,1,2], k = 25
> 输出：1
> 解释：学生消耗粉笔情况如下：
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。
> - 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。
> - 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。
> - 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。
> - 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。
> - 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。
> - 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。
> 编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。
> ```
>
> 





### 211

### 677

### 676

### 745