🔴🔁✅

### 11/12 [790. 多米诺和托米诺平铺](https://leetcode.cn/problems/domino-and-tromino-tiling/)🔴

> 有两种形状的瓷砖：一种是 `2 x 1` 的多米诺形，另一种是形如 "L" 的托米诺形。两种形状都可以旋转。
>
> <img src="../Resources/lc-domino.jpg" alt="img" style="zoom:80%;" />
>
> 给定整数 n ，返回可以平铺 `2 x n` 的面板的方法的数量。**返回对** `109 + 7` **取模** 的值。
>
> 平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。
>
> **示例 1:**
>
> <img src="../Resources/lc-domino1.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入: n = 3
> 输出: 5
> 解释: 五种不同的方法如上所示。
> ```
>
> **示例 2:**
>
> ```
> 输入: n = 1
> 输出: 1
> ```

### [805. 数组的均值分割](https://leetcode.cn/problems/split-array-with-same-average/)🔴

> 给定你一个整数数组 `nums`
>
> 我们要将 `nums` 数组中的每个元素移动到 `A` 数组 或者 `B` 数组中，使得 `A` 数组和 `B` 数组不为空，并且 `average(A) == average(B)` 。
>
> 如果可以完成则返回`true` ， 否则返回 `false` 。
>
> **注意：**对于数组 `arr` ,  `average(arr)` 是 `arr` 的所有元素除以 `arr` 长度的和。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,4,5,6,7,8]
> 输出: true
> 解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [3,1]
> 输出: false
> ```

### 11.15/[1710. 卡车上的最大单元数🔁](https://leetcode.cn/problems/maximum-units-on-a-truck/)

> 请你将一些箱子装在 **一辆卡车** 上。给你一个二维数组 `boxTypes` ，其中 `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]` ：
>
> - `numberOfBoxesi` 是类型 `i` 的箱子的数量。
> - `numberOfUnitsPerBoxi` 是类型 `i` 每个箱子可以装载的单元数量。
>
> 整数 `truckSize` 表示卡车上可以装载 **箱子** 的 **最大数量** 。只要箱子数量不超过 `truckSize` ，你就可以选择任意箱子装到卡车上。
>
> 返回卡车可以装载 **单元** 的 **最大** 总数*。*
>
>  
>
> **示例 1：**
>
> ```
> 输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
> 输出：8
> 解释：箱子的情况如下：
> - 1 个第一类的箱子，里面含 3 个单元。
> - 2 个第二类的箱子，每个里面含 2 个单元。
> - 3 个第三类的箱子，每个里面含 1 个单元。
> 可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
> 单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
> ```

计数排序：很好的方法！

```java
class Solution {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
        int count = 0;
		int[] ans = new int[1001];
		for (int[] is : boxTypes) {
			ans[is[1]] += is[0];
		}
		for (int i = ans.length - 1; i > 0; i--) {
			if (ans[i] != 0) {
				if (truckSize > ans[i]) {
					count += ans[i] * i;
					truckSize -= ans[i];
				} else {
					return count + truckSize * i;
				}
			}
		}
		return count;
    }
}
```

### 11.16/[775. 全局倒置与局部倒置🔴](https://leetcode.cn/problems/global-and-local-inversions/)

> 给你一个长度为 `n` 的整数数组 `nums` ，表示由范围 `[0, n - 1]` 内所有整数组成的一个排列。
>
> **全局倒置** 的数目等于满足下述条件不同下标对 `(i, j)` 的数目：
>
> - `0 <= i < j < n`
> - `nums[i] > nums[j]`
>
> **局部倒置** 的数目等于满足下述条件的下标 `i` 的数目：
>
> - `0 <= i < n - 1`
> - `nums[i] > nums[i + 1]`
>
> 当数组 `nums` 中 **全局倒置** 的数量等于 **局部倒置** 的数量时，返回 `true` ；否则，返回 `false` 。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,0,2]
> 输出：true
> 解释：有 1 个全局倒置，和 1 个局部倒置。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,0]
> 输出：false
> 解释：有 2 个全局倒置，和 1 个局部倒置。
> ```

```java
//维护后缀最小值
class Solution {
    public boolean isIdealPermutation(int[] nums) {
        int n = nums.length, minSuff = nums[n - 1];
        for (int i = n - 3; i >= 0; i--) {
            if (nums[i] > minSuff) {
                return false;
            }
            minSuff = Math.min(minSuff, nums[i + 1]);
        }
        return true;
    }
}
```







### [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

> 给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
>
> **示例 1：**
>
> ```
> 输入：nums = [5,2,6,1]
> 输出：[2,1,1,0] 
> 解释：
> 5 的右侧有 2 个更小的元素 (2 和 1)
> 2 的右侧仅有 1 个更小的元素 (1)
> 6 的右侧有 1 个更小的元素 (1)
> 1 的右侧有 0 个更小的元素
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-1]
> 输出：[0]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [-1,-1]
> 输出：[0,0]
> ```

#### 二分法

#### 归并排序

#### 树状数组

[算法学习笔记(2) : 树状数组 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93795692)

​	BIT(Binary Index Tree)

#### 线段树

#### 二叉搜索树

### [11.17/792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

> 给定字符串 `s` 和字符串数组 `words`, 返回 *`words[i]` 中是`s`的子序列的单词个数* 。
>
> 字符串的 **子序列** 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。
>
> - 例如， `“ace”` 是 `“abcde”` 的子序列。
>
> **示例 1:**
>
> ```
> 输入: s = "abcde", words = ["a","bb","acd","ace"]
> 输出: 3
> 解释: 有三个是 s 的子序列的单词: "a", "acd", "ace"。
> ```
>
> **Example 2:**
>
> ```
> 输入: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
> 输出: 2
> ```

二分 

```java
public int numMatchSubseq(String s,String[] words){
    List<Integer> pos[] = new List[26];//存26个字母的列表数组，每个下标存ArrayList
    char c[] = s.toCharArray();
    for(int i = 0;i<26;i++){
        pos[i] =new ArrayList<>();
        pos[i].add(-1);
    }
    for(int i = 0;i<c.length;i++){
        pos[c[i]-'a'].add(i);//每个字母出现的位置
    }
    int ans = words.length;
    for(int i =0;i<words.length;i++){
        int pre = -1;
        for(char ch:words[i].toCharArray()){5
            int next = nextPos(pos,pre,ch-'a');
            if(next==-1){
                ans--;break;
            }
            pre = next;
        }
    }
    return ans;
}

//二分查找
int nextPos(List<Integer> pos[],int idx ,int ch){
    if(pos[ch].get(pos[ch].size()-1)<=idx){return -1;}
        int l=0,r=pos[ch].size()-1;
        while(l<r){
            int mid=(l+r)>>1;
            if(pos[ch].get(mid)>idx){r=mid;}
            else{l=mid+1;}
            if(l==r-1){
                if(pos[ch].get(l)>idx){r=l;}
                break;
            }
        }
        return pos[ch].get(r);
}
```

```java
//next数组
class Solution {
    public int numMatchingSubseq(String s, String[] words) {
        char c[]=s.toCharArray();
        int next[][]=new int[c.length+1][26];
        int pos[]=new int[26];//每个字母第一次出现的位置，匹配符合贪心
        Arrays.fill(pos,-1);
        for(int i=0;i<=c.length;i++){Arrays.fill(next[i],-1);}
        for(int i=c.length-1;i>=0;i--){//倒叙
            pos[c[i]-'a']=i;
            for(int j=0;j<26;j++){next[i][j]=pos[j];}            
        }
        int ans=words.length;
        for(int i=0;i<words.length;i++){
            int pre=0;
            char c1[]=words[i].toCharArray();
            for(int j=0;j<c1.length;j++){
                pre=next[pre][c1[j]-'a'];
                if(pre<0){
                    ans--;
                    break;
                }
                pre++;
            }
        }
        return ans;
    }
}
```

### 392.判断子序列

DP做法:

预处理t中每一个字符下一次出现的位置

```java
int n = s.length(), m = t.length();
int[][] f = new int[m+1][26];
for(int i = 0;i<26;i++){
    f[m][i] = m;//初始化：第一次出现的位置为末尾
}


```

### [799. 香槟塔🔴](https://leetcode.cn/problems/champagne-tower/)

> 我们把玻璃杯摆成金字塔的形状，其中 **第一层** 有 `1` 个玻璃杯， **第二层** 有 `2` 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。
>
> 从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）
>
> 例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。
>
> <img src="../Resources/tower.png" alt="img" style="zoom:33%;" />
>
> 现在当倾倒了非负整数杯香槟后，返回第 `i` 行 `j` 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ `i` 和 `j` 都从0开始）。
>
> ```
> 示例 1:
> 输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
> 输出: 0.00000
> 解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。
> 
> 示例 2:
> 输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
> 输出: 0.50000
> 解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。
> ```
>
> **示例 3:**
>
> ```
> 输入: poured = 100000009, query_row = 33, query_glass = 17
> 输出: 1.00000
> ```

模拟：将所有一次性倒入第一杯

```java
public double champagneTower(int poured, int query_row, int query_glass) {
    double[] row = {poured};//将所有一次性倒入第一杯
    for(int i= 1;i<=query_row;i++){
        double[] nextRow = new double[i+1];
        for(int j = 0;j<i;j++){
            double volume = row[j];
            if(volume>1){
                nextRow[j] +=(volume-1)/2;
                nextRow[j+1] += (volume-1)/2;
            }
        }
        row = nextRow;
    }
    return Math.min(1,row[query_glass]);
}
```

### [878. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/)

> 一个正整数如果能被 `a` 或 `b` 整除，那么它是神奇的。
>
> 给定三个整数 `n` , `a` , `b` ，返回第 `n` 个神奇的数字。因为答案可能很大，所以返回答案 **对** `109 + 7` **取模** 后的值。
>
> **示例 1：**
>
> ```
> 输入：n = 1, a = 2, b = 3
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 4, a = 2, b = 3
> 输出：6
> ```

```java
class Solution {
    public int nthMagicalNumber(int n, int a, int b) {
        // a、b有倍数关系，可直接O(1)内返回。
        if(a % b == 0)return nthMagicalNumber(n, b);
        if(b % a == 0)return nthMagicalNumber(n, a);

        //求a和b的最小公倍数p
        int p = a, i = 1;
        while(p * i % b != 0)i++;
        p = p * i;

        //二分查找，直到某个数之前恰好有n个神奇数字。
        long l = 1, r = (long)n * Math.min(a, b);
        while(l <= r){
            long m = l + (r - l)/2;
            // 求m之前的神奇数字的个数：a的倍数的数量，加上b的倍数的数量，再减去a和b的公倍数的数量
            if( m / a + m / b - m / p >= n)r = --m;
            else l = ++m;
        }
        
        return (int)(l%1000000007);
    }

    public int nthMagicalNumber(int n, int a) {
        return (int)((long)n * a % 1000000007);
    }
}
```

### [795. 区间子数组个数🔴🔴](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)

> 给你一个整数数组 `nums` 和两个整数：`left` 及 `right` 。找出 `nums` 中连续、非空且其中最大元素在范围 `[left, right]` 内的子数组，并返回满足条件的子数组的个数。
>
> 生成的测试用例保证结果符合 **32-bit** 整数范围。
>
> **示例 1：**
>
> ```
> 输入：nums = [2,1,4,3], left = 2, right = 3
> 输出：3
> 解释：满足条件的三个子数组：[2], [2, 1], [3]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,9,2,5,6], left = 2, right = 8
> 输出：7
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `0 <= nums[i] <= 109`
> - `0 <= left <= right <= 109`

```java
class Solution {
    public int numSubarrayBoundedMax(int[] A, int L, int R) {
        // 最大元素满足大于等于L小于等于R的子数组个数 = 最大元素小于等于R的子数组个数 - 最大元素小于L的子数组个数
        return numSubarrayBoundedMax(A, R) - numSubarrayBoundedMax(A, L - 1);
    }

    private int numSubarrayBoundedMax(int[] A, int Max) {
        int res = 0;
        int numSubarry = 0;
        for (int num : A) {
            if (num <= Max) {
                numSubarry++;
                res += numSubarry;
            } else {
                numSubarry = 0;
            }
        }
        return res;
    }
}
```

```c++
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& A, int L, int R) {
        int j = -1, temp = 0, ans = 0;
        for(int i = 0; i < A.size(); i++) {
            if(A[i] > R)
                j = i;
            if(A[i] >= L)
                temp = i - j;
            ans += temp;
        }
        return ans;
    }
};
```

### [809. 情感丰富的文字](https://leetcode.cn/problems/expressive-words/)

> 有时候人们会用重复写一些字母来表示额外的感受，比如 `"hello" -> "heeellooo"`, `"hi" -> "hiii"`。我们将相邻字母都相同的一串字符定义为相同字母组，例如："h", "eee", "ll", "ooo"。
>
> 对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 `c` ），然后往其中添加相同的字母 `c` 使其长度达到 3 或以上。
>
> 例如，以 "hello" 为例，我们可以对字母组 "o" 扩张得到 "hellooo"，但是无法以同样的方法得到 "helloo" 因为字母组 "oo" 长度小于 3。此外，我们可以进行另一种扩张 "ll" -> "lllll" 以获得 "helllllooo"。如果 `s = "helllllooo"`，那么查询词 "hello" 是可扩张的，因为可以对它执行这两种扩张操作使得 `query = "hello" -> "hellooo" -> "helllllooo" = s`。
>
> 输入一组查询单词，输出其中可扩张的单词数量。
>
> **示例：**
>
> ```
> 输入： 
> s = "heeellooo"
> words = ["hello", "hi", "helo"]
> 输出：1
> 解释：
> 我们能通过扩张 "hello" 的 "e" 和 "o" 来得到 "heeellooo"。
> 我们不能通过扩张 "helo" 来得到 "heeellooo" 因为 "ll" 的长度小于 3 。
> ```

```java
class Solution {
    public int expressiveWords(String s, String[] words) {
        int ans = 0;
        char[] arr1 = s.toCharArray();
        for (String word : words) ans += ok(arr1, word.toCharArray()) ? 1 : 0;
        return ans;
    }
    boolean ok(char[] arr1, char[] arr2) {  
        int p1 = 0, p2 = 0;
        while (p1 < arr1.length && p2 < arr2.length) { 
            int cnt1 = 0, cnt2 = 0;
            char c = arr1[p1];
            while (p1 < arr1.length && arr1[p1] == c) {p1++; cnt1++;}
            while (p2 < arr2.length && arr2[p2] == c) {p2++; cnt2++;} 
            if (cnt1 < cnt2 || (cnt1 > cnt2 && cnt1 < 3)) return false; 
        }
        return p1 == arr1.length && p2 == arr2.length;
    }
}
```

