1️⃣：✅🔁🔴

2️⃣：🟩🟨🟥

3️⃣：🔰

https://github.com/sedatives-boo/Typora.git

## 数组

### 704.二分查找🟥🟨🟥

```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       下标
解释: 9 出现在 nums 中并且下标为 4，不在则返回-1
```

```java
class Solution{
            public int search(int[] nums,int target){
                int low,high,mid=-1;
                low = 0;
                high = nums.length-1;
                while(low<=high){
                    mid = (low+high)/2;
                    if(target==nums[mid])
                        return mid;
                    if(target>nums[mid])
                        low = mid +1;
                    else
                        high = mid -1;
                }
                return -1;
            }
        }
//时间效率100%，内存效率为42.2MB，6%
```

来自他人的解法：

```java
// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
```

<font color="red">二刷错误</font>:

```
left = nums.length; //没有-1
while(right<left)   //没有 =
```



### 34.在排序数组中查找元素的第一个和最后一个位置🟥

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

输入：nums = [], target = 0
输出：[-1,-1]
```

```java
//自己提交5次错的之后的结果，所有的用例都通过
class Solution {
    public int[] searchRange(int[] nums, int target) {
            int[] res = new int[]{-1,-1};
            int i = 0,j = 0;
            if(nums.length==0){
                return new int[]{-1,-1};
            }
            for(;nums[i]<target&&i<nums.length-1;i++);//找到第一个的下标
            if(i > nums.length) return new int[]{-1,-1};
            if(nums[i]==target){
                if(i == nums.length){
                    return new int[]{nums.length-1,nums.length-1};
                }
                for(j=i;j<nums.length&&nums[j]==target;j++);
                res = new int[]{i,j-1};
            }
            return res;
    }
}
//时间100%，内存44.8MB，8%
```

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
    int index = binarySearch(nums, target);
    if(index==-1){
        return new int[]{-1,-1};
    }
    int left = index;
    int right = index;
    //寻找左右边界
    while(left-1>=0&&nums[left-1]==nums[index]){
        left--;
    }
    while(right+1<nums.length&&nums[right+1]==nums[index]){
        right++;
    }
    return new int[] {left, right};
}

public int binarySearch(int[] nums,int target){
    int left = 0;
    int right = nums.length-1;
    int mid;
    while(left<=right){
        mid = (left+right)/2;
       if (nums[mid] == target) {
				return mid;
			} else if (nums[mid] < target) {
				left = mid + 1;
			} else {
				right = mid - 1; // 不变量：左闭右闭区间
			}
		}
		return -1; // 不存在
    }
}
```

### 27.移除元素🟥🟩

跳过暴力解法O(n<sup>2</sup>)，学习**双指针法**O(n)（快慢指针）：：快慢指针的思想！！！！

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并**原地**修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

```java
class Solution{
    int fastIndex = 0;
    int slowIndex;
    for(slowIndex = 0;fastIndex <nums.length;fastIndex++){//循环结束：快指针到末尾
        if(nums[fastIndex] !=val){// 快指针不等于val时，将快指针赋给慢指针
            nums[slowIndex] =nums[fastIndex];
            slowIndex++;
        }
        //当快指针等于val时，即可跳过
    }
    return slowIndex;
}
```

### 26.删除有序数组重复项🟥🟩

> 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
>
> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2,_]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

```java
//通过比对上一题做对
class Solution {
    public int removeDuplicates(int[] nums) {
        int fastIndex = 1;
        int slowIndex;
        for(slowIndex = 0;fastIndex<nums.length;fastIndex++){//快指针是遍历整个数组的，而慢指针保持于慢指针不同的前一个元素
            if(nums[fastIndex] != nums[fastIndex-1]){//在等的情况下，慢指针才能移动
                slowIndex++;
                nums[slowIndex] = nums[fastIndex];
                }
            }
        return slowIndex+1;
    }
}
//内存42.9MB，39%
```

### 283.移动0🟥🟥🟩

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> ```
> 输入: nums = [0]
> 输出: [0]
> ```

他人解法：采用快慢指针

```java
   //思路：设置一个index，表示非0数的个数，循环遍历数组，
    // 如果不是0，将非0值移动到第index位置,然后index + 1
    //遍历结束之后，index值表示为非0的个数，再次遍历，从index位置后的位置此时都应该为0
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[index] = nums[i];
                index++;
            }
        }

        for (int i = index; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
```

### 977.有序数组平方🟩

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
>
> 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
>
> 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]

采用双指针法

```java
class Solution{
    public int[] SortedSquare(int[] nums){
        if(nums.length==0) return nums;
        int i = 0, j = nums.length-1;
        int[] newArray = new int[nums.length];
        int k = j;
        while(i!=j){
            if(nums[i]*nums[i]>=nums[j]*nums[j]){
                newArray[k--] = nums[i]*nums[i];
                i++;
            }
            else{
                newArray[k--] = nums[j]*nums[j];
                j--;
            }
        }
        newArray[k] = nums[j]*nums[j];
        return newArray;
    }
}
```

注意设计测试所有用例

### 209.长度最小子数组🟥🟨🟩

学习**滑动窗口**

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
>
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
>
>  
>
> 示例 1：
>
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
>
> 示例 2：
> 输入：target = 4, nums = [1,4,4]
> 输出：1
>
> 示例 3：
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;//2147483647，其二进制为0111 1111 1111 1111 1111 1111 1111 1111
        //MIN_VALUE 的二进制为 1000 0000 0000 0000 0000 0000 0000 0000
        for(int right = 0;right<nums.length;right++){
            sum+=nums[right];
            while(sum>=target){
                result = Math.min(result, right - left  +1);
                sum -=nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0:result;
    }
}
```

### 904.水果成篮🟥🟥🟨🟩

> 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。
>
> 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
>
> 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
> 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
> 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
> 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
>
> 示例 1
>
> ```
> 输入：fruits = [1,2,1]
> 输出：3
> 解释：可以采摘全部 3 棵树。
> ```
>
> 示例 2：
>
> ```
> 输入：fruits = [0,1,2,2]
> 输出：3
> 解释：可以采摘 [1,2,2] 这三棵树。
> 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
> ```
>
> 示例 3：
>
> ```
> 输入：fruits = [1,2,3,2,2]
> 输出：4
> 解释：可以采摘 [2,3,2,2] 这四棵树。
> 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
> ```
>
> 示例 4：
>
> ```
> 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
> 输出：5
> 解释：可以采摘 [1,2,1,1,2] 这五棵树。
> ```

```java
//采用map，不用set，因为之前记录的个数不确定
 public int totalFruit(int[] fruits) {
     int l = 0;
     int r = 0;
     int res = 0;
     Map<Integer,Integer> map = new HashMap<>();
     for(;r<fruits.length;r++){
         map.put(fruits[r],map.getOrDefault(fruits[r],0)+1);
         while(map.size()>2){
             map.put(fruits[l],map.get(fruits[l])-1);
             if(map.get(fruits[l])==0){
                 map.remove(map.get(fruits[l]));
             }
             l++;
         }
         res =Math.max(res,r-l+1);
     }
     return res;
 }
```


### 76.最小覆盖字串🔴🔴🔴

> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
>
> 注意：
>
> 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
> 如果 s 中存在这样的子串，我们保证它是唯一的答案。
>
>
> 示例 1：
>
> ```
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> ```
>
> 示例 2：
>
> ```
> 输入：s = "a", t = "a"
> 输出："a"
> ```
>
> 示例 3:
>
> ```
> 输入: s = "a", t = "aa"
> 输出: ""
> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，
> 因此没有符合条件的子字符串，返回空字符串。
> ```

```java
//两个map记录s和t中每个字母出现的数量，
class Solution {
    public String minWindow(String s, String t) {
        if(t.length()>s.length()){
            return "";
        }
        int[] map = new int[128];
        for(char c: t.toCharArray()){
            map[c]++;
        }
        int left = 0;
        int right = 0;
        int start = 0;//注意start 和 left的区别，left是遍历过程的，start才是符合条件的
        int min = Integer.MAX_VALUE;
        int count = t.length();//记录一共有多少个字母要找
        while(right<s.length()){
            char c = s.charAt(right);
            if(map[c]-->0){//t中有的
                count--;
            }
            right++;
            //找到之后
            while(count==0){
               if(min>right-left){//出现更小且符合的窗口，修改start位置
                   min = right-left;
                   start = left;
               }
                c = s.charAt(left++);//开始缩小窗口
                if(map[c]++>=0){
                    count++;
                }
            }
        }
        return min==Integer.MAX_VALUE ? "" : s.substring(start,start+min);
    }
}
```

```java
class Solution {
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            ori.put(c, ori.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        while (r < sLen) {
            ++r;
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
            }
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        Iterator iter = ori.entrySet().iterator(); 
        while (iter.hasNext()) { 
            Map.Entry entry = (Map.Entry) iter.next(); 
            Character key = (Character) entry.getKey(); 
            Integer val = (Integer) entry.getValue(); 
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        } 
        return true;
    }
}
```



### 59.螺旋矩阵Ⅱ🔴

> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
>
>  
>
> **示例 1：**
>
> ![img](../Resources/spiraln.jpg)
>
> ```
> 输入：n = 3
> 输出：[[1,2,3],[8,9,4],[7,6,5]]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：[[1]]
> ```

```java
//模拟过程
int[][] res = new int[n][n];
int loop = n/2;//循环次数
int startX = 0;//每次循环起始位置
int startY = 0;
int offset = 1;//偏移量
int count = 1;//填充数字
int mid = n/2;
while(loop>0){
    int i = startX;
    int j = startY;
    for(;j<startY +n-offset;++j){//从左到右
        res[startX][j]= count+;
    }
    for(;i<startX+n-offset;++i){
        res[i][j] = count++;
    }
    for(;j>startY;j--){
        res[i][j]= count++;
    }
    for(;i>startX;i--){
        res[i][j] = count++;
    }
    loop++;
    startX+=1;
    startY+=1;
    offset+=2;
}
if(n%2==1){
    res[mid][mid] = count;
}
return res;
```



### 54.螺旋矩阵🔴

> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```java

```



## 链表

链表定义

```java
public class ListNode{
    int val;//节点值
    ListNode next;
    //构造函数，无参，一参，二参
    public ListNode(){}
    public ListNode(int val){this.val = val;}
    public ListNode(int val){
        this.val = val;
        this.next = next;
    }
}
```

### 203.移除链表元素🟥

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 
>
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> 示例 2：
>
> 输入：head = [], val = 1
> 输出：[]
> 示例 3：
>
> 输入：head = [7,7,7,7], val = 7
> 输出：[]

改进：（注意原题有head指针）

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
		while(head !=null&&head.val ==val){//先把头结点为val的给排除
            head = head.next;
        }
        if(head == null){
            return head;
        }
        
        ListNode pre = head;
        ListNode cur = head.next;
        while(cur !=null){
            if(cur!=null&&cur.val == val){
                pre.next = cur.next;
            }
            else{
            pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }
}
```

### 707.设计链表🔁

> 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
>
> 在链表类中实现这些功能：
>
> get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
> addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
> addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
> addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
> deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。
>
>
> 示例：
>
> ```java
> MyLinkedList linkedList = new MyLinkedList();
> linkedList.addAtHead(1);
> linkedList.addAtTail(3);
> linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3(在第一个节点之前（3）添加元素)
> linkedList.get(1);            //返回2
> linkedList.deleteAtIndex(1);  //现在链表是1-> 3
> linkedList.get(1);            //返回3
> ```
>
> 
>

```java
class MyLinkedList {
		int size;
        ListNode head;
    public MyLinkedList() {
		size = 0;
        head = new ListNode(0);
    }
    
    public int get(int index) {
		if(index >= size||index <0) return -1;
        ListNode current = head;
        for(int i =0;i<=index;i++){
            current = current.next;
        }
        return current.val;   //错误：
    }
    
    public void addAtHead(int val) {
		 addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
		addAtIndex(size, val);
    }
    
    public void addAtIndex(int index, int val) {
        //先检查index
        if (index>size) return;
        if (index<0) index=0;
        size++;
        ListNode pred = head;
        for(int i =0;i<index;i++){
            pred = pred.next;
        }
        ListNode newAdd = new ListNode(val);
        newAdd.next = pred.next;
        pred.next = newAdd;

    }
    
    public void deleteAtIndex(int index) {
if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    } 
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

他人：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }
}
class MyLinkedList {
    //size存储链表元素的个数
    int size;
    //虚拟头结点
    ListNode head;

    //初始化链表
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    //获取第index个节点的数值
    public int get(int index) {
        //如果index非法，返回-1
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode currentNode = head;
        //包含一个虚拟头节点，所以查找第 index+1 个节点
        for (int i = 0; i <= index; i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }

    //在链表最前面插入一个节点
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    //在链表的最后插入一个节点
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果 index 大于链表的长度，则返回空
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        //找到要插入节点的前驱
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    }

    //删除第index个节点
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}

```

### 206.反转链表🟥

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
		if(head ==null) return head;
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = null;
        while(curr != null){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
            
        }
        return cur;//错误，，注意返回的是pre！
    }
}
```

学习递归

反向递归思想

```java
class Solution{
    ListNode reverseList(ListNode head){
        //递归，先写返回条件
        if(head == null) return null;
        if(head.next ==null) return head;
        
        ListNode last = reverstList(head.next);
        head.next.next = head;	//将该节点设为下一个节点的next，实现两个节点翻转
        head.next = null;//将当前结点设为尾
        return last;
    }
}
```

### 24.两两交换链表结点🟥

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy  = new ListNode(0);
        dummy.next = head;
        ListNode cur  = dummy;
        while(cur.next !=null && cur.next.next != null){
            ListNode tmp = cur.next;
            ListNode tmp1 = cur.next.next.next;
            cur.next = cur.next.next;
            cur.next.next = tmp;
            cur.next.next.next=tmp1;
            cur = cur.next.next;
        }
        return dummy.next;

    }
}
```

### 19.删除链表倒数第n个结点🟥🟥🟩

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点
>
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> 示例 2：
>
> 输入：head = [1], n = 1
> 输出：[]
> 示例 3：
>
> 输入：head = [1,2], n = 1
> 输出：[1]

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
		ListNode front = dummy;
        ListNode rear = dummy;
        for(int i = 0;i<n;i++){
            rear = rear.next;
        }
        while(rear.next!=null){
            front = front.next;
            rear = rear.next;
        }
        front.next = front.next.next;
        return dummy.next;
    }
}
//个人写第一次出错，原因是直接返回head，但应该使用dummy！
```

### 2.两数相加🟥🟨🟨

> 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```
>
> 示例 2：
>
> ```
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
> ```
>
> 示例 3：
>
> ```
> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
> 输出：[8,9,9,9,0,0,0,1]
> ```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        int carry = 0;
        while(l1!=null||l2!=null){
            int x = l1==null? 0 :l1.val;
            int y = l2==null? 0 :l2.val;
            
            int sum = x+y+carry;
            carry = sum/10;
            sum = sum %10;
            cur.next = new ListNode(sum);
            cur = cur.next;
            if(l1!=null){
                l1 = l1.next;
            }if(l2!=null){
                l2 = l2.next;
            }
        }
        if(carry==1){
            cur.next = new ListNode(1);
        }
        return dummy.next;
    }
}
```

### 面试题 02.07. 链表相交✅🔁

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 
>
> 题目数据 **保证** 整个链式结构中不存在环。
>
> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。

```java
 class Solution{
    public ListNode getIntersectionNode(ListNode headA, ListNode headB){
        //方法：求出链表长度，对其末尾
        //特殊情况检查
        if(headA==null||headB==null) return null;
        //一般情况
        ListNode curA = headA;
        ListNode curB = headB;
        int lengthA = 0; int lengthB = 0;
        //求长度
       while(curA !=null){
           lengthA++;
           curA = curA.next;
       }
        while(curB !=null){
           lengthB++;
           curB = curB.next;
       }
        //移动指针
        if(lengthA > lengthB){
            int temp = lengthA - lengthB;
            for(int i = 0;i<temp;i++){
                curA=curA.next;
            }
        }
        if(lengthA < lengthB){
            int temp = lengthB - lengthA;
            for(int i = 0;i<temp;i++){
                curB=curB.next;
            }
        }
       //开始遍历比较
        for(int i = 0;i<Math.min(lengthA,lengthB);i++){
            if(curA==curB){
                return curA;
            }
            else{
                curA=curA.next;
                curB=curB.next;
            }
        }
        return null;
    }
}
```

### 142.环形链表Ⅱ🚸

> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
>
> 不允许修改 链表
>





## 哈希表

### 242.有效的字母异位词🟩

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
>
> 示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
>
> 示例 2: 输入: s = "rat", t = "car" 输出: false
>
> **说明:** 你可以假设字符串只包含小写字母

```java
//26个字母的索引值可以通过 ch - 'a'获得
class Solution{
    public boolean isAnagram(String s, String t){
        int[] record = new int[26];
        for(char c : s.toCharArray()){
            record[c-'a']++;   
        }
        
        for(char c : t.toCharArray()){
            record[c-'a']--;
        }
        
        for(int i : record){
            if(i!=0) return false;
        }
        return true;
        
    }
}
```

区别c和java的数组：

- 创建时指定长度，java的数组自动填充0
- 取String的字符需要调用 toCharArray()

###  349. 两个数组的交集🟩

> 给定两个数组 nums1 和 nums2 ，返回它们的交集 。输出结果中的每个元素一定是唯一的。我们可以 不考虑输出结果的顺序 
>
> 示例 1：
>
> ```
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> ```
>
> 示例 2：
>
> ```
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
> 解释：[4,9] 也是可通过的
> ```

```java
class Solution{
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new Hashset<>();
        for(int i : nums1){
            set.add(i);
        }
        //新建一个数组        
        Set<Integer> res = new Hashset<>();
        for(int i :nums2){
            if(set.contains(i))
                res.add(i);
        }  
    }      
    }
```

解法正确，这里需学习将hashset转化为数组的过程

```java
//HashSet<Integer> res;
int[] output = new int[res.size()];
int index = 0;
for(int i : res){
    output[index++]=i;
}
return output;
```

二刷采用了效率更高的方式：

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        boolean[] container = new boolean[1001];
        List<Integer> list = new ArrayList<>();
        for(int i :nums1){
            container[i]=true;
        }
        for(int j :nums2){
            if(container[j]){
                list.add(j);
                container[j]=false;
            }
        }
        int[] res = new int[list.size()];
        for(int i= 0;i<list.size();i++){
            res[i] =  list.get(i);
        }
        return res;
    }
}
```



### 202.快乐数🟥🟨

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」 定义为：
>
> 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
> 如果这个过程 结果为 1，那么这个数就是快乐数。
> 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
>
> 示例 1：
>
> ```
> 输入：n = 19
> 输出：true
> 解释：
> 1^2 + 9^2 = 82
> 8^2 + 2^2 = 68
> ^62 + 8^2 = 100
> 1^2 + 0^2 + 0^2 = 1
> ```
>
> 示例 2：
>
> ```
> 输入：n = 2
> 输出：false
> ```
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> 

思路：储存每一次的值，当发现已存在的就返回false。发现1就返回true

```java
class Solution {
        private int getSum(int n) {
            int sum = 0;
            while (n!=0) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            return sum;
        }

        public boolean isHappy(int n) {
            Set<Integer> set = new HashSet<>();
            while (n!=1&&!set.contains(n)) {
                set.add(n);
                n = getSum(n);
            }
            return n==1;
        }
    }
```

做的时候没有想到怎么求不定长数字的和。

### 1.两数之和🔰

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
> 示例 2：
>
> 输入：nums = [3,2,4], target = 6
> 输出：[1,2]
> 示例 3：
>
> 输入：nums = [3,3], target = 6
> 输出：[0,1]

要求使用set做

注意有索引值则需要用map而不是set

```java
class Solution {
        public int[] twoSum(int[] nums, int target) {
            HashMap<Integer,Integer> map = new HashMap<>();
            //添加的过程
            for(int i =0;i<nums.length;i++){
                map.put(nums[i],i);
            }
            int res  = -1;
            for(int i = 0;i<nums.length;i++){
                int t = target - nums[i];
                if(map.containsKey(t)&&map.get(t)!=i){
                    return new int[]{i,map.get(t)};
                }
            }
            throw new IllegalArgumentException();
        }
    }
```

做的时候还是有一些没想到，需要复习

### 454.四数相加Ⅱ🟥

> 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
>
> - 0 <= i, j, k, l < n
> - nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
>
>
> 示例 1：
>
> ```
> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 输出：2
> 解释：
> 两个元组如下：
> 
> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
> ```
>
> 示例 2：
>
> ```
> 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
> 输出：1
> ```

```java
//解法：用两个双重for循环，第一个双重for循环将nums1，nums2元素相加所有会出现的值，出现几次记录在map中
//   第二个双重for循环检查0-(nums3+nums4)的值是否出现在map中，返回这个值。
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        int temp = 0;
        for(int i : nums1){
            for(int j : nums2){
                temp = i+j;
                //注意采用map计数的方法：如果存在，这value+1，否则创建新的value=1
                if(map.containsKey(temp)){
                    map.put(temp,map.get(temp)+1);
                }else{
                    map.put(temp,1);
                }
            }
        }
        //统计剩余两数和
        for(int k :nums3){
            for(int l :nums4){
                temp = 0 - k - l;
                if(map.containsKey(temp)){
                    res = res +map.get(temp);
                }
            }
        }
        return res;
    }
}
```

### 383.赎金信🟩

> 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
>
> 如果可以，返回 true ；否则返回 false 。
>
> magazine 中的每个字符只能在 ransomNote 中使用一次。
>
> 示例 1：
>
> ```
> 输入：ransomNote = "a", magazine = "b"
> 输出：false
> ```
>
> 示例 2：
>
> ```
> 输入：ransomNote = "aa", magazine = "ab"
> 输出：false
> ```
>
> 示例 3：
>
> ```
> 输入：ransomNote = "aa", magazine = "aab"
> 输出：true
> ```

```java
//将两个字符串转化为字符数组并用hashmap记录magzine。遍历ransomnote每出现一个字符就减去相应value，直到出现value=-1，否则返回正确
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
		char[] ransomArray = ransomNote.toCharArray();
        char[] magazineArray = magazine.toCharArray();
        
        Map<Character,Integer> map = new HashMap<>();
        for(char c:magazineArray){
            if(map.containsKey(c)){
                map.put(c,map.get(c)+1);
            }else{
                map.put(c,1);
            }
        }
        //开始检查ransonNote
        for(char c:ransomArray){
            if(map.containsKey(c)){
                map.put(c,map.get(c)-1);
                if(map.get(c)<0) return false;
            }
            else{
                return false;
            }
        }
        return true;
    }
}
```

可用242题，记录26个字母的数组就行

### 15.三数之和🔁🔴🔁

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>
> 示例 1：
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = []
> 输出：[]
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [0]
> 输出：[]
> ```
>

```java
//直接看解答：
//  hash方法不太好，需要去重，，采用双指针：
class Solution{
    public List<List<Integer>> threeSum(int[] nums){
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);//先排序数组
        
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>0) return result; //当前值为正，后面全为正数了，返回结果
            if(i>0&&nums[i]==nums[i-1]) continue;//跳过相等的数，去重
            
            int left = i+1;//第二个数
            int right = nums.length-1;//第三个数
            while(right>left){
                int sum = nums[i]+nums[left]+nums[right];
                if(sum>0){
                    right--;
                }else if (sum<0){
                    letf++;
                }else{//当sum ==0 时
                    result.add(Arrays.asList(nums[i],nums[right],nums[left]));//注意List的生成
                    //去重逻辑，即相等的数就跳过（第二，第三个数都要）
                    while(right>left && nums[right]==nums[right-1]) right--;
                    while(right>left && nums[left]==nums[left+1]) left++;
                    //指针收缩
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
}
```

### 18.四数之和

> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> 0 <= a, b, c, d < n
> a、b、c 和 d 互不相同
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 你可以按 任意顺序 返回答案 。
>
> 示例 1：
>
> ```
> 输入：nums = [1,0,-1,0,-2,2], target = 0
> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [2,2,2,2,2], target = 8
> 输出：[[2,2,2,2]]
> ```



## 字符串

### [22. 括号生成🔴](https://leetcode.cn/problems/generate-parentheses/)

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> **示例 1：**
>
> ```
> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：["()"]
> ```

```java
//递归
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        dfs(n,n,"");
        return res;
    }

    public void dfs(int left,int right,String curStr){
        if(left==0&&right==0){
            res.add(curStr);
            return;
        }
        if(left>0){
            dfs(left-1,right,curStr+"(");
        }
        if(right>left){
            dfs(left,right-1,curStr+")");
        }
    }
}
```









### 344.反转字符串🟩

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>
> 示例 1：
>
> ```
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]
> ```
>
> 示例 2：
>
> ```
> 输入：s = ["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]
> ```

```java
class Solution {
    public void reverseString(char[] s) {
		//反转数组
        int temp =s[0];
        for(int i=0;i<s.length/2;i++){
            temp = s[i];
            s[i] = s[s.length-1-i];
            s[s.length-1-i] = s[i];
        }
    }
}
```

### 剑指offer.05.替换空格🟩🟩

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> ```
> 输入：s = "We are happy."
> 输出："We%20are%20happy."
> ```

```java
//题解1：直接库函数
s.replace(" ","%20");
```

```java
//StringBuilder
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i =0;i<s.length;i++){
            char c = s.charAt(i);
            if(c==' ') sb.append("%20");
            else sb.append(c);
        }
        return sb.toString();
    }
}
```

### 151.反转字符串的单词✅🔁🔁

> 给你一个字符串 s ，颠倒字符串中 单词 的顺序。
>
> 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
>
> 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
>
> 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
>
> 示例 1：
>
> ```
> 输入：s = "the sky is blue"
> 输出："blue is sky the"
> ```
>
> 示例 2：
>
> ```
> 输入：s = "  hello world  "
> 输出："world hello"
> 解释：颠倒后的字符串中不能存在前导空格和尾随空格。
> ```
>
> 示例 3：
>
> ```
> 输入：s = "a good   example"
> 输出："example good a"
> 解释：如果两个单词间有多余的空格，颠倒后的字符串需要将单词间的空格减少到仅有一个
> ```

```java
//方法：split库函数，定义新的字符串，把单词倒叙相加
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
            String[] s_arr = s.split(" ");
            for(int i =s_arr.length-1;i>=0;i--){
                if(s_arr[i].equals("")) continue;
                sb.append(s_arr[i]);
                sb.append(" ");
            }
            return sb.substring(0,sb.length()-1);
    }
}
//自己调试很久通过了！！！！
//但是不知道 s.split(" ") 分割空格和s_arr[i].equals("")检查空格不一样！！
```

```java
//更好的方法，不用辅助空间：解答
//先反转整个字符串，再将单词次序反转
class Solution {
    /**
     * 思路：
     *	①反转字符串  "the sky is blue " => " eulb si yks eht"
     *	②遍历 " eulb si yks eht"，每次先对某个单词进行反转再移位
     *	   这里以第一个单词进行为演示：" eulb si yks eht" ==反转=> " blue si yks eht" ==移位=> "blue si yks eht"
     */
    public String reverseWords(String s) {
        //步骤1：字符串整体反转（此时其中的单词也都反转了）
        char[] initialArr = s.toCharArray();
        reverse(initialArr, 0, s.length() - 1);
        int k = 0;
        for (int i = 0; i < initialArr.length; i++) {
            if (initialArr[i] == ' ') {
                continue;
            }
            int tempCur = i;
            while (i < initialArr.length && initialArr[i] != ' ') {
                i++;
            }
            for (int j = tempCur; j < i; j++) {
                if (j == tempCur) { //步骤二：二次反转
                    reverse(initialArr, tempCur, i - 1);//对指定范围字符串进行反转，不反转从后往前遍历一个个填充有问题
                }
                //步骤三：移动操作
                initialArr[k++] = initialArr[j];
                if (j == i - 1) { //遍历结束
                    //避免越界情况，例如=> "asdasd df f"，不加判断最后就会数组越界
                    if (k < initialArr.length) {
                        initialArr[k++] = ' ';
                    }
                }
            }
        }
        if (k == 0) {
            return "";
        } else {
            //参数三：以防出现如"asdasd df f"=>"f df asdasd"正好凑满不需要省略空格情况
            return new String(initialArr, 0, (k == initialArr.length) && (initialArr[k - 1] != ' ') ? k : k - 1);
        }
    }
    public void reverse(char[] chars, int begin, int end) {
        for (int i = begin, j = end; i < j; i++, j--) {
            chars[i] ^= chars[j];
            chars[j] ^= chars[i];
            chars[i] ^= chars[j];
        }
    }
}
```

### 剑指offer.58.左旋转字符串✅🔁🔁

> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
>
> 示例 1：
>
> ```
> 输入: s = "abcdefg", k = 2
> 输出: "cdefgab"
> ```
>
> 示例 2：
>
> ```
> 输入: s = "lrloseumgh", k = 6
> 输出: "umghlrlose"
> ```

```java
//个人想法：保留前n。后面移位，再插入前n
class Solution {
    public String reverseLeftWords(String s, int n) {
        char[] c_arr = s.toCharArray();
            char[] temp = new char[n];
            for(int i = 0;i<n;i++){
                temp[i] = c_arr[i];
            }
            //后面移位
            for(int i = n;i<c_arr.length;i++){
                c_arr[i-n] = c_arr[i];
            }
            //再插入
            for(int i =c_arr.length-n;i<c_arr.length;i++){
                c_arr[i] = temp[i- c_arr.length+n];
            }
            return new String(c_arr);//注意数组转字符串的方法
    }
}
//内存效率不高
```

```java
//反转区间为前n的子串
//反转区间为n到末尾的子串
//反转整个字符串
class Solution {
    public String reverseLeftWords(String s, int n) {
        int len=s.length();
        StringBuilder sb=new StringBuilder(s);
        reverseString(sb,0,n-1);
        reverseString(sb,n,len-1);
        return sb.reverse().toString();
    }
     public void reverseString(StringBuilder sb, int start, int end) {
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
            }
        }
}
//时间效率不高
```

### 28.实现strStr()✅🔁🔴

> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
>
> 说明：
>
> 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
> 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
>
> 出处。
>
> 示例 1：
>
> ```
> 输入：haystack = "hello", needle = "ll"
> 输出：2
> ```
>
> 示例 2：
>
> ```
> 输入：haystack = "aaaaa", needle = "bba"
> 输出：-1
> ```
>
> 示例 3：
>
> ```
> 输入：haystack = "", needle = ""
> 输出：0
> ```

```java
//KMP算法已忘
class Solution {
    public void getNext(int[] next, String s){
        //求解next
        //1 初始化j和next[j]
        //2 大循环
        //    如果 前后缀相等，j前进
        //    如果不相等，且j>=0,j回退到next[j]的位置
        // 	  然后将j给next i
        int j = -1;
        int next[0] = j;
        for(int i = 1; i<s.length;i++){
            while(j>=0 && s.charAt(i)!=s.charAt(j+1){ j = next[j];}
            if(s.charAt(i)==s.charAt[j+1]) j++;
            next[i]=j;
        }
        
    }
   public int strStr(String haystack, String needle) {
      //模式匹配过程
       //特殊情况
       //创建next，求next过程
       //for
       		//和getNext 一样
       		//返回
       if(haystack.length()==0) return 0;
       int[] next = new int[needle.length()];
       getNext(next, needle);
       int j = -1;
       for(int i =0 ; i<haystack.length();i++){
           while(j>=0 && haystack.charAt(i)==needle.charAt(j+1) j = next[j];
           if(haystack.charAt(i)==needle.charAt(j+1)) j++;
           if(j == needle.length()-1)  return (i-needle.length()+1);
       }
    
   }
}
```

```java
//KMP算法--next数组
void getNext(){
	int j = -1;  //j是前缀长度
    next[0] = j;
    for(int i = 1;i<s.size();i++){
        while(j>=0 && s[i]!= s[j+1])	j = next[j];	//前后缀不同，向前回退
        if(s[i]==s[j+1]) j++;  //找相同的前后缀
        next[i] = j;    //前缀长度赋给next
    }
}
```

```java
//滑动窗口法
public int strStr(String haystack, String needle){
    //特殊检查
    int m = needle.length();
    if(m==0) return 0;
    int n = haystack.length();
    if(n<m) return -1;
    //
    int i =0;
    int j =0;
    while(i<n-m+1){
        while(i<n&&haystack.charAt(i)!=needle.charAt(j))  i++;
        if(i==n) return -1;
        //遍历后续字符
        i++;
        j++;
        while(i<n && j<m &&haystack.charAt(i)==needle.charAt(j)){
            i++;j++;
        }
        if(j == m) return i - j;//已找到
        else{
            i -= j - 1;
            j =0;
        }
    }
    return -1;
}
```

### 459.重复的子字符串🔁🔁🔴

> 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
>
>  示例 1:
>
> ```
>输入: s = "abab"
> 输出: true
> 解释: 可由子串 "ab" 重复两次构成。
> ```
> 
> 示例 2:
>
> ```
>输入: s = "aba"
> 输出: false
> ```
> 
> 示例 3:
>
> ```
>输入: s = "abcabcabcabc"
> 输出: true
> 解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
> ```

```java
public boolean repeatedSubstringPattern(String s){
    if(s.equals("")) return false;
    int len = s.length();
    s = " "+s;// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了
    char[] chars = s.toCharArray();
    int[] next = new int[len +1];
    for(int i = 2, j = 0;i<=len;i++){ // 构造 next 数组过程，j从0开始(空格)，i从2开始
        while(j >0 && chars[i] != chars[j+1]) j = next[j]; // 匹配不成功，j回到前一位置 next 数组所对应的值
        if(chars[i] == chars[j+1]) j++;    // 匹配成功，j往后移
        next[i] = j;
    }
     // 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值
    if(next[len]>0 && len%(len -next[len]) == 0){
        return true;
    }
    return false;
}
```

### 567.字符串的排列🔴

> 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
>
> 换句话说，s1 的排列之一是 s2 的 子串 。
>
>  
>
> 示例 1：
>
> 输入：s1 = "ab" s2 = "eidbaooo"
> 输出：true
> 解释：s2 包含 s1 的排列之一 ("ba").
> 示例 2：
>
> 输入：s1= "ab" s2 = "eidboaoo"
> 输出：false

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int n = s1.length(), m = s2.length();
        if (n > m) {
            return false;
        }
        int[] cnt = new int[26];
        for (int i = 0; i < n; ++i) {
            --cnt[s1.charAt(i) - 'a'];//先把s1 的记录（负数）
        }
        int left = 0;
        for (int right = 0; right < m; ++right) {
            int x = s2.charAt(right) - 'a';
            ++cnt[x];
            while (cnt[x] > 0) {//当字符多出来了，就滑动左指针
                --cnt[s2.charAt(left) - 'a'];
                ++left;
            }
            if (right - left + 1 == n) {//当长度符合时就是说明找到了,不然前面的while循环无法通过
                return true;
            }
        }
        return false;
    }
}
```

### [541. 反转字符串 II🔴](https://leetcode.cn/problems/reverse-string-ii/)

> 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。
>
> - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。
>
> **示例 1：**
>
> ```
> 输入：s = "abcdefg", k = 2
> 输出："bacdfeg"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "abcd", k = 2
> 输出："bacd"
> ```



```java
StringBuilder res = new StringBuilder();
int index= 0;
int length = s.length();
while(index<length){
    int end = Math.min(length,index+k);
    StringBuilder temp = new StringBuilder(s.substring(index,end));
    if((index/k)%2==0) res.append(temp.reverse());
    else res.append(temp);
    index = end;
}
return res.toString();
```

```java
class Solution {
    public String reverseStr(String s, int k) {
        int n = s.length();
        char[] arr = s.toCharArray();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(arr, i, Math.min(i + k, n) - 1);
        }
        return new String(arr);
    }

    public void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}

```



### 607

### 601

### 596

### 586

### 584

### [5. 最长回文子串🔴](https://leetcode.cn/problems/longest-palindromic-substring/)

> 给你一个字符串 `s`，找到 `s` 中最长的回文子串。
>
>  **示例 1：**
>
> ```
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "cbbd"
> 输出："bb"
> ```

```java
//DP
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) return s;
 
        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

```java
//中心扩散
//如果传入重合的下标，进行中心扩散，此时得到的回文子串的长度是奇数；
//如果传入相邻的下标，进行中心扩散，此时得到的回文子串的长度是偶数。
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        
        int maxLen = 0;
        // 数组第一位记录起始位置，第二位记录长度
        int[] res = new int[2];
        for (int i = 0; i < s.length() - 1; i++) {
            int[] odd = centerSpread(s, i, i);
            int[] even = centerSpread(s, i, i + 1);
            int[] max = odd[1] > even[1] ? odd : even;//选长度长的
            if (max[1] > maxLen) {
                res = max;
                maxLen = max[1];
            }
        }
        return s.substring(res[0], res[0] + res[1]);
    }

    private int[] centerSpread(String s, int left, int right) {
        int len = s.length();
        while (left >= 0 && right < len) {
            if (s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return new int[]{left + 1, right - left - 1};
    }
}
```





## 双指针法

本小节均为已完成的题目，现要求只用双指针法求解

### 27.移除元素✅✅

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并**原地**修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

```java
class Solution {
        public int removeElement(int[] nums, int val) {
            //这里是在原数组上修改
            int slow = 0;
            for(int fast = 0;fast<nums.length;fast++){
                if(nums[fast] == val) continue;
                else if(fast == slow){
                    slow++;
                }else{
                    nums[slow]=nums[fast];
                    slow++;
                }
            }
            return slow;
        }
    }
```

### 剑指offer.05.替换空格✅

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> ```
> 输入：s = "We are happy."
> 输出："We%20are%20happy."
> ```

原解法：库函数；StringBuilder。

```java
class Solution {
    public String replaceSpace(String s) {
        //双指针法
        if(s==null||s.length()==0) return s;
        StringBuilder sb = new StringBuilder();
        //检查空格
        for(int i =0 ;i<s.length();i++){
            if(s.charAt(i)==' ')
                sb.append("  ");
        }
        if(sb.length()==0) return s;
        //正经开始
        //设立左右指针
        int left = s.length()-1;
        s += sb.toString();
        int right = s.length()-1;
        char[] cs = s.toCharArray();
        while(left>=0){
            if(cs[left]==' '){
                cs[right--]='0';
                cs[right--]='2';
                cs[right]='%';
            }else{
                cs[right]=cs[left];
            }
            left--;
            right--;
        }
        return new String(cs);
    }
}
```

### 206.反转链表✅

常规做法省略，递归法

```java
public ListNode reverseList(ListNode head) {
    return reverse(null,head);
}
//类似双指针，开始相当于把pre=null, cur=head 传入
private ListNode reverse(ListNode prev, ListNode cur) {
    if(cur==null) return pre;//此时cur到原链表尾，pre就是新链表头			//递归出口
    ListNode temp = null;
    temp = cur.next;//保存下一个结点
    cur.next = prev;//反转
    
    return reverse(cur, temp);//进行下一次递归					//循环
}
```

### 19.删除链表倒数第n个结点✅

解法：

1. 先定义dummy

2. 将rear后移n位

3. 同时移动rear和front，当rear到表尾时，front就到了倒数n个节点

   ```java
   public ListNode removeNthFromEnd(ListNode head, int n) {
       ListNode dummy = new ListNode(0);
       dummy.next = head;
       ListNode front = dummy;
       ListNode rear = dummy;
       for(int i = 0;i<n;i++){
           rear =rear.next;
       }
       while(rear.next!=null){
           front = front.next;
           rear = rear.next;
       }
       front.next = front.next.next;
       return dummy.next;
   }
   ```

### 15.三数之和✅🔁

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中**不可以包含重复**的三元组。
>
> 示例 1：
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = []
> 输出：[]
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [0]
> 输出：[]
> ```

题解：将数组排序

```java
/**
*先将数组排序
*返回条件：当前值大于0
*去重：消除连续又相等的值
*定义左，右指针
*
*/
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
       Arrays.sort(nums);
       List<List<Integer>> result = new ArrayList<>();
        
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>0) return result;
            if(i>0 && nums[i]==nums[i-1]) continue;
            
            int left = i+1;
            int right = nums.length-1;
            while(right>left){
                int sum = nums[i]+nums[left]+nums[right];
                if(sum>0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    //添加元素
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    //然后去重
                    while(right>left && nums[left]==nums[left+1]) left++;
                    while(right>left && nums[right]==nums[right-1]) right--;
                    left++;
                    right--;
                }
            }
        }

    }
}
```



## 栈与队列

### 155·剑指 Offer 30. 包含min函数的栈🔁

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

```java
 private Node head;
    public MinStack() {
    }
    public void push(int x) {
        if (head == null)
            head = new Node(x, x, null);
        else
            head = new Node(x, Math.min(head.min, x), head);
    }

    public void pop() {
        head = head.next;
    }

    public int top() {
        return head.val;
    }

    public int min() {
        return head.min;
    }

    private class Node {
        int val;
        int min;
        Node next;

        public Node(int val, int min, Node next) {
            this.val = val;
            this.min = min;
            this.next = next;
        }
    }
```



### 232.用栈实现队列✅✅✅

> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：
>
> 实现 MyQueue 类：
>
> void push(int x) 将元素 x 推到队列的末尾
> int pop() 从队列的开头移除并返回元素
> int peek() 返回队列开头的元素
> boolean empty() 如果队列为空，返回 true ；否则，返回 false

```java
class MyQueue {
    
    Stack<Integer> stackIn;
    Stack<Integer> stackOit;
    public MyQueue() {
		stacjIn = new Stack<>();
        stackOut = new Stack<>();
    }
    
    public void push(int x) {
		stackIn.push(x);
    }
    
    public int pop() {
        //定义一个方法将In全都进入out栈
		dumpstackIn();
        return stackOut.pop();
    }
    
    public int peek() {
		dumpstackIn();
        return stackOut.peek();
    }
    
    public boolean empty() {
		return stackIn.isEmpth()&&stackOut.isEmpty();
    }
    //定义新方法
    private void dumpstackIn(){
        if(!stackOut.isEmpty()) return;//注意out要空的才能压入栈，否则输出pop,peek有问题
        while(!stackIn.isEmpty()){
            stackOut.push(stackIn.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```



### 225.用队列实现栈🔁✅

> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
>
> 实现 MyStack 类：
>
> void push(int x) 将元素 x 压入栈顶。
> int pop() 移除并返回栈顶元素。
> int top() 返回栈顶元素。
> boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

 常用的LinkedList集合，实现了Queue接口

> 1、`boolean offer(E e)`和`boolean add(E e)`的区别
> add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！
>
> 2、`E peek()`和`E element()`的区别
> peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。
>
> 3、`E poll()`和`E remove()`的区别
> poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。

本题保证了栈不会为空，因此没有什么区别

```java
class MyStack {
	Queue<Integer> queue1;
    Queue<Integer> queue2;
    public MyStack() {
		queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int x) {
		queue2.offer(x);// 先放在辅助队列中
        while(!queue1.isEmpty()){//queue1 非空时
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp ;
        temp = queue1;
        queue1 = queue2;
        queue2 = temp;// 最后交换queue1和queue2，将元素都放到queue1中
    }
    
    public int pop() {
		return queue1.poll();
    }
    
    public int top() {
		return queue1.peek();
    }
    
    public boolean empty() {
		return queue1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```



### 20.有效的括号🟩

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
>
>
> 示例 1：
>
> ```
> 输入：s = "()"
> 输出：true
> ```
>
> 示例 2：
>
> ```
> 输入：s = "()[]{}"
> 输出：true
> ```
>
> 示例 3：
>
> ```
> 输入：s = "(]"
> 输出：false
> ```
>
> 示例 4：
>
> ```
> 输入：s = "([)]"
> 输出：false
> ```
>
> 示例 5：
>
> ```
> 输入：s = "{[]}"
> 输出：true
> ```

```java
//左括号入栈，右括号出栈
class Solution {
    public boolean isValid(String s){
            char[] arr = s.toCharArray();
            Stack<Character> stack = new Stack<>();
            for(char c : arr){
                if(c=='('||c=='{'||c=='[') stack.push(c);
                else{
                    if(stack.isEmpty()) return false;
                    char temp = stack.pop();
                    if(temp=='('&&c==')') ;
                    else if(temp=='{'&&c=='}') ;
                    else if(temp=='['&&c==']') ;
                    else return false;
                }
            }
            if(!stack.isEmpty()) return false;
            return true;
        }
}
```

### 1047.删除字符串中的所有相邻重复项✅🔁

> 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
>
> 在 S 上反复执行重复项删除操作，直到无法继续删除。
>
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
>
>  
>
> 示例：
>
> ```
> 输入："abbaca"
> 输出："ca"
> ```
>
> 解释：
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

```java
//思路：入栈，每次和栈顶元素比较
class Solution{
        public String removeDuplicates(String s){
            if(s.length()==0) return s;
            Stack<Character> stack = new Stack<>();
            char[] char_arr = s.toCharArray();
            int length = 0;
            //检查当前元素和栈顶元素，如果不等，则压入栈，相等则取出。
            for(char c :char_arr){
                if(!stack.isEmpty()&&stack.peek()==c){
                    stack.pop();
                    length--;
                }else{
                    stack.push(c);
                    length++;
                }
            }
            //将整个栈打印出来，注意要逆序
           char[] output = new char[length];
            for(int i = 0;i<length;i++){
                output[i] = stack.pop();
            }
            char temp = output[0];
            for(int i = 0;i<output.length/2;i++){
                temp = output[i];
                output[i] = output[output.length-1-i];
                output[output.length-1-i] = temp;
            }
            return new String(output);
        }
    }
//错误
```

```java
//解答：
class Solution {
    public String removeDuplicates(String s) {
        // 将 res 当做栈
        StringBuffer res = new StringBuffer();
        // top为 res 的长度
        int top = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            // 当 top > 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--
            if (top >= 0 && res.charAt(top) == c) {
                res.deleteCharAt(top);
                top--;
            // 否则，将该字符 入栈，同时top++
            } else {
                res.append(c);
                top++;
            }
        }
        return res.toString();
    }
}
```



### 150.逆波兰表达式求值✅🔁

也称（后缀表达式）

> 根据 逆波兰表示法，求表达式的值。
>
> 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
>
> 注意 两个整数之间的除法只保留整数部分。
>
> 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
>
> 示例 1：
>
> ```
> 输入：tokens = ["2","1","+","3","*"]
> 输出：9
> 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
> ```
>
> 示例 2：
>
> ```
> 输入：tokens = ["4","13","5","/","+"]
> 输出：6
> 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
> ```
>
> 示例 3：
>
> ```
> 输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
> 输出：22
> 解释：该算式转化为常见的中缀算术表达式为：
>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
> = ((10 * (6 / (12 * -11))) + 17) + 5
> = ((10 * (6 / -132)) + 17) + 5
> = ((10 * 0) + 17) + 5
> = (0 + 17) + 5
> = 17 + 5
> = 22
> ```

**注意：java不同于c++。不要进行String 转 int，而是String做计算会自动转成int**

注意泛型是int ！！！ 不是String

不使用  == 而用 equals

不要使用Stack类，而使用Deque类构造对象，**Stack类已经过时**

普通队列(一端进另一端出):
`Queue<> queue = new LinkedList<>()或Deque<> deque = new LinkedList<>()`
双端队列(两端都可进出)
`Deque<> deque = new LinkedList<>()`
堆栈
`Deque<> deque = new LinkedList<>()`

| **饰符和返回值** | **方法名**                        | **描述**                                     |
| ---------------- | --------------------------------- | -------------------------------------------- |
| **添加功能**     |                                   |                                              |
| void             | **push**(E)                       | 向队列头部插入一个元素,失败时抛出异常        |
| void             | **addFirst**(E)                   | 向队列头部插入一个元素,失败时抛出异常        |
| void             | **addLast**(E)                    | 向队列尾部插入一个元素,失败时抛出异常        |
| boolean          | **offerFirst**(E)                 | 向队列头部加入一个元素,失败时返回false       |
| boolean          | **offerLast**(E)                  | 向队列尾部加入一个元素,失败时返回false       |
| **获取功能**     |                                   |                                              |
| E                | **getFirst**()                    | 获取队列头部元素,队列为空时抛出异常          |
| E                | **getLast**()                     | 获取队列尾部元素,队列为空时抛出异常          |
| E                | **peekFirst**()                   | 获取队列头部元素,队列为空时返回null          |
| E                | **peekLast**()                    | 获取队列尾部元素,队列为空时返回null          |
| **删除功能**     |                                   |                                              |
| boolean          | **removeFirstOccurrence**(Object) | 删除第一次出现的指定元素,不存在时返回false   |
| boolean          | **removeLastOccurrence**(Object)  | 删除最后一次出现的指定元素,不存在时返回false |
| **弹出功能**     |                                   |                                              |
| E                | **pop**()                         | 弹出队列头部元素,队列为空时抛出异常          |
| E                | **removeFirst**()                 | 弹出队列头部元素,队列为空时抛出异常          |
| E                | **removeLast**()                  | 弹出队列尾部元素,队列为空时抛出异常          |
| E                | **pollFirst**()                   | 弹出队列头部元素,队列为空时返回null          |
| E                | **pollLast**()                    | 弹出队列尾部元素,队列为空时返回null          |
| **迭代器**       |                                   |                                              |
| Iterator<E>      | **descendingIterator**()          | 返回队列反向迭代器                           |

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> deque = new LinkedList<>();
        int length=tokens.length;
        int sum = 0;
        for(int i = 0;i<length;++i){
            if("*".equals(tokens[i])||"/".equals(tokens[i])||"-".equals(tokens[i])||"+".equals(tokens[i])){
                int a = deque.pop();
                int b = deque.pollFirst();
                if(tokens[i]=="*") deque.push(a*b);
                if(tokens[i]=="+") deque.push(a+b);
                if(tokens[i]=="-") deque.push(b-a);
                if(tokens[i]=="b") deque.push(b/a);
            }else{
                deque.push(Integer.valueOf(tokens[i]));
            }
        }
        return deque.peek();
    }
}
```

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList();
        for (int i = 0; i < tokens.length; ++i) {
            if ("+".equals(tokens[i])) {
                stack.push(stack.pop() + stack.pop());
            } else if ("-".equals(tokens[i])) {
                stack.push(-stack.pop() + stack.pop());
            } else if ("*".equals(tokens[i])) {
                stack.push(stack.pop() * stack.pop());
            } else if ("/".equals(tokens[i])) {
                int temp1 = stack.pop();
                int temp2 = stack.pop();
                stack.push(temp2 / temp1);
            } else {
                stack.push(Integer.valueOf(tokens[i]));
            }
        }
        return stack.pop();
    }
}
```



### 239.滑动窗口最大值✅🔁🔁🟥

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
>
> 返回 滑动窗口中的最大值 。
>
> 示例 1：
>
> ```
>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> 
> ---------------               -----
> 
> [1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7
> ```
> 
> 示例 2：
>
> ```
>输入：nums = [1], k = 1
> 输出：[1]
> ```

介绍一下`ArrayDeque`，不是性能安全的，作为栈时比Stack性能好，作为队列时比Queue性能好

ArrayDeque和Java的LinkedList都实现了Deque接口。但是，它们之间存在一些差异。

- LinkedList支持空元素，而ArrayDeque不支持。
- 链表中的每个节点都包含到其他节点的链接。这就是LinkedList比ArrayDeque需要更多存储空间的原因。
- 如果要实现队列或双端队列数据结构，则ArrayDeque可能比LinkedList快。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        //利用双端队列手动实现单调队列
        /**
   		  * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可
 		* 单调队列类似 （tail -->） 3 --> 2 --> 1 --> 0 (--> head) (右边为头结点，元素存的是下标)*/
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res =new int[nums.length-k+1];
        int idx = 0;
        for(int i = 0;i<n;i++){
             // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点
            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出。节点索引在窗口内
            while(!deque.isEmpty()&&deque.peek()< i-k+1){//队顶元素已经超出Deque范围
                deque.poll();//队顶出队
            }
            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则原末尾弹出//这步是关键！！，deque并不是有k个元素
            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {//注意是while循环！
                deque.pollLast();//队尾出队
            }

            deque.offer(i);

            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了
            if(i >= k - 1){//当队列满了就可以开始检查了
                res[idx++] = nums[deque.peek()];//取队顶元素记入结果
            }
        }
        return res;
    }
}
```

### 347.前 K 个高频元素✅🔁🔁

> 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。
>
>  示例 1:
>
> ```
>输入: nums = [1,1,1,2,2,3], k = 2
> 输出: [1,2]
>```
> 
> 示例 2:
> 
> ```
>输入: nums = [1], k = 1
> 输出: [1]
>```

`Entry` 将键值对的对应关系封装成对象，这样在遍历时，可以通过Entry获取对应信息。

`Set<Map.Entry<K,V>> entrySet();`返回Set集合，里面装Entry

> 实现步骤：
>
> 1，调用Map集合中的entrySet()方法，将集合中的映射关系对象存储到Set集合中
>
> 2，迭代Set集合
>
> 3，获取Set集合的元素，是映射关系的对象
>
> 4，通过映射关系对象的方法，getKey()和getValue(),获取键值对

这里的优先队列就是一个堆，因为优先队列从队头取元素，从队尾加元素，其内部元素自动依照权值排列

> ```
> peek()//返回队首元素
> poll()//返回队首元素，队首元素出队列
> add()//添加元素
> size()//返回队列元素个数
> isEmpty()//判断队列是否为空，为空返回true,不空返回false
> ```

```java
//他人题解
class Solution{
    public int[] topKFrequent(int[] nums, int k){
        int[] result = new int[k];
        Hashmap<Integer, Integer> map = new HashMap<>();
        for(int num:nums){
            map.put(num, map.getOrDefault(num, 0)+1);//将元素和出现次数记录
        }
        
        Set<Map.Entry<Integer,Integer>> entries = map.entrySet();
        //根据map的value值正序排，相当于一个小顶堆
        PriorityQueue<Map.Entry<Integer,Integer>> queue = new PriorityQueue<>((o1,o2)->o1.getValue()-o2.getValue());
        for(Map.Entry<Integer,Integer> entry:entries){
            queue.offer(entry);
            if(queue.size()>k) queue.poll();
        }
        //小顶堆，取出前面value小的，剩下的k个就是结果
        for(int i = k-1;i>=0;i--){
            result[i] = queue.poll().getKey();
        }
        return result;
    }
}
```

### HJ77 火车进站

```
3
1 2 3
/////////////
1 2 3
1 3 2
2 1 3
2 3 1
3 2 1
```



```java
import java.util.*;

// 思路：主要思想是递归，之所以产生很多方案的原因就是，每次进来一辆火车后，我们将其压入栈中，然后我们可以有两种选择，一是不弹出，二是弹出；
// 对于第二种弹出元素，弹出的个数的范围取决于当前栈中元素的个数，所以遍历每种情况，在遍历每种情况的时候再递归到下一辆火车
public class Main {
    static Deque<Integer> stack;
    static int[] nums, outNums;
    static int n;
    static List<String> res;
    public static void main(String[] args) {
        // 完成输入
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        nums = new int[n];
        for (int i=0; i<n; i++) nums[i] = in.nextInt();
        // outNums是用来记录当前递归中，已经出站的火车编号； stack是记录当前车站中还有哪些火车； 
        // res是记录所有结果并进行排序，因为题目要求所有方案以字典序排序输出，所以没办法必须加
        outNums = new int[n];
        stack = new LinkedList<>();
        res = new ArrayList<>();
        // 开始遍历
        dfs(0, 0);
        // 对所有方案排序，并输出
        Collections.sort(res);
        for (String str:res) System.out.println(str);
    }
    
    // i代表已经递归到了第i辆火车，cnt代表已经已经出站的火车数量，即是outNums的下标
    public static void dfs(int i, int cnt) {
        // 这个tmp栈很重要，这是保证dfs返回时，stack中的元素和进来时一样
        Deque<Integer> tmp = new LinkedList<>();
        // 压入当前火车
        stack.push(nums[i]);
        
        // 当递归到最后一辆火车时，我们只需要将其压入栈中，这时所能做的只有弹出栈中所有元素，并将其添加到outNums数组中
        if (i==n-1) {
            
            // 弹出栈中所有元素
            while (stack.size() > 0) {
                tmp.push(stack.peek());
                outNums[cnt++] = stack.pop();
            }
            // 这里>1是因为stack中本身不含有nums[i]
            while (tmp.size() > 1) stack.push(tmp.pop());
            // 将当前方案以字符串形式保存到res中
            StringBuilder sb = new StringBuilder();
            for (int outNum:outNums) sb.append(outNum).append(" ");
            res.add(sb.toString());
        }
        // 如果没有递归到最后一辆火车，那么在将当前火车编号压入栈后，有很多选择，这也就产生了很多方案
        // 一种就是继续压；还有一种就是开始弹出元素，弹出元素个数范围是[0, size]（包含两边界），那么就需要依次遍历
        else {
            int size = stack.size();
            // 继续压
            dfs(i+1, cnt);
            // 开始弹出元素
            for (int j=0; j<size; j++) {
                tmp.push(stack.peek());
                outNums[cnt++] = stack.pop();
                dfs(i+1, cnt);
            }
            // 这里>1是因为stack中本身不含有nums[i]，
            while (tmp.size() > 1) stack.push(tmp.pop());
        }
    }
}

```

