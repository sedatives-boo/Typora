# 每日

### 5.27面试题17.11单词距离💫

> 有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?
>
> 示例：
>
> ```
> 输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student"
> 输出：1
> ```
>
> 提示：`words.length <= 100000`

```java
//他人解法：前缀树
class Solution {
    Trie root;

    public int findClosest(String[] words, String word1, String word2) {
        root = new Trie();
        for (int i = 0; i < words.length; i++) {
            addString(words[i], i);
        }
        List<Integer> list1 = searchIndex(word1);
        List<Integer> list2 = searchIndex(word2);
        if (list1 == null || list2 == null) return -1;
        int minDistance = Integer.MAX_VALUE;
        int p = 0;
        for (Integer index : list2) {
            while (p + 1 < list1.size() && Math.abs(index - list1.get(p)) > Math.abs(index - list1.get(p + 1)))
                p++;
            minDistance = Math.min(minDistance, Math.abs(index - list1.get(p)));
        }
        return minDistance;
    }

    private List<Integer> searchIndex(String str) {
        Trie cur = root;
        for (int i = 0; i < str.length(); i++) {
            int ch = str.charAt(i);
            if (cur.children[ch] == null) return null;
            cur = cur.children[ch];
        }
        return cur.indexList;
    }

    private void addString(String str, int index) {
        Trie cur = root;
        for (int i = 0; i < str.length(); i++) {
            int ch = str.charAt(i);
            if (cur.children[ch] == null)
                cur.children[ch] = new Trie();
            cur = cur.children[ch];
        }
        cur.indexList.add(index);
    }

    class Trie {
        Trie[] children;
        List<Integer> indexList;

        public Trie() {
            this.children = new Trie[128];
            this.indexList = new ArrayList<>();
        }
    }
}
```

### 5.28/1021.删除最外层括号✅

> 有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。
>
> 例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
> 如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。
>
> 给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。
>
> 对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。
>
> 示例 1：
>
> ```
> 输入：s = "(()())(())"
> 输出："()()()"
> 解释：
> 输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
> 删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
> ```
>
> 示例 2：
>
> ```
> 输入：s = "(()())(())(()(()))"
> 输出："()()()()(())"
> 解释：
> 输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
> 删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
> ```
>
> 示例 3：
>
> ```
> 输入：s = "()()"
> 输出：""
> 解释：
> 输入字符串为 "()()"，原语化分解得到 "()" + "()"，
> 删除每个部分中的最外层括号后得到 "" + "" = ""。
> ```

```java
//效率不怎么高
class Solution {
    public String removeOuterParentheses(String s) {
        //栈和队列一起完成
        Deque<Character> stack = new LinkedList<>();
        Deque<Character> deque = new LinkedList<>();
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i<s.length();i++){
            if(s.charAt(i)=='('){
                stack.addLast(s.charAt(i));
                deque.addLast(s.charAt(i));
            }else if(s.charAt(i)==')'){
                stack.pollLast();
                deque.addLast(')');
                if(stack.isEmpty()){//栈空：表示当前原语结束，收集结果
                    deque.pollLast();
                    deque.pollFirst();
                    while(!deque.isEmpty()){ 
                        sb.append(deque.pollFirst());
                    }
                }
            }
        }
        return new String(sb);
    }
}
```

### 5.29/468.验证IP地址🔁🔁🔴🔁

> 给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 "IPv4" ；如果是有效的 IPv6 地址，返回 "IPv6" ；如果不是上述类型的 IP 地址，返回 "Neither" 。
>
> 有效的IPv4地址 是 `“x1.x2.x3.x4”` 形式的IP地址。 其中 0 <= xi <= 255 且 xi 不能包含 前导零。例如: `“192.168.1.1”` 、 `“192.168.1.0”` 为有效IPv4地址， `“192.168.01.1”` 为无效IPv4地址; `“192.168.1.00”` 、 “192.168@1.1” 为无效IPv4地址。
>
> 一个有效的IPv6地址 是一个格式为`“x1:x2:x3:x4:x5:x6:x7:x8”` 的IP地址，其中:
>
> `1 <= xi.length <= 4`
> xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。
> 在 xi 中允许前导零。
> 例如 `"2001:0db8:85a3:0000:0000:8a2e:0370:7334"` 和 `"2001:db8:85a3:0:0:8A2E:0370:7334"` 是有效的 IPv6 地址，而 `"2001:0db8:85a3::8A2E:037j:7334"` 和 `"02001:0db8:85a3:0000:0000:8a2e:0370:7334"` 是无效的 IPv6 地址。
>
> 示例 1：
>
> ```
> 输入：queryIP = "172.16.254.1"
> 输出："IPv4"
> 解释：有效的 IPv4 地址，返回 "IPv4"
> ```
>
> 示例 2：
>
> ```
> 输入：queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
> 输出："IPv6"
> 解释：有效的 IPv6 地址，返回 "IPv6"
> ```
>
> 示例 3：
>
> ```
> 输入：queryIP = "256.256.256.256"
> 输出："Neither"
> 解释：既不是 IPv4 地址，又不是 IPv6 地址
> ```

```java
//正则
class Solution {
    public String validIPAddress(String IP) {
        if (IP == null) {
            return "Neither";
        }
        String regex0 = "(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
        String regexIPv4 = regex0 + "(\\." + regex0 + "){3}";//双引号是是字符串的，与表达式无关
        String regex1 = "([\\da-fA-F]{1,4})";
        String regexIPv6 = regex1 + "(:" + regex1 + "){7}";
        
        String result = "Neither";
        if (IP.matches(regexIPv4)) {
            result = "IPv4";
        } else if (IP.matches(regexIPv6)) {
            result = "IPv6";
        }
        return result;
    }
}
```

```
\\d   		数字 0-9
[1-9]\\d  		10-99
1\\d\\d			100-199
2[0-4]\\d   	200-249	
d|25[0-5] 		250-255
[]    		内的任意字符
\\da-fA-F    \\d 数字    a-f   A-F  的集合
{1,4}        至少出现1-4次
```



### 5.30/1022.从根到叶的二进制数之和🔴🔴

> **给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。
>
> 例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。
> 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。
>
> 返回这些数字之和。题目数据保证答案是一个 32 位 整数。
>
> <img src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,0,1,0,1,0,1]
> 输出：22
> 解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [0]
> 输出：0
> ```

```java
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        if(root==null) return 0;
        return backreacking(root,0);
    }
    public int backreacking(TreeNode root,int num){
        int sum = 0;
        num = (num<<1) + root.val;
        if(root.right==null&root.left==null) return num;
        if(root.right!=null) sum+=backreacking(root.right,num);
        if(root.left!=null) sum += backreacking(root.left,num);
        return sum;
    }
}
```

### 5.31剑指 Offer II 114. 外星文字典💫

> 现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。
>
> 给定一个字符串列表 `words` ，作为这门语言的词典，`words` 中的字符串已经 按这门新语言的字母顺序进行了排序 。
>
> 请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 "" 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。
>
> 字符串 s 字典顺序小于 字符串 t 有两种情况：
>
> 在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。
> 如果前面 min(s.length, t.length) 字母都相同，那么 s.length < t.length 时，s 的字典顺序也小于 t 。
>
>
> 示例 1：
>
> ```
> 输入：words = ["wrt","wrf","er","ett","rftt"]
> 输出："wertf"
> ```
>
> 示例 2：
>
> ```
> 输入：words = ["z","x"]
> 输出："zx"
> ```
>
> 示例 3：
>
> ```
> 输入：words = ["z","x","z"]
> 输出：""
> 解释：不存在合法字母顺序，因此返回 "" 。
> ```

```java
嗯，这个题在收藏夹里面躺了快一年都没有解决，今天是时候拿出来做一下了🙃🙃🙃，，感觉是一道非常经典的拓扑排序的题，代码会比较长但是很容易理解
思路：
    1、先标记所有出现过的字母，没出现过的字母不要在答案中出现；
    2、正向建图（存储某个字母的儿子）：用list存储，反向建图，用set存储；
    3、把所有出现过的点（字母）并且没有父节点的（入度为0）点先拿出来组成字母表前缀，这些是字母表中最可能的最靠前的字母们；
    4、BFS取出每一个字母，同时把它从相应儿子的set中删除，假如此时set已经空，这说明这个点的祖先你们全都遍历过了，而且也加到字母表里面了，那么这个字母也能够假如字母表；
    5、此时遍历所有set，假如还有不空的，说明拓扑排序存在环，则不存再答案；
    6、对于有些出现了的，但是还没有跟其他字母存在先后关系的字母，也要拼在字母表后边，既然出现了，也不可以落下呀，
    注意陷阱:1、建图不要重复加入边，出错案例：["ac","ab","zc","zb"] 2、后者不能是前者的真前缀，出错案例：["abc","ab"]
/*
@可爱抱抱呀
执行用时：2 ms, 在所有 Java 提交中击败了99.12%的用户
内存消耗：39.5 MB, 在所有 Java 提交中击败了79.59%的用户
2022年5月30日 15:52
*/
class Solution {
    public String alienOrder(String[] words) {
        boolean has[]=new boolean[26];//记录字母是否出现过
        char c[][]=new char[words.length][];
        for(int i=0;i<c.length;i++){
            c[i]=words[i].toCharArray();
            for(int j=0;j<c[i].length;j++){has[c[i][j]-'a']=true;}
        }
        List<Integer> son[]=new List[26];
        Set<Integer> father[]=new Set[26];
        for(int i=0;i<26;i++){
            son[i]=new ArrayList<>();
            father[i]=new HashSet<>();
        }
        //以下正反建图：
        for(int i=1;i<c.length;i++){
            int p=0;
            while(p<Math.min(c[i-1].length,c[i].length)&&c[i-1][p]==c[i][p]){p++;}
            if(p==c[i].length&&p<c[i-1].length){return "";}//后者为前者的真前缀，报警了啊
            if(p<c[i].length&&p<c[i-1].length){
                //此时遇到的首个不同字母，有关字母表顺序，主注意去重
                if(father[c[i][p]-'a'].add(c[i-1][p]-'a')){son[c[i-1][p]-'a'].add(c[i][p]-'a');}
            }
        }
        Queue<Integer> q=new LinkedList<>();
        StringBuilder ans=new StringBuilder();
        //先把没有父节点的字母收集起来，这些是字母中的前排
        for(int i=0;i<26;i++){
            if(has[i]&&father[i].size()==0){
                ans.append((char)(i+'a'));
                has[i]=false;
                q.add(i);
            }
        }
        //下边开始BFS：
        while(q.size()>0){
            int a=q.poll();
            for(int i=0;i<son[a].size();i++){
                int b=son[a].get(i);
                father[b].remove(a);
                if(father[b].size()==0){
                    ans.append((char)(b+'a'));
                    has[b]=false;
                    q.add(b);
                }
            }
        }
        //下边开始检查有无set不是空的，有的话说明存在环，顺便把无顺序关系的字母加进来
        for(int i=0;i<26;i++){
            if(father[i].size()>0){return "";}
            if(has[i]){ans.append((char)(i+'a'));}
        }
        return ans.toString();
    }
}
```

### 6.1/473. 火柴拼正方形💫

> 你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。
>
> 如果你能使这个正方形，则返回 true ，否则返回 false 。
>
> 输入: matchsticks = [1,1,2,2,2]
> 输出: true
> 解释: 能拼成一个边长为2的正方形，每边两根火柴。
> 示例 2:
>
> 输入: matchsticks = [3,3,3,3,4]
> 输出: false
> 解释: 不能用所有火柴拼成一个正方形。

```java
//回溯
/*
	1、计算总长度，不是4的倍数则返回，，，单边长度len也可得出
	2、降序排序数组
	3、创建数组，存放4条边
	4、回溯：
		1、结束条件：所有火柴取完
		2、以四条边为遍历
		edges[i]+=matchsticks[index];
		if(edges]i<len && dfs(index+1)) retrun true;//遍历到底时才会满足条件
		edges[i]-=edges[i]+=matchsticks[index];
*/
class Solution{
    public boolean makeSquare(int[] matchsticks){
        int totalLen = Arrays.stream(matchsticks).sum();//使用流处理
        if(totalLen%4!=0){
            return false;
        }
        Arrays.sort(matchsticks,Collections.reverseOrder());
       int[] edges = new int[4];
        return dfs(0,matchsticks,edges,totalLen/4);
    }
    
    public boolean dfs(int index,int[] matchstaicks,int[] edges,int len ){
        if(index==matchstick.length){
            return true;
        }
        for(int i = 0;i<edges.length;i++){
            edges[i] += matchsticks[index];
            if(edges[i]<=len && dfs(index+1,matchsticks.edges.int len)){
                return true;
            }
            edges[i] -=matchsticks[index];
        }
        return false;
    }
}
```

```java
//状态压缩+DP
class Solution {
    public boolean makesquare(int[] matchsticks) {
        int totalLen = Arrays.stream(matchsticks).sum();
        if (totalLen % 4 != 0) {
            return false;
        }
        int len = totalLen / 4, n = matchsticks.length;
        int[] dp = new int[1 << n];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int s = 1; s < (1 << n); s++) {
            for (int k = 0; k < n; k++) {
                if ((s & (1 << k)) == 0) {
                    continue;
                }
                int s1 = s & ~(1 << k);
                if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {
                    dp[s] = (dp[s1] + matchsticks[k]) % len;
                    break;
                }
            }
        }
        return dp[(1 << n) - 1] == 0;
    }
}
```

##### Arrays.stream



##### Arrays.sort  和 Collections.sort

Arrays.sort针对对象，，可以是String，int，类数组

Collections.sort针对集合（List），实际上是调用Arrays.sort

```java
// 逆序排序 ，传入 Collections.reverseOrder()
Integer[] a ={2,51,3,4,7,1,4,10,234};
Arrays.sort(a, Collections.reverseOrder());
//选择排序区间
int[] a={5,3,1,6,8,9,3};
Arrays.sort(a,0,3);//  [0,3)
```

```java
int a=1,b=7,c=4,d=5;
List<Integer> list=new ArrayList<Integer>();
list.add(a);list.add(b);list.add(c);list.add(d);
Comparator cmp=new MyComparator();
Collections.sort(list,cmp);		//需要传入list， 和Comparator接口实现类
public static class MyComparator implements Comparator<Integer>
{
	public int compare(Integer arg0, Integer arg1) {
		if(arg0<arg1)
			return 1;
		else if(arg0>arg1)
			return -1;
		else
			return 0;
	}
}

```

##### 将数组转为ArrayList

1. String[] 类型的数组转为List

  ```java
  String[] array= {"aa", "bb", "cc"};
  ArrayList<String> arrayList = new ArrayList(Arrays.asList(array));
  ```



  2.int [] 类型的数组转为List
  错误做法:
  普通整型数组 arr ：int[] arr = {1,2,3};
  错误做法：Arrays.asList(arr)

正确做法

```java
int[] array = {1, 2, 3};
List<Integer> list1 = Arrays.stream(array).boxed().collect(Collectors.toList());
// Arrays.stream(arr) 可以替换成IntStream.of(arr)。
// 1.使用Arrays.stream将int[]转换成IntStream。
// 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream<Integer>。
// 3.使用Stream的collect()，将Stream<T>转换成List<T>，因此正是List<Integer>。
```



### 6.4/929.独特的电子邮件地址🔁✅

> 每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 '@' 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 '.' 或 '+' 。
>
> 例如，在 alice@leetcode.com中， alice 是 本地名 ，而 leetcode.com 是 域名 。
> 如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。
>
> 例如，"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。
> 如果在 本地名 中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。
>
> 例如 m.y+name@email.com 将转发到 my@email.com。
> 可以同时使用这两个规则。
>
> 给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。
>
>  
>
> 示例 1：
>
> ```
> 输入：emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
> 输出：2
> 解释：实际收到邮件的是 "testemail@leetcode.com" 和 "testemail@lee.tcode.com"。
> ```
>
> 示例 2：
>
> ```
> 输入：emails = ["a@leetcode.com","b@leetcode.com","c@leetcode.com"]
> 输出：3
> ```

```java
class Solution {
    public int numUniqueEmails(String[] emails) {
        Set<String> set = new HashSet<>();
        for(String s:emails){
            String[] arr = s.split("@");//只需对arr[0] 做处理就行
            StringBuilder sb = new StringBuilder();
            for(int i = 0;i<arr[0].length();i++){
                if(arr[0].charAt(i)=='.'){
                    continue;
                }
                if(arr[0].charAt(i)=='+'){
                    break;
                }else{
                    sb.append(arr[0].charAt(i));
                }
            }
            String news = new String(sb);
            set.add(news+"@"+arr[1]);
        }
        return set.size();
    }
}
```

### 6.5/478. 在圆内随机生成点🔁

> 给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。
>
> 实现 Solution 类:
>
> Solution(double radius, double x_center, double y_center) 用圆的半径 radius 和圆心的位置 (x_center, y_center) 初始化对象
> randPoint() 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 [x, y] 。
>
>
> 示例 1：
>
> ```
> 输入: 
> ["Solution","randPoint","randPoint","randPoint"]
> [[1.0, 0.0, 0.0], [], [], []]
> 输出: [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]
> 解释:
> Solution solution = new Solution(1.0, 0.0, 0.0);
> solution.randPoint ();//返回[-0.02493，-0.38077]
> solution.randPoint ();//返回[0.82314,0.38945]
> solution.randPoint ();//返回[0.36572,0.17248]
> ```

半径随机0-1 不能均匀分布

```java
class Solution {
    private double radius;
    private double x_center;
    private double y_center;
    private double pi = Math.PI;
    public Solution(double radius, double x_center, double y_center) {
        this.radius = radius;
        this.x_center = x_center;
        this.y_center = y_center;
    }
    
    public double[] randPoint() {
        double q1 = Math.random();//弧度因子
        double q2 = Math.random();//半径因子
        
        double x = x_center+Math.sqrt(radius*radius)*q2*Math.cos(2*pi*q1);
        double y = y_center+Math.sqrt(radius*radius)*q2*Math.sin(2*pi*q1);
        return new double[]{x,y};
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(radius, x_center, y_center);
 * double[] param_1 = obj.randPoint();
 */
```

采用拒绝采用法

```java
class Solution {
    Random random = new Random();//注意random对象
    double radius;
    double x_center ;
    double y_center ;
    public Solution(double radius, double x_center, double y_center) {
        this.radius = radius;
        this.x_center = x_center ;
        this.y_center = y_center ;
    }
    
    public double[] randPoint() {
        while(true){
            double randomX = random.nextDouble() * (radius * 2) - radius ;
            double randomY = random.nextDouble() * (radius * 2) - radius;
            if (randomX * randomX + randomY * randomY <= radius * radius)
                return new double[]{randomX + x_center , randomY + y_center};
        }
    }
}
```

### 6.7/875 爱吃香蕉的珂珂🔴

> 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。
>
> 珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
>
> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
>
> 返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
>
> 示例 1：
>
> ```
> 输入：piles = [3,6,7,11], h = 8
> 输出：4
> ```
>
> 示例 2：
>
> ```
> 输入：piles = [30,11,23,4,20], h = 5
> 输出：30
> ```
>
> 示例 3：
>
> ```
> 输入：piles = [30,11,23,4,20], h = 6
> 输出：23
> ```

```java
 public int midEatingSpeed(int[] piles, int h){
     int low = 1;
     int high =0;
     for(int pile:piles){
         high = Math.max(high,pile);//找出最大值
     }
     int res = high;
     while(low<high){
         int speed = (high-low)/2+low;//中点
         long time = getTime(piles,speed);//获取当前速度的时间
         if(time<=h){//如果时间更短了， 说明速度太快了，要缩短high
             res=speed;
             high = speed;
         }else{
             low = speed+1;
         }
     }
     return res;
 }

public long getTime(int[] plies,int speed){//计算当前速度下所需要的时间
    long time= 0;
    for(int pile :piles){
        int curTime = (pile+speed-1)/speed;
        time += cuurTime;
    }
    return time;
}
```

### 6.8/1037.有效的回旋镖🔁

> 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。
>
> 回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。
>
>  
>
> 示例 1：
>
> ```
> 输入：points = [[1,1],[2,3],[3,2]]
> 输出：true
> ```
>
> 示例 2：
>
> ```
> 输入：points = [[1,1],[2,2],[3,3]]
> 输出：false
> ```

```java
//因为求斜率会有÷0情况，因此采用十字相乘法
```

### 6.9/非重叠矩形中的随机点🔴

> 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。
>
> 在一个给定的矩形覆盖的空间内任何整数点都有可能被返回。
>
> 请注意 ，整数点是具有整数坐标的点。
>
> 实现 Solution 类:
>
> Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。
> int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。
>
> ```
> 输入: 
> ["Solution", "pick", "pick", "pick", "pick", "pick"]
> [[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
> 输出: 
> [null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]
> 
> 解释：
> Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
> solution.pick(); // 返回 [1, -2]
> solution.pick(); // 返回 [1, -1]
> solution.pick(); // 返回 [-1, -2]
> solution.pick(); // 返回 [-2, -2]
> solution.pick(); // 返回 [0, 0]
> ```

```java
class Solution {
    Random rand;
    List<Integer> arr;
    int[][] rects;//矩阵属性

    public Solution(int[][] rects) {
        rand = new Random();
        arr = new ArrayList<Integer>();
        arr.add(0);
        this.rects = rects;
        for (int[] rect : rects) {
            int a = rect[0], b = rect[1], x = rect[2], y = rect[3];
            arr.add(arr.get(arr.size() - 1) + (x - a + 1) * (y - b + 1));//表示该矩形内点的个数
        }
    }

    public int[] pick() {
        int k = rand.nextInt(arr.get(arr.size() - 1));//从总个数中随机取出一个
        int rectIndex = binarySearch(arr, k + 1) - 1;//找到这个随机数对应的矩阵
        k -= arr.get(rectIndex);//减去该矩阵的起始点，得到在这个矩阵中的序号
        int[] rect = rects[rectIndex];//取出改矩阵
        int a = rect[0], b = rect[1], y = rect[3];
        int col = y - b + 1;
        int da = k / col;
        int db = k - col * da;
        return new int[]{a + da, b + db};
    }

    private int binarySearch(List<Integer> arr, int target) {
        int low = 0, high = arr.size() - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int num = arr.get(mid);
            if (num == target) {
                return mid;
            } else if (num > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```

### 6.11/926. 将字符串翻转到单调递增🔴🔁

> 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。
>
> 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。
>
> 返回使 s 单调递增的最小翻转次数。
>
>  
>
> 示例 1：
>
> 输入：s = "00110"
> 输出：1
> 解释：翻转最后一位得到 00111.
> 示例 2：
>
> 输入：s = "010110"
> 输出：2
> 解释：翻转得到 011111，或者是 000111。
> 示例 3：
>
> 输入：s = "00011000"
> 输出：2
> 解释：翻转得到 00000000。

```java
//错误思路
    class Solution {
    public int minFlipsMonoIncr(String s) {
 		int[] pre = new int[s.length()+1];
        int[] post = new int[s.length()+1];
        int indexOf1 = s.length();
        int indexOf0 = -1;
        for(int i = 1;i<=s.length();i++){
            if(s.charAt(i-1)=='0'){
                indexOf0 = Math.max(i-1,indexOf0);
                pre[i] =pre[i-1];
            }else{
                pre[i] = pre[i-1]+1;
            }
        }
        for(int j = s.length();j>0;j--){
            if(s.charAt(j-1)=='1'){
                indexOf1 = Math.min(indexOf1,j-1);
                post[j-1]=post[j];
            }else{
                post[j-1] = post[j]+1;
            }
        }
        if(indexOf0==-1||indexOf1==s.length()){
            return 0;
        }
        int ans1 = post[indexOf1];
        int ans0 = pre[indexOf0];
        return Math.min(ans1,ans0);
    }
}
```

```java
//DP
class Solution {
    public int minFlipsMonoIncr(String s) {
        int m = s.length();
        int[][] dp = new int[m + 1][2];
        for(int i = 1; i <= m; i++){
            if(s.charAt(i - 1) == '0'){
                dp[i][0] = dp[i - 1][0];//为0   保持上一位全0状态
                dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + 1;//0变1 ，
            }else{
                dp[i][0] = dp[i - 1][0] + 1;//变为0，上一位全0态—+1
                dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]);
            }
        }
        return Math.min(dp[m][0], dp[m][1]);
    }
}
```

```java
//状态保留DP*******************************
class Solution {
    public int minFlipsMonoIncr(String s) {
        char[] cs = s.toCharArray();
        int n = s.length();
        int res = 0, curOneCnt = 0;//记录当前1 的个数
        for (int i = 0; i < n; i ++ ) {
            if (cs[i] == '1') {
                curOneCnt ++ ;
            } else {
                res = Math.min(res + 1, curOneCnt);	//当前为0，答案就是（改为1：）
                							//（改为0： 之前的1改为0）
            }
        }
        return res;
    }
}
```

### 6.14/498.对角线遍历🔁🔴

> 给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
>
> 示例 1：
>
> <img src="../Resources/diag1-grid.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,4,7,5,3,6,8,9]
> ```
>
> 示例 2：
>
> ```
> 输入：mat = [[1,2],[3,4]]
> 输出：[1,2,3,4]
> ```

```java
//碰到四条边的情况+正常的两种路线=6种路线
public int[] findDiagonalOrder(int[][] matrix){
    if(matrix == null||matrix.length==0){
        return new int[]{};
    }
    int r = 0,c = 0;
    int row = matrix.length, col = matrix[0].length;
    int res = new int[row*col];
    for(int i = 0;i<res.length;i++){
        res[i]= matrix[r][c];
        if((r+c)%2==0){//偶数为向上遍历，奇数为向下遍历
            if(c==col-1){
                r++;//往下移动一格准备向下遍历
            }else if(r==0){
                c++;//往右移动一格准备向下遍历
            }else{
                r--;c++;
            }else{
                if(r==row-1){
                    c++;//往右移动一格准备向上遍历
                }else if(c==0){
                    r++;//往下移动一格准备向上遍历
                }else{
                    r++;c--;
                }
            }
        }
        return res;
    }
}
```

### 6.16/532.数组中的k-diff数对🔴🔁

> 给定一个整数数组和一个整数 k，你需要在数组里找到 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。
>
> 这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：
>
> `0 <= i < j < nums.length`
> `|nums[i] - nums[j]| == k`
> 注意，`|val|` 表示 val 的绝对值。
>
> 示例 1：
>
> ```
> 输入：nums = [3, 1, 4, 1, 5], k = 2
> 输出：2
> 解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
> 尽管数组中有两个1，但我们只应返回不同的数对的数量。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [1, 2, 3, 4, 5], k = 1
> 输出：4
> 解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [1, 3, 1, 5, 4], k = 0
> 输出：1
> 解释：数组中只有一个 0-diff 数对，(1, 1)。
> ```

```java
//两数之和的方法
class Solution {
    public int findPairs(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        int count = 0;
        if(k<0) return 0;
        for(int i =0;i<nums.length;i++){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        for(int i :map.keySet()){
            if(k==0){
                if(map.get(i)>1){//k=0时，需要有两个以上才能一对
                    count++;
                }
            }else if(map.containsKey(i+k)){//遍历找i+k 的就不用找 i-k 的情况了
                count++;
            }
        }
        return count;
    }
}
```



### 6.19/508.出现次数最多的子树元素和🔴

> 给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。
>
> 一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。
>

```java
class Solution {
    private int max = 0;
    public int[] findFrequentTreeSum(TreeNode root) {
        if(root==null) return new int[0];
        Map<Integer,Integer> map = new HashMap<>();
        helper(root,map);//计算所有节点的答案并存入map
        //求出map中value最大值对应的key
        List<Integer> res = new LinkedList<>();
        for(int i :map.keySet()){
            if(map.get(i)==max){
                res.add(i);
            }
        }
        int[] resAns = new int[res.size()];
        for(int i = 0;i<res.size();i++){
            resAns[i] = res.get(i);
        }
        return resAns;
    }

    private int helper(TreeNode root, Map<Integer,Integer> map){
        if(root==null) return 0;//返回条件：当前为空
        //求出当前节点为根的元素和
        int left = helper(root.left,map);//逐渐向下递归
        int right = helper(root.right,map);
        int val = left+right+root.val;//本节点的值，就是左右孩子和该节点值之和
        map.put(val,map.getOrDefault(val,0)+1);
        max = Math.max(max,map.get(val));
        return val;
    }
}
```

### 6.27/[522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

> 给定字符串列表 `strs` ，返回其中 **最长的特殊序列** 。如果最长特殊序列不存在，返回 `-1` 。
>
> **特殊序列** 定义如下：该序列为某字符串 **独有的子序列（即不能是其他字符串的子序列）**。
>
>  `s` 的 **子序列**可以通过删去字符串 `s` 中的某些字符实现。
>
> - 例如，`"abc"` 是 `"aebdc"` 的子序列，因为您可以删除`"aebdc"`中的下划线字符来得到 `"abc"` 。`"aebdc"`的子序列还包括`"aebdc"`、 `"aeb"` 和 "" (空字符串)。
>
> **示例 1：**
>
> ```
> 输入: strs = ["aba","cdc","eae"]
> 输出: 3
> ```
>
> **示例 2:**
>
> ```
> 输入: strs = ["aaa","aaa","aa"]
> 输出: -1
> ```

```java
class Solution {
    public int findLUSlength(String[] strs) {
        int N = strs.length;
        int ans = -1;
        boolean flag = true;
        for(int i= 0;i<N;i++){
            for(int j =0;j<N;j++){
                if(i!=j && isSubstr(strs[i],strs[j])){
                    flag = false;
                    break;
                }
            }
            if(flag) ans = Math.max(ans,strs[i].length());
            flag = true;
        }
        return ans;
    }

    private boolean isSubstr(String str1, String str2){
        int index1 = 0;
        int index2 = 0;
        while(index1<str1.length() && index2<str2.length()){
            if(str1.charAt(index1)==str2.charAt(index2)) index1++;
            index2++;
        }
        return index1 ==str1.length();
    }
}
```

### 6.29/[535. TinyURL 的加密与解密🔴](https://leetcode.cn/problems/encode-and-decode-tinyurl/)

> TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL `https://leetcode.com/problems/design-tinyurl` 时，它将返回一个简化的URL `http://tinyurl.com/4e9iAk` 。请你设计一个类来加密与解密 TinyURL 。
>
> 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。
>
> 实现 `Solution` 类：
>
> - `Solution()` 初始化 TinyURL 系统对象。
> - `String encode(String longUrl)` 返回 `longUrl` 对应的 TinyURL 。
> - `String decode(String shortUrl)` 返回 `shortUrl` 原本的 URL 。题目数据保证给定的 `shortUrl` 是由同一个系统对象加密的。
>
> **示例：**
>
> ```
> 输入：url = "https://leetcode.com/problems/design-tinyurl"
> 输出："https://leetcode.com/problems/design-tinyurl"
> 
> 解释：
> Solution obj = new Solution();
> string tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。
> string ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。
> ```

```java
//hash函数计算
public class Codec {
    static final int K1 = 1117;
    static final int K2 = 1000000007;
    private Map<Integer, String> dataBase = new HashMap<Integer, String>();
    private Map<String, Integer> urlToKey = new HashMap<String, Integer>();

    public String encode(String longUrl) {
        if (urlToKey.containsKey(longUrl)) {
            return "http://tinyurl.com/" + urlToKey.get(longUrl);
        }
        int key = 0;
        long base = 1;
        for (int i = 0; i < longUrl.length(); i++) {
            char c = longUrl.charAt(i);
            key = (int) ((key + (long) c * base) % K2);
            base = (base * K1) % K2;
        }
        while (dataBase.containsKey(key)) {
            key = (key + 1) % K2;
        }
        dataBase.put(key, longUrl);
        urlToKey.put(longUrl, key);
        return "http://tinyurl.com/" + key;
    }

    public String decode(String shortUrl) {
        int p = shortUrl.lastIndexOf('/') + 1;
        int key = Integer.parseInt(shortUrl.substring(p));
        return dataBase.get(key);
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/encode-and-decode-tinyurl/solution/tinyurl-de-jia-mi-yu-jie-mi-by-leetcode-ty5yp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 7.7/648单词替换

> 在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。
>
> 现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。
>
> 你需要输出替换之后的句子。
>
>  
>
> 示例 1：
>
> ```
> 输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
> 输出："the cat was rat by the bat"
> ```
>
> 示例 2：
>
> ```
> 输入：dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
> 输出："a a b c"
> ```

```java
class Solution {
    public String replaceWords(List<String> dictionary, String sentence) {
        Set<String> dictionarySet = new HashSet<String>();
        for (String root : dictionary) {
            dictionarySet.add(root);
        }
        String[] words = sentence.split(" ");
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            for (int j = 0; j < word.length(); j++) {
                if (dictionarySet.contains(word.substring(0, 1 + j))) {
                    words[i] = word.substring(0, 1 + j);
                    break;
                }
            }
        }
        return String.join(" ", words);
    }
}
```

```java
//字典树
class Solution {
      //Trie
        Class Trie{
            Map<Character, Trie> children;
            public Trie(){
                children = new HashMap<Charater,Trie>();
            }
        }
    //方法
    public String replaceWords(List<String> dictionary, String sentence) {
        Trie trie = new Trie();
        for(String word : dictionary){
            Trie cur = trie;
            for(int i  = 0;i<word.length();i++){
                char c = word.charAt(i);
                cur.children.putIfAbsent(c,new Trie());
                cur = cur.children.get(c);
            }
            cur.children.put('#',new Trie());
        }
    }
}
```

### 8.30/最大二叉树 II

> **最大树** 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。
>
> 给你最大树的根节点 `root` 和一个整数 `val` 。
>
> 就像 [之前的问题](https://leetcode.cn/problems/maximum-binary-tree/) 那样，给定的树是利用 `Construct(a)` 例程从列表 `a`（`root = Construct(a)`）递归地构建的：
>
> - 如果 `a` 为空，返回 `null` 。
> - 否则，令 `a[i]` 作为 `a` 的最大元素。创建一个值为 `a[i]` 的根节点 `root` 。
> - `root` 的左子树将被构建为 `Construct([a[0], a[1], ..., a[i - 1]])` 。
> - `root` 的右子树将被构建为 `Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])` 。
> - 返回 `root` 。
>
> 请注意，题目没有直接给出 `a` ，只是给出一个根节点 `root = Construct(a)` 。
>
> 假设 `b` 是 `a` 的副本，并在末尾附加值 `val`。题目数据保证 `b` 中的值互不相同。
>
> 返回 `Construct(b)` 。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoMaxTree(TreeNode root, int val) {
        TreeNode parent = null;
        TreeNode cur = root;
        while(cur!=null){
            if(val>cur.val){
                if(parent==null){//已经比根节点大
                    return new TreeNode(val,root,null);
                }
                TreeNode node = new TreeNode(val,cur,null);
                parent.right = node;
                return root;
            }else{//向右子树遍历寻找
                parent = cur;
                cur = cur.right;
            }
        }
        parent.right = new TreeNode(val);
        return root;
    }
}
```



# 计划

### 542.01矩阵🔴🔴

> 给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
>
> 两个相邻元素间的距离为 1 。
>

```java
//BFS
/*
	将所有0加入队列头，作为第一层
	初始化：将原来的1位置赋为最大值
	遍历：
		
*/
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
        Deque<int[]> q = new LinkedList<>();
        int m = mat.length;
        int n = mat[0].length;
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(mat[i][j]==0){
                    q.addFirst(new int[]{i,j});
                }else{
                    mat[i][j] = m+n;
                }
            }
        }
        while(!q.isEmpty()){
            int[] dot = q.pollFirst();//x,y 是当前队列头元素
            int x = dot[0];
            int y = dot[1];
            for(int[] v :dirs){
                int nx = x+v[0];
                int ny = y+v[1];
                if(nx>=0&&nx<m&&ny>=0&&ny<n){
                    if(mat[x][y]+1<mat[nx][ny]){//当前对头元素+1<边上的位置，说明边上的位置能更快到达，更新
                        mat[nx][ny] = mat[x][y]+1;
                        q.addLast(new int[]{nx,ny});//将更新过的点加入队中，看它能影响它周边哪些点
                    }
                }
            }
        }
        return mat;
    }
}
```

### 994.腐烂的橘子🔴🔴

> 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：
>
> 值 0 代表空单元格；
> 值 1 代表新鲜橘子；
> 值 2 代表腐烂的橘子。
> 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。
>
> 返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。
>
> ```
> 输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
> 输出：4
> ```
>
> 示例 2：
>
> ```
> 输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
> 输出：-1
> 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
> ```
>
> 示例 3：
>
> ```
> 输入：grid = [[0,2]]
> 输出：0
> 解释：因为 0 分钟时已
> ```

- 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。

- 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。
- 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        //要记录当前剩余新鲜橘子数，如果执行完后不为0则返回-1
        //开始先将所有的腐烂橘子加入队
        //每一轮计算当前的队列的数，队列为空时计算时间
        //遍历时将由好变坏的橘子入队
        Deque<int[]> queue = new LinkedList<>();
        int count = 0;
        int m = grid.length;
        int n = grid[0].length;
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(grid[i][j]==1){
                    count++;
                }else if(grid[i][j]==2){
                    queue.add(new int[]{i,j});
                }
            }
        }
        int rount = 0;
        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
        while(count>0&&!queue.isEmpty()){
            rount++;
            int len = queue.size();
            for(int i =0;i<len;i++){
                int[] orange = queue.poll();
                int x = orange[0];
                int y = orange[1];
                for(int[] d: dirs){
                    int nx = x+d[0];
                    int ny = y+d[1];
                    if(nx>=0&&nx<m&&ny>=0&&ny<n){
                        if(grid[nx][ny]==1){
                            grid[nx][ny] = 2;
                            queue.addLast(new int[]{nx,ny});
                            count--;
                        }
                    }
                }
            }
        }
        if(count>0){
            return -1;
        }
        return rount;
    }
}
```

### 1588.所有奇数长度子数组和🔁🔴

> 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。
>
> 子数组 定义为原数组中的一个连续子序列。
>
> 请你返回 arr 中 所有奇数长度子数组的和 。
>
>  
>
> 示例 1：
>
> ```
> 输入：arr = [1,4,2,5,3]
> 输出：58
> 解释：所有奇数长度子数组和它们的和为：
> [1] = 1
> [4] = 4
> [2] = 2
> [5] = 5
> [3] = 3
> [1,4,2] = 7
> [4,2,5] = 11
> [2,5,3] = 10
> [1,4,2,5,3] = 15
> 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
> ```
>
> 示例 2：
>
> ```
> 输入：arr = [1,2]
> 输出：3
> 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
> ```
>
> 示例 3：
>
> ```
> 输入：arr = [10,11,12]
> 输出：66
> ```

```java
//前缀和
class Solution {
     public int sumOddLengthSubarrays(int[] arr) {
        int n = arr.length;
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + arr[i];
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i; j >= 0; j -= 2) {
                res += prefix[i + 1] - prefix[j];
            }
        }
        return res;
    }
}
```

### 1356. 根据数字二进制下 1 的数目排序🔁🔴

> 给你一个整数数组 `arr` 。请你将数组中的元素按照其二进制表示中数字 **1** 的数目升序排序。
>
> 如果存在多个数字二进制中 **1** 的数目相同，则必须将它们按照数值大小升序排列。
>
> 请你返回排序后的数组。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr = [0,1,2,3,4,5,6,7,8]
> 输出：[0,1,2,4,8,3,5,6,7]
> 解释：[0] 是唯一一个有 0 个 1 的数。
> [1,2,4,8] 都有 1 个 1 。
> [3,5,6] 有 2 个 1 。
> [7] 有 3 个 1 。
> 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]
> 输出：[1,2,4,8,16,32,64,128,256,512,1024]
> 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。
> ```

```java
class Solution {
    private int cntInt(int val){
        int count = 0;
        while(val > 0) {
            val = val & (val - 1);//不停消去最低位的1
            count ++;
        }
        return count;
    }

    public int[] sortByBits(int[] arr) {
      return Arrays.stream(arr).boxed()
            .sorted(new Comparator<Integer>(){
                @Override
                public int compare(Integer o1, Integer o2) {
                    int cnt1 = cntInt(o1);
                    int cnt2 = cntInt(o2);
                    return (cnt1 == cnt2) ? Integer.compare(o1, o2) : Integer.compare(cnt1, cnt2);
                }
            })
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```

```java
//稍微好理解的
class Solution {
    public int[] sortByBits(int[] arr) {
        int[][] arrnew = new int[arr.length][2];
        for (int i = 0; i < arrnew.length; i++) {
            arrnew[i][0] = arr[i];
            arrnew[i][1] = countOne(arr[i]);
        }
        Arrays.sort(arrnew, (o1, o2) -> o1[1] == o2[1] ? o1[0] - o2[0] : o1[1] - o2[1]);
        for (int i = 0; i < arr.length; i++) {
            arr[i] = arrnew[i][0];
        }
        return arr;
    }

    public int countOne(int num) {
        int count = 0;
        while (num != 0) {
            count += (num & 1);
            num >>= 1;
        }
        return count;
    }
}
```

### 226. 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

```java
利用前序遍历
class Solution {
        // 先序遍历--从顶向下交换
        public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            // 保存右子树
            TreeNode rightTree = root.right;
            // 交换左右子树的位置
            root.right = invertTree(root.left);
            root.left = invertTree(rightTree);
            return root;
        }
    }

利用中序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            invertTree(root.left); // 递归找到左节点
            TreeNode rightNode= root.right; // 保存右节点
            root.right = root.left;
            root.left = rightNode;
            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left
            invertTree(root.left); 
    }
}

利用后序遍历
 class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 后序遍历-- 从下向上交换
            if (root == null) return null;
            TreeNode leftNode = invertTree(root.left);
            TreeNode rightNode = invertTree(root.right);
            root.right = leftNode;
            root.left = rightNode;
            return root;
        }
    }

利用层次遍历
   class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 层次遍历--直接左右交换即可
            if (root == null) return null;
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(root);
            while (!queue.isEmpty()){
                TreeNode node = queue.poll();
                TreeNode rightTree = node.right;
                node.right = node.left;
                node.left = rightTree;
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            return root;
        }
    }
```

### 191. 位1的个数

> 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

```java
//Java内置方法 String str = Integer.toBinaryString(num);
//通过与每一位作运算计算
int count = 0;
while(n>0){
    if(n&1) count++;
}
//计算最低位的1
int count = 0;
while(n>0){
    n = n&(n-1);
    count++;
}
//从最低位逐位检查
int count = 0;
while(n>0){
    if(n&1){
        count++;
    }
    n>>=1; 
}
```

### 720. 词典中最长的单词🔁🔴

> 给出一个字符串数组 `words` 组成的一本英语词典。返回 `words` 中最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。
>
> 若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。
>
> **示例 1：**
>
> ```
>输入：words = ["w","wo","wor","worl", "world"]
> 输出："world"
> 解释： 单词"world"可由"w", "wo", "wor", 和 "worl"逐步添加一个字母组成。
> ```
> 
> **示例 2：**
>
> ```
>输入：words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
> 输出："apple"
> 解释："apply" 和 "apple" 都能由词典中的单词组成。但是 "apple" 的字典序小于 "apply" 
> ```

```java
//排序（按长度），逐个检查放入map中，如果存在（短一个字母的）就存进去。
class Solution {
    public String longestWord(String[] words) {
    Arrays.sort(words);
    Set<String> set = new HashSet<>();
    String res = "";
    for (String s : words) {
        //如果单词只有一个字母，那一定是共有的
        if (s.length() == 1 || set.contains(s.substring(0, s.length() - 1))) {
            res = s.length() > res.length() ? s : res;//res是当前最长的答案
            set.add(s);
        }
    }
    return res;
    }
}
```

### 784. 字母大小写全排列🔴

> 难度中等391收藏分享切换为英文接收动态反馈
>
> 给定一个字符串 `s` ，通过将字符串 `s` 中的每个字母转变大小写，我们可以获得一个新的字符串。
>
> 返回 *所有可能得到的字符串集合* 。以 **任意顺序** 返回输出。
>
> **示例 1：**
>
> ```
> 输入：s = "a1b2"
> 输出：["a1b2", "a1B2", "A1b2", "A1B2"]
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "3z4"
> 输出: ["3z4","3Z4"]
> ```
>
>  

```java
class Solution {
    List<String> res = new ArrayList<>();
    int dis = 'A'-'a';
    public List<String> letterCasePermutation(String s) {
        if(s.length()==0){return res;}
        char[] cs = s.toCharArray();
        bt(cs,0);
        return res;
    }
    public void bt(char[] cs,int index){
        res.add(String.valueOf(cs));
        for(int i = index;i<cs.length;i++){
            if(cs[i]>='0'&&cs[i]<='9'){
                continue;
            }else if(cs[i]>='a'&&cs[i]<='z'){
                cs[i] = (char)(cs[i]+dis);
                bt(cs,i+1);
                cs[i] = (char)(cs[i]-dis);
            }else{
                cs[i] = (char)(cs[i]-dis);
                bt(cs,i+1);
                cs[i] = (char)(cs[i]+dis);
            }
        }
    }
} 
```

### 653. 两数之和 IV - 输入 BST🔴

给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

```java
class Solution {
    Set<Integer> set = new HashSet<Integer>();

    public boolean findTarget(TreeNode root, int k) {
        if (root == null) {
            return false;
        }
        if (set.contains(k - root.val)) {
            return true;
        }
        set.add(root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}
```

### 剑指 Offer 26. 树的子结构🔴

> 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
>
> B是A的子结构， 即 A中有出现和B相同的结构和节点值。
>
> 例如:
> 给定的树 A:
>
> `   3  / \  4  5 / \ 1  2`
> 给定的树 B：
>
> `  4  / 1`
> 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
>
> **示例 1：**
>
> ```
> 输入：A = [1,2,3], B = [3,1]
> 输出：false
> ```
>
> **示例 2：**
>
> ```
> 输入：A = [3,4,5,1,2], B = [4,1]
> 输出：true
> ```

```java
//递归
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(B==null) return false;
        return search(A,B);
    }
    private boolean compare(TreeNode A,TreeNode B){
        if(B==null) return true;
        if(A==null) return false;//这两行顺序不能错
        return A.val==B.val &&compare(A.left,B.left)&&compare(A.right,B.right);
    }

    private boolean search(TreeNode A,TreeNode B){
        //先序遍历到A中B根节点位置
        if(A==null) return false;
        if(A.val==B.val&&compare(A,B)) return true;
        return search(A.left,B)||search(A.right,B);
    }
}
```

