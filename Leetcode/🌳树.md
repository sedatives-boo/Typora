## 二叉树

### 144.二叉树前序遍历✅🔁🔴

> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。
>
> ```
> 输入：root = [1,null,2,3]
> 输出：[1,2,3]
> 示例 2：
> 
> 输入：root = []
> 输出：[]
> 示例 3：
> 
> 输入：root = [1]
> 输出：[1]
> 
> 输入：root = [1,null,2]
> 输出：[1,2]
> 
> 输入：root = [1,2]
> 输出：[1,2]
> ```
>
> ```java
> /**
>  * Definition for a binary tree node.
>  * public class TreeNode {
>  *     int val;
>  *     TreeNode left;
>  *     TreeNode right;
>  *     TreeNode() {}
>  *     TreeNode(int val) { this.val = val; }
>  *     TreeNode(int val, TreeNode left, TreeNode right) {
>  *         this.val = val;
>  *         this.left = left;
>  *         this.right = right;
>  *     }
>  * }
>  */
> ```

```java
//需要： 一个递归函数，当val=null时结束，如果不是null则加入List中
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
		List<Integer> result = new ArrayList<>();
        preorder(root.val, result);
		return result;
    }
    
    public void preorder(TreeNode root,List<Integer> result){
        if(root == null) return;
        result.add(root);
        preorder(root.left,result);
        preorder(root.right,result);
    }
}
```

使用栈（迭代遍历）

```java
//先将根节点入栈
//每次迭代：出栈顶元素，再将该元素的右左孩子压栈
public List<Integer> preorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();		//注意创建的时候需要泛型
    List<Integer> result = new ArrayList<>();
    if(root==null) return result;
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode top = stack.pop();
        result.add(top.val);
        if(top.right!=null)		//解题时遗漏的点，需要检查非空才入栈，和递归不一样，递归再函数开头就有空值返回
        	stack.push(top.right);
        if(top.left!=null)
        	stack.push(top.left);
    }
    return result;
    }
```

### 94.二叉树中序遍历✅🔁🔴

递归法和上题类似

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    inorder(root,res);
    return res;
}
public void inorder(TreeNode root, List<Integer> res){
    if(root==null) return;
    inorder(root.left,res);
    res.add(root.val);
    inorder(root.right,res);
}
```

现学习迭代法

```java
//超内存
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();		
    List<Integer> result = new ArrayList<>();
    if(root==null) return result;
    TreeNode cur = root;
    while(!stack.isEmpty()||cur!=null){   
       if(cur!=null){
           stack.push(cur);
           cur = cur.left;
       }else{
           cur=stack.pop();
           result.add(cur.val);
           stack.push(cur.right);//问题在此，，注意好 栈和指针的关系
       }
    }
    return result;
}
}
```

```java
//解答
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
           if (cur != null){
               stack.push(cur);
               cur = cur.left;
           }else{
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right;
           }
        }
        return result;
    }
}
```



### 145.二叉树后序遍历✅🔁🔴🔴

采用迭代法

```java
// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        if(root==null) return result;
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.left!=null) stack.push(node.left);
            if(node.right!=null) stack.push(node.right);
        }
        Collections.reverse(result);
        return result;
    }
}
```

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(!stack.isEmpty()||cur!=null){
            while(cur!=null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.peek();
            if(cur.right==null||cur.right==pre){
                list.add(cur.val);
                stack.pop();
                pre = cur;
                cur = null;
            }else{
                cur = cur.right;
            }
        }    
        return list;
    }
}
```



### 二叉树层序遍历

##### 102.二叉树层序遍历✅🔁🔴

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

```java
public List<List<Integer>> resList = new ArrayList<List<Integer>>();
 public List<List<Integer>> levelOrder(TreeNode root) {
     //checkFun01(root,0)
        checkFun02(root);//用的迭代方法
        return resList;
    }

public void checkFun02(TreeNode node){
    if(node==null) return;
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(node);
    while(!queue.isEmpty()){
        List<Integer> itemList = new ArrayList<>();
        int len = queue.size();			//通过size函数就能求得这一层多少个节点，而不是每加一个+1
        while(len>0){
            TreeNode tmpNode = queue.poll();
            itemList.add(tmpNode.val);
            if (tmpNode.left != null) queue.offer(tmpNode.left);
            if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
        }
        resList.add(tmpList);
    }
}
```

```java
//递归方式
public void checkFun01(TreeNode node,Integer deep){
    if(root==null) return ;
    deep++;
    if(resList.size()<deep){//当层级增加时，list的Item也增加，利用list的索引值进行层级界定
        List<Integer> item = new ArrayList<>();
        resList.add(item);
    }
    resList.get(deep-1).add(node.val);
    
    checkFun01(node.left,deep);
    checkFun01(node.right,deep);
}
```

##### 107.二叉树层序遍历Ⅱ✅🔁

相比于上一题，逆转List输出，本题需全程手打

```java
//这里忘了怎么逆转链表了！！！！
//直接新建一个新链表，从原链表后往前遍历加入！！
//ArrayList 是数组，支持随机存储！！！
list.get(i); //根据下标读取
list.add();	//加入当前末尾
```

##### 199.二叉树的右视图✅

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
> ```
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,null,3]
> 输出: [1,3]
> ```
>
> 相当于层序遍历的每层最后一个节点

```java
//层序遍历的稍作修改即可
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        //仅加入层序遍历每层最后一个节点
        List<Integer> itemList = new ArrayList<>();
        if(root==null) return itemList;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
        	int len = queue.size();			//通过size函数就能求得这一层多少个节点，而不是每加一个+1
        	while(len>0){
            	TreeNode tmpNode = queue.poll();
            	if(len==1) itemList.add(tmpNode.val);
            	if (tmpNode.left != null) queue.offer(tmpNode.left);
            	if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
        	}
        
    	}
   		return itemList;
    }
}
```

##### 637.二叉树的层平均值✅

> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[3.00000,14.50000,11.00000]
> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
> 因此返回 [3, 14.5, 11] 。
> ```

```java
//类似层序遍历，只不过将itemlist求得后算一遍平均值
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
	List<Double> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            int listSize = itemList.size();
            double sum = 0;
            for(int i = 0;i<listSize;i++){
                sum+=itemList.get(i);
            }
            double ave = sum/listSize;
            res.add(ave);    
        }
        return res;
    }
}
```

##### 515.每个树行的最大值✅✅✅

> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。
>
> ```
> 输入: root = [1,3,2,5,3,null,9]
> 输出: [1,3,9]
> ```
>
> **示例2：**
>
> ```
> 输入: root = [1,2,3]
> 输出: [1,3]
> ```

```java
//ArrayList 有求最大值的内置方法吗？
class Solution {
    public List<Integer> largestValues(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if(root==null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            //通过得到的itemList，找到其最大值，加入到res中
            int listSize = itemList.size();
            int max=itemList.get(0);
            for(Integer i : itemList){
                if(i>max) max=i;
            }
            res.add(max);
        }
        return res;
    }
}
```

##### 429.N叉树层序遍历✅

> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。
>
> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
>
> ```java
> /*
> // Definition for a Node.
> class Node {
> public int val;
> public List<Node> children;
> 
> public Node() {}
> 
> public Node(int _val) {
>   val = _val;
> }
> 
> public Node(int _val, List<Node> _children) {
>   val = _val;
>   children = _children;
> }
> };
> */
> 
> ```

```java
//root.children 得到的是List，则利用root.children.get(i)获取第i个孩子节点
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
         List<List<Integer>> res = new ArrayList<>();
        if(root==null) return res;
        Deque<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                Node tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                int numOfChildren = tmpNode.children.size();
                for(int i = 0;i<numOfChildren;i++){
                    queue.offer(tmpNode.children.get(i));
                }
                len--;
            }
            res.add(itemList);
        }
        return res;
    }
}
```



##### 116.填充每个节点的下一个右侧节点指针🟥

> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> struct Node {
> int val;
> Node *left;
> Node *right;
> Node *next;
> }
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if(root==null) return root;
        Deque<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>1){
                Node tmpNode = queue.poll();
                tmpNode.next = queue.peek();
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            Node tmpNode = queue.poll();
            tmpNode.next = null;
            if(tmpNode.left!=null) queue.offer(tmpNode.left);
            if(tmpNode.right!=null) queue.offer(tmpNode.right);
        }
        return root;
    }
}
```

##### 117填充每个节点的下一个右侧节点指针Ⅱ✅

> 给定一个二叉树
>
> struct Node {
> int val;
> Node *left;
> Node *right;
> Node *next;
> }
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。
>
> ```
> 和 116一样代码
> ```

##### 104.二叉树最大深度✅

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> 示例：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
>   3
>  / \
>
> 9  20
>   /  \
>  15   7
> 返回它的最大深度 3 。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            depth++;
        }
        return depth;
    }
}
```

##### 111.二叉树最小深度✅

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。

```java
//想法：与上一题类似，当遇到节点没有左右节点，返回当前深度+1
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                if(tmpNode.left==null&&tmpNode.right==null) return depth+1;
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            depth++;
        }
        return depth;
    }
}
```

### 226.翻转二叉树🟨🟩🟥

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```
>
> ```
> 输入：root = [2,1,3]
> 输出：[2,3,1]
> ```

```java
//思路：无论以什么顺序遍历完就行，每个节点反转左右子节点
class Solution {//这是前序遍历
    public TreeNode invertTree(TreeNode root) {
        preorder(root);
        return root;
    }
    public void preorder(TreeNode node){
        if(node==null) return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preorder(node.right);
        preorder(node.left);
        
    }
}
```

### 101.对称二叉树🟨🟥🟥

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称

```java
//这是错误解法，因为单纯一个层序遍历无法得出唯一的树形！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
//本题特例：   [1,2,2,null,3,null,3]
//先反转一下，在检查
class Solution {
    public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> queue = new LinkedList<>();
        List<Integer> res1 = new ArrayList<>();
        List<Integer> res2 = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            res1.add(tmp.val);
            if(tmp.left!=null) queue.offer(tmp.left);
            if(tmp.right!=null) queue.offer(tmp.right);
        }
        //这里已经得到了树的层序遍历，现在反转一下，再遍历一遍，就可以对比了
        preorder(root);//反转函数
        Deque<TreeNode> queue2 = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            res2.add(tmp.val);
            if(tmp.left!=null) queue.offer(tmp.left);
            if(tmp.right!=null) queue.offer(tmp.right);
        }
        //q1和q2对比
        int len = res1.size();
        for(int i = 0;i<len;i++){
            if(res1.get(i)!=res2.get(i)) return false;
        }
        return true;
    }
    public void preorder(TreeNode node){
        if(node==null) return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preorder(node.right);
        preorder(node.left);       
    }
}
```

```java
//题解：递归法
public boolean isSymmetric(TreeNode root){
    return compare(root.left, root.right);
}

private boolean compare(TreeNode left, TreeNode right){//同时传入两个节点
    if(left==null&&right!=null) return false;
    if(left!=null&&right==null) return false;
    if(left==null&&right==null) return true;
    if(letf.val!=right.val) return false;//排除了所有的错误情况，开始递归
    
    return compare(left.left,right.right)&&compare(left.right, right.left);
}
```

```java
//题解：迭代法
public boolean isSymmetric(TreeNode root){
    Deque<TreeNode> deque = new LinkedList<>();//使用ArrayDeque会报错
    deque.offerFirst(root.left);
    deque.offerLast(root.right);
    while(!deque.isEmpty()){
        TreeNode leftNode = deque.pollFirst();
        TreeNode rightNode = deque.pollLast();
        if(leftNode == null & rightNode ==null) continue;//注意不是returntrue； 
        if(leftNode==null||rightNode==null||leftNode.val!=rightNode.val) return false;
        deque.offerFirst(leftNode.left);
        deque.offerFirst(leftNode.right);
        deque.offerLast(rightNode.right);
        deque.offerLast(rightNode.left);
    }
    return true;
}
```



### 222.完全二叉树的节点个数🟥🟥

> 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
>
> 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1 ~ $2^h$ 个节点

```java
//遍历树用时过高     用时8%
//题解：利用性质     用时100%
class Solution{
    public int countNodes(TreeNode root){
        if(root == null) return 0;
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        if(leftDepth == rightDepth){//此时左子树是满二叉树
            return (1<<leftDepth) +countNodes(root.right);    // 1(根节点) + (1 << ld)-1(左完全左子树节点数) + 右子树节点数量       
        }else{//此时右子树必然是满二叉树，rightDepth+1=leftDepth
            return (1<<rightDepth) +countNodes(root.left);  // 1(根节点) + (1 << rd)-1(右完全右子树节点数) + 左子树节点数量
        }
    }
    
    private int getDepth(TreeNode root){
        int depth = 0;
        while(root!=null){
            root= root.left;
            depth++
        }
        return depth;
    }
 }
```

### 110.平衡二叉树🟥

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：
>
> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```java
//可以理解的解法
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;//空树为平衡
        if(Math.abs(depth(root.left)-depth(root.right))>1) return false;//左右子树高度差大于1
        return isBalanced(root.left)&&isBalanced(root.right);//本树判断完，再递归判断子树
    }
    public int depth(TreeNode root){//求子树高度
        if(root==null) return 0;
        int left = depth(root.left);//分别求左右子树高度
        int right = depth(root.right);

        return Math.max(right,left)+1;//得出本树的高度
    }
}
```



```java
class Solution {
   /**
     * 递归法
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        // 左右子树高度差大于1，return -1表示已经不是平衡树了
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

```javascript
class Solution {
   /**
     * 迭代法，效率较低，计算高度时会重复遍历
     * 时间复杂度：O(n^2)
     */
    public boolean isBalanced(TreeNode root) {
        if(root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root!= null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 比较左右子树的高度差，输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 层序遍历，求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null)   return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null)    deque.offer(poll.left);
                if (poll.right != null)   deque.offer(poll.right);
            }
        }
        return depth;
    }
}
```

```java
class Solution {
   /**
     * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历
     * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。
     * 时间复杂度：O(n)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null)   return 0;
        int leftHeight = root.left != null ? root.left.val : 0;
        int rightHeight = root.right != null ? root.right.val : 0;
        int height = Math.max(leftHeight, rightHeight) + 1;
        root.val = height;// 用TreeNode.val来保存当前结点的高度
        return height;
    }
}
```

### 257.二叉树的所有路径🟨

> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> ```
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：["1"]
> ```

```java
//递归+回溯🔁
class Solution {
    /**
     * 递归法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null)  return res;
        List<Integer> paths = new ArrayList<>();
        traversal(root, paths, res);
        return res;
    }
    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {
        paths.add(root.val);
        // 叶子结点
        if (root.left == null && root.right == null) {   // 输出
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));
            res.add(sb.toString());
            return;
        }
        if (root.left != null) {
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);// 回溯，移除path这个数组的最后一个元素，就相当于把第一行加入的节点（此节点移除）
        }
        if (root.right != null) {
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
    }
}
```

```java
// 解法2
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)  return result;
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```



### 404.左叶子之和🟩

> 给定二叉树的根节点 `root` ，返回所有左叶子之和。
>
> 输入: root = [3,9,20,null,null,15,7] 
> 输出: 24 
> 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

常用递归遍历

```java
//通过父节点寻找，if(node.left!=null&&node.left.left==null&&node.left.right==null)
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
	    if(root==null) return 0;
        int sum =0;
        if(root.left!=null&&root.left.left==null&&root.left.right==null){
            sum+=root.left.val;
        }
        return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
}
```

### 513.找树的左下角的值🟥🟥🟨

> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。
>
> 假设二叉树中至少有一个节点。

```java
//层序遍历解法，效率极低
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        //层序遍历，更新底层第一个元素
        Deque<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmp = queue.poll();
                itemList.add(tmp.val);
                if(tmp.left!=null) queue.offer(tmp.left);
                if(tmp.right!=null) queue.offer(tmp.right);
                len--;
            }
            res.add(itemList);
        }
        return res.get(res.size()-1).get(0);
    }
}
```

```java
// 递归法：维护一个Deep，这样每次传入子节点和deep+1，你叫Deep和deep+1//
//还是没理解透
class Solution {
    private int Deep = -1;
    private int value = 0;
    public int findBottomLeftValue(TreeNode root) {//主函数
        value = root.val;
        findLeftValue(root,0);
        return value;
    }

    private void findLeftValue (TreeNode root,int deep) {
        if (root == null) return;
        if (root.left == null && root.right == null) {//如果到了叶子结点 ,只有这一层第一个左结点满足deep条件，
            if (deep > Deep) {//当前deep大于Deep，保存值，修改deep
                value = root.val;
                Deep = deep;
            }
        }
        if (root.left != null) findLeftValue(root.left,deep + 1);//只要还有左结点，就不停递归
        //因为每一层最左侧的节点都是第一个读取的，后面同层的节点因为deep更新，其值不会读取，除非deep变大
        if (root.right != null) findLeftValue(root.right,deep + 1);//然后递归右节点
    }
}

/*
	递归方法（节点，当前深度）{
		为空返回；
		如果是叶子节点{
			检查当前深度是否大于最大深度
				更新结果，更新最大深度（同一层的只有最左节点才会修改值）
		}
		如果这个节点还有子节点{
			递归，传入子节点，当前深度+1
		}
		递归右节点
		{
			同理
		}
	}

*/
```

### 112.路径总和🟥🟥

> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
>
> 叶子节点 是指没有子节点的节点。
>
> ```
> 输入：root = [1,2,3], targetSum = 5
> 输出：false
> 解释：树中存在两条根节点到叶子节点的路径：
> (1 --> 2): 和为 3
> (1 --> 3): 和为 4
> 不存在 sum = 5 的根节点到叶子节点的路径。
> ```

```java
//完整的递归分析
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        targetSum -=root.val;
        if(root.left==null&&root.right==null){
            return targetSum==0;
        }

        if(root.left!=null){
            if(hasPathSum( root.left,targetSum)){
                return true;
            }
        }

        if(root.right!=null){
            if(hasPathSum(root.right,targetSum)){
                return true;
            }
        }

        return false;
    }
}
```

```java
//递归法 精简
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
         if(root==null) return false;
         if(root.left==null&&root.right==null) return root.val ==targetSum;//当叶子节点和减去的值相等，刚好路径得到
         return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
        //非叶子节点递归，只需传减去的值下去
    }
}
```

```java
//迭代法
public boolean hasPathSum(TreeNode root, int targetSum){
    if(root==null) return false;
    Stack<TreeNode> stack1 = new LinkedList<>();
    Stack<Intager> stack2 = new LinkedList<>();
    stack1.push(root);
    stack2.push(root.val);
    while(!stack1.isEmpty()){
        int size = stack1.size();
        for(int i = 0;i<size;i++){//加了这时间更快
            TreeNode node = stack1.pop();
            int sum = stack2.pop();
            if(node.left==null&&node.right==null&&sum==targetSum) return true;
            if(node.right!=null){
                stack1.push(node.right);
                stack2.push(sum+node.right.val);
            }
            if(node.left!=null){
                stack1.push(node.left);
                stack2.push(sum+=node.left.val);
            }
        }
    }
    return false;
}
```

### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> **示例 1：**
>
> <img src="../Resources/pathsumii1.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> 输出：[[5,4,11,2],[5,8,4,5]]
> ```
>
> **示例 2：**
>
> <img src="../Resources/pathsum2.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：root = [1,2,3], targetSum = 5
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [1,2], targetSum = 0
> 输出：[]
> ```















### 106.从中序和后序构造二叉树🟨

> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
>
> ```
> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> 输出：[3,9,20,null,null,15,7]
> ```
>
> 示例 2:
>
> ```
> 输入：inorder = [-1], postorder = [-1]
> 输出：[-1]
> ```

首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。说到一层一层切割，就应该想到了递归。

来看一下一共分几步：

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

```java
class Solution {🔴
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree1(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }
    public TreeNode buildTree1(int[] inorder, int inLeft, int inRight,
                               int[] postorder, int postLeft, int postRight) {
        // 没有元素了
        if (inRight - inLeft < 1) {
            return null;
        }
        // 只有一个元素了   
        if (inRight - inLeft == 1) {
            return new TreeNode(inorder[inLeft]);
        }
        // 后序数组postorder里最后一个即为根结点
        int rootVal = postorder[postRight - 1];
        TreeNode root = new TreeNode(rootVal);
        int rootIndex = 0;
        // 根据根结点的值找到该值在中序数组inorder里的位置
        for (int i = inLeft; i < inRight; i++) {
            if (inorder[i] == rootVal) {
                rootIndex = i;
                break;
            }
        }
        // 根据rootIndex划分左右子树
        root.left = buildTree1(inorder, inLeft, rootIndex,
                postorder, postLeft, postLeft + (rootIndex - inLeft));
        root.right = buildTree1(inorder, rootIndex + 1, inRight,
                postorder, postLeft + (rootIndex - inLeft), postRight - 1);
        return root;
    }
}
```

```java
//比较好理解的方法，效率低🔁
public TreeNode buildTree(int[] inorder, int[] postorder) {
        int i_len = inorder.length;
        int p_len = postorder.length;//注意length是变量，不是方法，没有（）
        if(i_len == 0 || p_len == 0){
            return null;
        }
        //通过后序序列，查找子树的根节点
        int root_val = postorder[p_len - 1];
        //构造根节点
        TreeNode root = new TreeNode(root_val);
        //遍历中序序列，确定根结点在中序序列中的位置，从而确定左右子树
        int k = 0;
        for (int i = 0; i < i_len; i++) {
            if(root_val == inorder[i]){
                k = i;//这个k就是根节点在中序的位置
                break;
            }
        }
        //分割左右子树，分别创建左右子树的中序、后序序列
        int[] left_in = Arrays.copyOfRange(inorder, 0, k);
        int[] left_post = Arrays.copyOfRange(postorder, 0, k);
        root.left = buildTree(left_in,left_post);   //注意.left 是域，不是新节点，不要TreeNode
        
        int[] right_in = Arrays.copyOfRange(inorder, k + 1, i_len);
        int[] right_post = Arrays.copyOfRange(postorder, k, p_len - 1);
        root.right = buildTree(right_in,right_post);
        return root;
    }
```

### 105.从前序与中序构造二叉树

> 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

```java
//类似上一题的解法
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int pre_length = preorder.length;
        int in_length = inorder.length;
        if(pre_length==0||in_length==0) return null;

        int root_val = preorder[0];
        TreeNode root = new TreeNode(root_val);
        int k = 0;
        for(int i = 0;i<in_length;i++){
            if(inorder[i]==root_val){
                k = i; break;
            }
        }
        //分割
        int[] left_pre = Arrays.copyOfRange(preorder,1,k+1);
        int[] left_in = Arrays.copyOfRange(inorder,0,k);
        root.left = buildTree(left_pre,left_in);

        int[] right_pre = Arrays.copyOfRange(preorder,k+1,pre_length);
        int[] rigth_in = Arrays.copyOfRange(inorder,k+1,pre_length);
        root.right = buildTree(right_pre,rigth_in);
        return root;
    }
}
```

### 654.最大二叉树🟨

> 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:
>
> 创建一个根节点，其值为 nums 中的最大值。
> 递归地在最大值 左边 的 子数组前缀上 构建左子树。
> 递归地在最大值 右边 的 子数组后缀上 构建右子树。
> 返回 nums 构建的 最大二叉树 。

```java
//采用上一题的解法可通过，效率较低
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length==0) return null;
        //找到最大值
        int max = 0;
        int max_index = 0;
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>max){
                max = nums[i];
                max_index = i;
            }
        }
        TreeNode root = new TreeNode(max);
        int[] left = Arrays.copyOfRange(nums,0,max_index);
        int[] right = Arrays.copyOfRange(nums,max_index+1,nums.length);
        root.left = constructMaximumBinaryTree(left);
        root.right = constructMaximumBinaryTree(right);
        return root;
    }
}
```

```java
//题解：用时100%，想法类似，新添加判断：没有元素和只有一个元素
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return constructMaximumBinaryTree1(nums, 0, nums.length);
    }

    public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) {
        if (rightIndex - leftIndex < 1) {// 没有元素了
            return null;
        }
        if (rightIndex - leftIndex == 1) {// 只有一个元素
            return new TreeNode(nums[leftIndex]);
        }
        int maxIndex = leftIndex;// 最大值所在位置
        int maxVal = nums[maxIndex];// 最大值
        for (int i = leftIndex + 1; i < rightIndex; i++) {
            if (nums[i] > maxVal){
                maxVal = nums[i];
                maxIndex = i;
            }
        }
        TreeNode root = new TreeNode(maxVal);
        // 根据maxIndex划分左右子树
        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);
        root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);
        return root;
    }
}
```

### 617.合并二叉树🟨

> 给你两棵二叉树： root1 和 root2 。
>
> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
>
> 返回合并后的二叉树。
>
> 注意: 合并过程必须从两个树的根节点开始。

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null) return root2;
        if(root2==null) return root1;

        TreeNode root = new TreeNode(root1.val+root2.val);
        root.left = mergeTrees(root1.left,root2.left);
        root.right = mergeTrees(root1.right,root2.right);
        return root;
    }
}
```

### 700.二叉树中的搜索🟩

> 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
>
> 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root ==null) return null;
        if(root.val == val) return root;
        if(root.val>val) return searchBST(root.left,val);
        if(root.val<val) return searchBST(root.right,val);
        return null;
    }
}
```

### 98.验证二叉搜索树🟥

> 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
>
> 有效 二叉搜索树定义如下：
>
> 节点的左子树只包含 小于 当前节点的数。
> 节点的右子树只包含 大于 当前节点的数。
> 所有左子树和右子树自身必须也是二叉搜索树。

> <font color="red">提示：递归时需要自己传入max，min作为边界条件，且重新写个递归函数，无法在原函数递归</font>
>
> 递归参数：当前节点，min，max

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
		if(root==null) return true;
        if(root.left!=null&&root.val<root.left.val) return false;
        if(root.right!=null&&root.val>root.right.val) return false;
        return (isValidBST(root.left)&&isValidBST(root.right));
    }
}
//错误，输入：
//[2,2,2]
//输出：
//true
//预期结果：
//false
```

```java
public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean validate(TreeNode node, long min, long max) {
        if (node == null) {
            return true;
        }
        if (node.val <= min || node.val >= max) {
            return false;
        }
        return  validate(node.left, min, node.val) && validate(node.right, node.val, max);
    }
```

```java
class Solution {
    // 迭代：利用中序遍历顺序
    public boolean isValidBST(TreeNode root) {
        if (root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;// 左
            }
            // 中，处理
            TreeNode pop = stack.pop();
            if (pre != null && pop.val <= pre.val) {
                return false;
            }
            pre = pop;
            root = pop.right;// 右
        }
        return true;
    }
}
```

### 530.二叉树的最小绝对差🟥

> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
>
> 差值是一个正数，其数值等于两值之差的绝对值。

> <font color="red">使用上一题解法，递归，每次与前一个比较，比中序遍历快</font>

```java
class Solution {
    public int getMinimumDifference(TreeNode root) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode pre = null;
        int res = Integer.MAX_VALUE;
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root = root.left;
            }
            TreeNode pop = stack.pop();
            if(pre!=null&&res>pop.val-pre.val){
                res = pop.val-pre.val;
            }
            pre = pop;
            root=pop.right;
        }
        return res;
    }
}
```



```java
//直接中序遍历：效率极低
class Solution {
    public int getMinimumDifference(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root,res);
        List<Integer> nums = new ArrayList<>();
        for(int i=0;i<res.size()-1;i++){
            nums.add(res.get(i+1)-res.get(i));
        }
        int min = Integer.MAX_VALUE;
        for(int i :nums){
            if(i<min) min = i;
        }
        return min;
    }

    public void inorder(TreeNode root,List<Integer> res){
        if(root==null) return;
        inorder(root.left,res);
        res.add(root.val);
        inorder(root.right,res);
    }
}
```

```java
//递归：高效率：在递归的同时就比价前序元素
class Solution {
    TreeNode pre;// 记录上一个遍历的结点
    int result = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
       if(root==null)return 0;
       traversal(root);
       return result;
    }
    public void traversal(TreeNode root){
        if(root==null)return;
        //左
        traversal(root.left);
        //中
        if(pre!=null){
            result = Math.min(result,root.val-pre.val);
        }
        pre = root;
        //右
        traversal(root.right);
    }
}
```

### 501.二叉搜索树中的众数

> 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
>
> 如果树中有不止一个众数，可以按 任意顺序 返回。
>
> 假定 BST 满足如下定义：
>
> 结点左子树中所含节点的值 小于等于 当前节点的值
> 结点右子树中所含节点的值 大于等于 当前节点的值
> 左子树和右子树都是二叉搜索树

```java
class Solution {
    ArrayList<Integer> resList;
    int maxCount;
    int count;
    TreeNode pre;

    public int[] findMode(TreeNode root) {
        resList = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;
        findMode1(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }

    public void findMode1(TreeNode root) {
        if (root == null) {
            return;
        }
        findMode1(root.left);

        int rootValue = root.val;
        // 计数
        if (pre == null || rootValue != pre.val) {
            count = 1;
        } else {
            count++;
        }
        // 更新结果以及maxCount
        if (count > maxCount) {
            resList.clear();
            resList.add(rootValue);
            maxCount = count;
        } else if (count == maxCount) {
            resList.add(rootValue);
        }
        pre = root;

        findMode1(root.right);
    }
}
```



### 235.二叉搜索树的最近公共祖先🟨

> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
> 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
> 
>
> 示例 1:
>
> ```
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
> 输出: 6 
> 解释: 节点 2 和节点 8 的最近公共祖先是 6。
> ```
>
> 示例 2:
>
> ```
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
> 输出: 2
> 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
> ```



<font color="729900">根据性质，很简单</font>





















```java
//递归法
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```





### 236.二叉树的最近公告祖先🟥🟥

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

```java
//回溯过程就是自底向上
//注意：除了p和q本身就是祖先，其他情况p和q一定在最近公共祖先的左右子树上
//递归寻找的含义
/*
	返回值： TreeNode
	一层返回条件： 本结点就是要找的p或q或本结点为null
	定义左右：递归获得：且只有祖先才能返回
	
*/
```





### 701.二叉搜索树中的插入操作

### 450.删除二叉搜索树中节点

### 669.修建二叉搜索树

### 108.有序数组转化为二叉搜索树

### 538.二叉搜索树转化为累加树

### [剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode.cn/problems/h54YBf/)

> 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
>
> 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
>
> **示例 1：**
>
> <img src="../Resources/serdeser.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：root = [1,2,3,null,null,4,5]
> 输出：[1,2,3,null,null,4,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [1]
> 输出：[1]
> ```
>
> **示例 4：**
>
> ```
> 输入：root = [1,2]
> 输出：[1,2]
> ```
