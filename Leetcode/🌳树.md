## äºŒå‰æ ‘

### 144.äºŒå‰æ ‘å‰åºéå†âœ…ğŸ”ğŸ”´

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ **å‰åº** éå†ã€‚
>
> ```
> è¾“å…¥ï¼šroot = [1,null,2,3]
> è¾“å‡ºï¼š[1,2,3]
> ç¤ºä¾‹ 2ï¼š
> 
> è¾“å…¥ï¼šroot = []
> è¾“å‡ºï¼š[]
> ç¤ºä¾‹ 3ï¼š
> 
> è¾“å…¥ï¼šroot = [1]
> è¾“å‡ºï¼š[1]
> 
> è¾“å…¥ï¼šroot = [1,null,2]
> è¾“å‡ºï¼š[1,2]
> 
> è¾“å…¥ï¼šroot = [1,2]
> è¾“å‡ºï¼š[1,2]
> ```
>
> ```java
> /**
>  * Definition for a binary tree node.
>  * public class TreeNode {
>  *     int val;
>  *     TreeNode left;
>  *     TreeNode right;
>  *     TreeNode() {}
>  *     TreeNode(int val) { this.val = val; }
>  *     TreeNode(int val, TreeNode left, TreeNode right) {
>  *         this.val = val;
>  *         this.left = left;
>  *         this.right = right;
>  *     }
>  * }
>  */
> ```

```java
//éœ€è¦ï¼š ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œå½“val=nullæ—¶ç»“æŸï¼Œå¦‚æœä¸æ˜¯nullåˆ™åŠ å…¥Listä¸­
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
		List<Integer> result = new ArrayList<>();
        preorder(root.val, result);
		return result;
    }
    
    public void preorder(TreeNode root,List<Integer> result){
        if(root == null) return;
        result.add(root);
        preorder(root.left,result);
        preorder(root.right,result);
    }
}
```

ä½¿ç”¨æ ˆï¼ˆè¿­ä»£éå†ï¼‰

```java
//å…ˆå°†æ ¹èŠ‚ç‚¹å…¥æ ˆ
//æ¯æ¬¡è¿­ä»£ï¼šå‡ºæ ˆé¡¶å…ƒç´ ï¼Œå†å°†è¯¥å…ƒç´ çš„å³å·¦å­©å­å‹æ ˆ
public List<Integer> preorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();		//æ³¨æ„åˆ›å»ºçš„æ—¶å€™éœ€è¦æ³›å‹
    List<Integer> result = new ArrayList<>();
    if(root==null) return result;
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode top = stack.pop();
        result.add(top.val);
        if(top.right!=null)		//è§£é¢˜æ—¶é—æ¼çš„ç‚¹ï¼Œéœ€è¦æ£€æŸ¥éç©ºæ‰å…¥æ ˆï¼Œå’Œé€’å½’ä¸ä¸€æ ·ï¼Œé€’å½’å†å‡½æ•°å¼€å¤´å°±æœ‰ç©ºå€¼è¿”å›
        	stack.push(top.right);
        if(top.left!=null)
        	stack.push(top.left);
    }
    return result;
    }
```

### 94.äºŒå‰æ ‘ä¸­åºéå†âœ…ğŸ”ğŸ”´

é€’å½’æ³•å’Œä¸Šé¢˜ç±»ä¼¼

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    inorder(root,res);
    return res;
}
public void inorder(TreeNode root, List<Integer> res){
    if(root==null) return;
    inorder(root.left,res);
    res.add(root.val);
    inorder(root.right,res);
}
```

ç°å­¦ä¹ è¿­ä»£æ³•

```java
//è¶…å†…å­˜
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();		
    List<Integer> result = new ArrayList<>();
    if(root==null) return result;
    TreeNode cur = root;
    while(!stack.isEmpty()||cur!=null){   
       if(cur!=null){
           stack.push(cur);
           cur = cur.left;
       }else{
           cur=stack.pop();
           result.add(cur.val);
           stack.push(cur.right);//é—®é¢˜åœ¨æ­¤ï¼Œï¼Œæ³¨æ„å¥½ æ ˆå’ŒæŒ‡é’ˆçš„å…³ç³»
       }
    }
    return result;
}
}
```

```java
//è§£ç­”
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
           if (cur != null){
               stack.push(cur);
               cur = cur.left;
           }else{
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right;
           }
        }
        return result;
    }
}
```



### 145.äºŒå‰æ ‘ååºéå†âœ…ğŸ”ğŸ”´ğŸ”´

é‡‡ç”¨è¿­ä»£æ³•

```java
// ååºéå†é¡ºåº å·¦-å³-ä¸­ å…¥æ ˆé¡ºåºï¼šä¸­-å·¦-å³ å‡ºæ ˆé¡ºåºï¼šä¸­-å³-å·¦ï¼Œ æœ€åç¿»è½¬ç»“æœ
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        if(root==null) return result;
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.left!=null) stack.push(node.left);
            if(node.right!=null) stack.push(node.right);
        }
        Collections.reverse(result);
        return result;
    }
}
```

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(!stack.isEmpty()||cur!=null){
            while(cur!=null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.peek();
            if(cur.right==null||cur.right==pre){
                list.add(cur.val);
                stack.pop();
                pre = cur;
                cur = null;
            }else{
                cur = cur.right;
            }
        }    
        return list;
    }
}
```



### äºŒå‰æ ‘å±‚åºéå†

##### 102.äºŒå‰æ ‘å±‚åºéå†âœ…ğŸ”ğŸ”´

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]
```

```java
public List<List<Integer>> resList = new ArrayList<List<Integer>>();
 public List<List<Integer>> levelOrder(TreeNode root) {
     //checkFun01(root,0)
        checkFun02(root);//ç”¨çš„è¿­ä»£æ–¹æ³•
        return resList;
    }

public void checkFun02(TreeNode node){
    if(node==null) return;
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(node);
    while(!queue.isEmpty()){
        List<Integer> itemList = new ArrayList<>();
        int len = queue.size();			//é€šè¿‡sizeå‡½æ•°å°±èƒ½æ±‚å¾—è¿™ä¸€å±‚å¤šå°‘ä¸ªèŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯æ¯åŠ ä¸€ä¸ª+1
        while(len>0){
            TreeNode tmpNode = queue.poll();
            itemList.add(tmpNode.val);
            if (tmpNode.left != null) queue.offer(tmpNode.left);
            if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
        }
        resList.add(tmpList);
    }
}
```

```java
//é€’å½’æ–¹å¼
public void checkFun01(TreeNode node,Integer deep){
    if(root==null) return ;
    deep++;
    if(resList.size()<deep){//å½“å±‚çº§å¢åŠ æ—¶ï¼Œlistçš„Itemä¹Ÿå¢åŠ ï¼Œåˆ©ç”¨listçš„ç´¢å¼•å€¼è¿›è¡Œå±‚çº§ç•Œå®š
        List<Integer> item = new ArrayList<>();
        resList.add(item);
    }
    resList.get(deep-1).add(node.val);
    
    checkFun01(node.left,deep);
    checkFun01(node.right,deep);
}
```

##### 107.äºŒå‰æ ‘å±‚åºéå†â…¡âœ…ğŸ”

ç›¸æ¯”äºä¸Šä¸€é¢˜ï¼Œé€†è½¬Listè¾“å‡ºï¼Œæœ¬é¢˜éœ€å…¨ç¨‹æ‰‹æ‰“

```java
//è¿™é‡Œå¿˜äº†æ€ä¹ˆé€†è½¬é“¾è¡¨äº†ï¼ï¼ï¼ï¼
//ç›´æ¥æ–°å»ºä¸€ä¸ªæ–°é“¾è¡¨ï¼Œä»åŸé“¾è¡¨åå¾€å‰éå†åŠ å…¥ï¼ï¼
//ArrayList æ˜¯æ•°ç»„ï¼Œæ”¯æŒéšæœºå­˜å‚¨ï¼ï¼ï¼
list.get(i); //æ ¹æ®ä¸‹æ ‡è¯»å–
list.add();	//åŠ å…¥å½“å‰æœ«å°¾
```

##### 199.äºŒå‰æ ‘çš„å³è§†å›¾âœ…

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ **æ ¹èŠ‚ç‚¹** `root`ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚
>
> ```
> è¾“å…¥: [1,2,3,null,5,null,4]
> è¾“å‡º: [1,3,4]
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥: [1,null,3]
> è¾“å‡º: [1,3]
> ```
>
> ç›¸å½“äºå±‚åºéå†çš„æ¯å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹

```java
//å±‚åºéå†çš„ç¨ä½œä¿®æ”¹å³å¯
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        //ä»…åŠ å…¥å±‚åºéå†æ¯å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹
        List<Integer> itemList = new ArrayList<>();
        if(root==null) return itemList;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
        	int len = queue.size();			//é€šè¿‡sizeå‡½æ•°å°±èƒ½æ±‚å¾—è¿™ä¸€å±‚å¤šå°‘ä¸ªèŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯æ¯åŠ ä¸€ä¸ª+1
        	while(len>0){
            	TreeNode tmpNode = queue.poll();
            	if(len==1) itemList.add(tmpNode.val);
            	if (tmpNode.left != null) queue.offer(tmpNode.left);
            	if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
        	}
        
    	}
   		return itemList;
    }
}
```

##### 637.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼âœ…

> ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` , ä»¥æ•°ç»„çš„å½¢å¼è¿”å›æ¯ä¸€å±‚èŠ‚ç‚¹çš„å¹³å‡å€¼ã€‚ä¸å®é™…ç­”æ¡ˆç›¸å·® `10-5` ä»¥å†…çš„ç­”æ¡ˆå¯ä»¥è¢«æ¥å—ã€‚
>
> ```
> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
> è¾“å‡ºï¼š[3.00000,14.50000,11.00000]
> è§£é‡Šï¼šç¬¬ 0 å±‚çš„å¹³å‡å€¼ä¸º 3,ç¬¬ 1 å±‚çš„å¹³å‡å€¼ä¸º 14.5,ç¬¬ 2 å±‚çš„å¹³å‡å€¼ä¸º 11 ã€‚
> å› æ­¤è¿”å› [3, 14.5, 11] ã€‚
> ```

```java
//ç±»ä¼¼å±‚åºéå†ï¼Œåªä¸è¿‡å°†itemlistæ±‚å¾—åç®—ä¸€éå¹³å‡å€¼
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
	List<Double> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            int listSize = itemList.size();
            double sum = 0;
            for(int i = 0;i<listSize;i++){
                sum+=itemList.get(i);
            }
            double ave = sum/listSize;
            res.add(ave);    
        }
        return res;
    }
}
```

##### 515.æ¯ä¸ªæ ‘è¡Œçš„æœ€å¤§å€¼âœ…âœ…âœ…

> ç»™å®šä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘ä¸­æ¯ä¸€å±‚çš„æœ€å¤§å€¼ã€‚
>
> ```
> è¾“å…¥: root = [1,3,2,5,3,null,9]
> è¾“å‡º: [1,3,9]
> ```
>
> **ç¤ºä¾‹2ï¼š**
>
> ```
> è¾“å…¥: root = [1,2,3]
> è¾“å‡º: [1,3]
> ```

```java
//ArrayList æœ‰æ±‚æœ€å¤§å€¼çš„å†…ç½®æ–¹æ³•å—ï¼Ÿ
class Solution {
    public List<Integer> largestValues(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if(root==null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            //é€šè¿‡å¾—åˆ°çš„itemListï¼Œæ‰¾åˆ°å…¶æœ€å¤§å€¼ï¼ŒåŠ å…¥åˆ°resä¸­
            int listSize = itemList.size();
            int max=itemList.get(0);
            for(Integer i : itemList){
                if(i>max) max=i;
            }
            res.add(max);
        }
        return res;
    }
}
```

##### 429.Nå‰æ ‘å±‚åºéå†âœ…

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„*å±‚åºéå†*ã€‚ï¼ˆå³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†ï¼‰ã€‚
>
> æ ‘çš„åºåˆ—åŒ–è¾“å…¥æ˜¯ç”¨å±‚åºéå†ï¼Œæ¯ç»„å­èŠ‚ç‚¹éƒ½ç”± null å€¼åˆ†éš”ï¼ˆå‚è§ç¤ºä¾‹ï¼‰ã€‚
>
> ```java
> /*
> // Definition for a Node.
> class Node {
> public int val;
> public List<Node> children;
> 
> public Node() {}
> 
> public Node(int _val) {
>   val = _val;
> }
> 
> public Node(int _val, List<Node> _children) {
>   val = _val;
>   children = _children;
> }
> };
> */
> 
> ```

```java
//root.children å¾—åˆ°çš„æ˜¯Listï¼Œåˆ™åˆ©ç”¨root.children.get(i)è·å–ç¬¬iä¸ªå­©å­èŠ‚ç‚¹
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
         List<List<Integer>> res = new ArrayList<>();
        if(root==null) return res;
        Deque<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                Node tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                int numOfChildren = tmpNode.children.size();
                for(int i = 0;i<numOfChildren;i++){
                    queue.offer(tmpNode.children.get(i));
                }
                len--;
            }
            res.add(itemList);
        }
        return res;
    }
}
```



##### 116.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆğŸŸ¥

> ç»™å®šä¸€ä¸ª å®Œç¾äºŒå‰æ ‘ ï¼Œå…¶æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚ï¼Œæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
>
> struct Node {
> int val;
> Node *left;
> Node *right;
> Node *next;
> }
> å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚
>
> åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if(root==null) return root;
        Deque<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>1){
                Node tmpNode = queue.poll();
                tmpNode.next = queue.peek();
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            Node tmpNode = queue.poll();
            tmpNode.next = null;
            if(tmpNode.left!=null) queue.offer(tmpNode.left);
            if(tmpNode.right!=null) queue.offer(tmpNode.right);
        }
        return root;
    }
}
```

##### 117å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆâ…¡âœ…

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘
>
> struct Node {
> int val;
> Node *left;
> Node *right;
> Node *next;
> }
> å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚
>
> åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚
>
> ```
> å’Œ 116ä¸€æ ·ä»£ç 
> ```

##### 104.äºŒå‰æ ‘æœ€å¤§æ·±åº¦âœ…

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
>
> äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚
>
> è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> ç¤ºä¾‹ï¼š
> ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7]ï¼Œ
>
>   3
>  / \
>
> 9  20
>   /  \
>  15   7
> è¿”å›å®ƒçš„æœ€å¤§æ·±åº¦ 3 ã€‚

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            depth++;
        }
        return depth;
    }
}
```

##### 111.äºŒå‰æ ‘æœ€å°æ·±åº¦âœ…

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚
>
> æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚
>
> **è¯´æ˜ï¼š**å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

```java
//æƒ³æ³•ï¼šä¸ä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œå½“é‡åˆ°èŠ‚ç‚¹æ²¡æœ‰å·¦å³èŠ‚ç‚¹ï¼Œè¿”å›å½“å‰æ·±åº¦+1
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                if(tmpNode.left==null&&tmpNode.right==null) return depth+1;
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            depth++;
        }
        return depth;
    }
}
```

### 226.ç¿»è½¬äºŒå‰æ ‘ğŸŸ¨ğŸŸ©ğŸŸ¥

> ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚
>
> ```
> è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
> è¾“å‡ºï¼š[4,7,2,9,6,3,1]
> ```
>
> ```
> è¾“å…¥ï¼šroot = [2,1,3]
> è¾“å‡ºï¼š[2,3,1]
> ```

```java
//æ€è·¯ï¼šæ— è®ºä»¥ä»€ä¹ˆé¡ºåºéå†å®Œå°±è¡Œï¼Œæ¯ä¸ªèŠ‚ç‚¹åè½¬å·¦å³å­èŠ‚ç‚¹
class Solution {//è¿™æ˜¯å‰åºéå†
    public TreeNode invertTree(TreeNode root) {
        preorder(root);
        return root;
    }
    public void preorder(TreeNode node){
        if(node==null) return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preorder(node.right);
        preorder(node.left);
        
    }
}
```

### 101.å¯¹ç§°äºŒå‰æ ‘ğŸŸ¨ğŸŸ¥ğŸŸ¥

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°

```java
//è¿™æ˜¯é”™è¯¯è§£æ³•ï¼Œå› ä¸ºå•çº¯ä¸€ä¸ªå±‚åºéå†æ— æ³•å¾—å‡ºå”¯ä¸€çš„æ ‘å½¢ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼
//æœ¬é¢˜ç‰¹ä¾‹ï¼š   [1,2,2,null,3,null,3]
//å…ˆåè½¬ä¸€ä¸‹ï¼Œåœ¨æ£€æŸ¥
class Solution {
    public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> queue = new LinkedList<>();
        List<Integer> res1 = new ArrayList<>();
        List<Integer> res2 = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            res1.add(tmp.val);
            if(tmp.left!=null) queue.offer(tmp.left);
            if(tmp.right!=null) queue.offer(tmp.right);
        }
        //è¿™é‡Œå·²ç»å¾—åˆ°äº†æ ‘çš„å±‚åºéå†ï¼Œç°åœ¨åè½¬ä¸€ä¸‹ï¼Œå†éå†ä¸€éï¼Œå°±å¯ä»¥å¯¹æ¯”äº†
        preorder(root);//åè½¬å‡½æ•°
        Deque<TreeNode> queue2 = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            res2.add(tmp.val);
            if(tmp.left!=null) queue.offer(tmp.left);
            if(tmp.right!=null) queue.offer(tmp.right);
        }
        //q1å’Œq2å¯¹æ¯”
        int len = res1.size();
        for(int i = 0;i<len;i++){
            if(res1.get(i)!=res2.get(i)) return false;
        }
        return true;
    }
    public void preorder(TreeNode node){
        if(node==null) return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preorder(node.right);
        preorder(node.left);       
    }
}
```

```java
//é¢˜è§£ï¼šé€’å½’æ³•
public boolean isSymmetric(TreeNode root){
    return compare(root.left, root.right);
}

private boolean compare(TreeNode left, TreeNode right){//åŒæ—¶ä¼ å…¥ä¸¤ä¸ªèŠ‚ç‚¹
    if(left==null&&right!=null) return false;
    if(left!=null&&right==null) return false;
    if(left==null&&right==null) return true;
    if(letf.val!=right.val) return false;//æ’é™¤äº†æ‰€æœ‰çš„é”™è¯¯æƒ…å†µï¼Œå¼€å§‹é€’å½’
    
    return compare(left.left,right.right)&&compare(left.right, right.left);
}
```

```java
//é¢˜è§£ï¼šè¿­ä»£æ³•
public boolean isSymmetric(TreeNode root){
    Deque<TreeNode> deque = new LinkedList<>();//ä½¿ç”¨ArrayDequeä¼šæŠ¥é”™
    deque.offerFirst(root.left);
    deque.offerLast(root.right);
    while(!deque.isEmpty()){
        TreeNode leftNode = deque.pollFirst();
        TreeNode rightNode = deque.pollLast();
        if(leftNode == null & rightNode ==null) continue;//æ³¨æ„ä¸æ˜¯returntrueï¼› 
        if(leftNode==null||rightNode==null||leftNode.val!=rightNode.val) return false;
        deque.offerFirst(leftNode.left);
        deque.offerFirst(leftNode.right);
        deque.offerLast(rightNode.right);
        deque.offerLast(rightNode.left);
    }
    return true;
}
```



### 222.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ğŸŸ¥ğŸŸ¥

> ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
>
> å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« 1 ~ $2^h$ ä¸ªèŠ‚ç‚¹

```java
//éå†æ ‘ç”¨æ—¶è¿‡é«˜     ç”¨æ—¶8%
//é¢˜è§£ï¼šåˆ©ç”¨æ€§è´¨     ç”¨æ—¶100%
class Solution{
    public int countNodes(TreeNode root){
        if(root == null) return 0;
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        if(leftDepth == rightDepth){//æ­¤æ—¶å·¦å­æ ‘æ˜¯æ»¡äºŒå‰æ ‘
            return (1<<leftDepth) +countNodes(root.right);    // 1(æ ¹èŠ‚ç‚¹) + (1 << ld)-1(å·¦å®Œå…¨å·¦å­æ ‘èŠ‚ç‚¹æ•°) + å³å­æ ‘èŠ‚ç‚¹æ•°é‡       
        }else{//æ­¤æ—¶å³å­æ ‘å¿…ç„¶æ˜¯æ»¡äºŒå‰æ ‘ï¼ŒrightDepth+1=leftDepth
            return (1<<rightDepth) +countNodes(root.left);  // 1(æ ¹èŠ‚ç‚¹) + (1 << rd)-1(å³å®Œå…¨å³å­æ ‘èŠ‚ç‚¹æ•°) + å·¦å­æ ‘èŠ‚ç‚¹æ•°é‡
        }
    }
    
    private int getDepth(TreeNode root){
        int depth = 0;
        while(root!=null){
            root= root.left;
            depth++
        }
        return depth;
    }
 }
```

### 110.å¹³è¡¡äºŒå‰æ ‘ğŸŸ¥

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
>
> æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
>
> ä¸€ä¸ªäºŒå‰æ ‘*æ¯ä¸ªèŠ‚ç‚¹* çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€‚

```java
//å¯ä»¥ç†è§£çš„è§£æ³•
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;//ç©ºæ ‘ä¸ºå¹³è¡¡
        if(Math.abs(depth(root.left)-depth(root.right))>1) return false;//å·¦å³å­æ ‘é«˜åº¦å·®å¤§äº1
        return isBalanced(root.left)&&isBalanced(root.right);//æœ¬æ ‘åˆ¤æ–­å®Œï¼Œå†é€’å½’åˆ¤æ–­å­æ ‘
    }
    public int depth(TreeNode root){//æ±‚å­æ ‘é«˜åº¦
        if(root==null) return 0;
        int left = depth(root.left);//åˆ†åˆ«æ±‚å·¦å³å­æ ‘é«˜åº¦
        int right = depth(root.right);

        return Math.max(right,left)+1;//å¾—å‡ºæœ¬æ ‘çš„é«˜åº¦
    }
}
```



```java
class Solution {
   /**
     * é€’å½’æ³•
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        // å·¦å³å­æ ‘é«˜åº¦å·®å¤§äº1ï¼Œreturn -1è¡¨ç¤ºå·²ç»ä¸æ˜¯å¹³è¡¡æ ‘äº†
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

```javascript
class Solution {
   /**
     * è¿­ä»£æ³•ï¼Œæ•ˆç‡è¾ƒä½ï¼Œè®¡ç®—é«˜åº¦æ—¶ä¼šé‡å¤éå†
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)
     */
    public boolean isBalanced(TreeNode root) {
        if(root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root!= null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // å³ç»“ç‚¹ä¸ºnullæˆ–å·²ç»éå†è¿‡
            if (inNode.right == null || inNode.right == pre) {
                // æ¯”è¾ƒå·¦å³å­æ ‘çš„é«˜åº¦å·®ï¼Œè¾“å‡º
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// å½“å‰ç»“ç‚¹ä¸‹ï¼Œæ²¡æœ‰è¦éå†çš„ç»“ç‚¹äº†
            } else {
                root = inNode.right;// å³ç»“ç‚¹è¿˜æ²¡éå†ï¼Œéå†å³ç»“ç‚¹
            }
        }
        return true;
    }

    /**
     * å±‚åºéå†ï¼Œæ±‚ç»“ç‚¹çš„é«˜åº¦
     */
    public int getHeight(TreeNode root) {
        if (root == null)   return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null)    deque.offer(poll.left);
                if (poll.right != null)   deque.offer(poll.right);
            }
        }
        return depth;
    }
}
```

```java
class Solution {
   /**
     * ä¼˜åŒ–è¿­ä»£æ³•ï¼Œé’ˆå¯¹æš´åŠ›è¿­ä»£æ³•çš„getHeightæ–¹æ³•åšä¼˜åŒ–ï¼Œåˆ©ç”¨TreeNode.valæ¥ä¿å­˜å½“å‰ç»“ç‚¹çš„é«˜åº¦ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰é‡å¤éå†
     * è·å–é«˜åº¦ç®—æ³•æ—¶é—´å¤æ‚åº¦å¯ä»¥é™åˆ°O(1)ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦é™ä¸ºO(n)ã€‚
     * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // å³ç»“ç‚¹ä¸ºnullæˆ–å·²ç»éå†è¿‡
            if (inNode.right == null || inNode.right == pre) {
                // è¾“å‡º
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// å½“å‰ç»“ç‚¹ä¸‹ï¼Œæ²¡æœ‰è¦éå†çš„ç»“ç‚¹äº†
            } else {
                root = inNode.right;// å³ç»“ç‚¹è¿˜æ²¡éå†ï¼Œéå†å³ç»“ç‚¹
            }
        }
        return true;
    }

    /**
     * æ±‚ç»“ç‚¹çš„é«˜åº¦
     */
    public int getHeight(TreeNode root) {
        if (root == null)   return 0;
        int leftHeight = root.left != null ? root.left.val : 0;
        int rightHeight = root.right != null ? root.right.val : 0;
        int height = Math.max(leftHeight, rightHeight) + 1;
        root.val = height;// ç”¨TreeNode.valæ¥ä¿å­˜å½“å‰ç»“ç‚¹çš„é«˜åº¦
        return height;
    }
}
```

### 257.äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ğŸŸ¨

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼ŒæŒ‰ **ä»»æ„é¡ºåº** ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
>
> **å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> ```
> è¾“å…¥ï¼šroot = [1,2,3,null,5]
> è¾“å‡ºï¼š["1->2->5","1->3"]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šroot = [1]
> è¾“å‡ºï¼š["1"]
> ```

```java
//é€’å½’+å›æº¯ğŸ”
class Solution {
    /**
     * é€’å½’æ³•
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null)  return res;
        List<Integer> paths = new ArrayList<>();
        traversal(root, paths, res);
        return res;
    }
    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {
        paths.add(root.val);
        // å¶å­ç»“ç‚¹
        if (root.left == null && root.right == null) {   // è¾“å‡º
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));
            res.add(sb.toString());
            return;
        }
        if (root.left != null) {
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);// å›æº¯ï¼Œç§»é™¤pathè¿™ä¸ªæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå°±ç›¸å½“äºæŠŠç¬¬ä¸€è¡ŒåŠ å…¥çš„èŠ‚ç‚¹ï¼ˆæ­¤èŠ‚ç‚¹ç§»é™¤ï¼‰
        }
        if (root.right != null) {
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);// å›æº¯
        }
    }
}
```

```java
// è§£æ³•2
class Solution {
    /**
     * è¿­ä»£æ³•
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)  return result;
        Stack<Object> stack = new Stack<>();
        // èŠ‚ç‚¹å’Œè·¯å¾„åŒæ—¶å…¥æ ˆ
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // èŠ‚ç‚¹å’Œè·¯å¾„åŒæ—¶å‡ºæ ˆ
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // è‹¥æ‰¾åˆ°å¶å­èŠ‚ç‚¹
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //å³å­èŠ‚ç‚¹ä¸ä¸ºç©º
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //å·¦å­èŠ‚ç‚¹ä¸ä¸ºç©º
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```



### 404.å·¦å¶å­ä¹‹å’ŒğŸŸ©

> ç»™å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
>
> è¾“å…¥: root = [3,9,20,null,null,15,7] 
> è¾“å‡º: 24 
> è§£é‡Š: åœ¨è¿™ä¸ªäºŒå‰æ ‘ä¸­ï¼Œæœ‰ä¸¤ä¸ªå·¦å¶å­ï¼Œåˆ†åˆ«æ˜¯ 9 å’Œ 15ï¼Œæ‰€ä»¥è¿”å› 24

å¸¸ç”¨é€’å½’éå†

```java
//é€šè¿‡çˆ¶èŠ‚ç‚¹å¯»æ‰¾ï¼Œif(node.left!=null&&node.left.left==null&&node.left.right==null)
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
	    if(root==null) return 0;
        int sum =0;
        if(root.left!=null&&root.left.left==null&&root.left.right==null){
            sum+=root.left.val;
        }
        return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
}
```

### 513.æ‰¾æ ‘çš„å·¦ä¸‹è§’çš„å€¼ğŸŸ¥ğŸŸ¥ğŸŸ¨

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ **æ ¹èŠ‚ç‚¹** `root`ï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘çš„ **æœ€åº•å±‚ æœ€å·¦è¾¹** èŠ‚ç‚¹çš„å€¼ã€‚
>
> å‡è®¾äºŒå‰æ ‘ä¸­è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚

```java
//å±‚åºéå†è§£æ³•ï¼Œæ•ˆç‡æä½
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        //å±‚åºéå†ï¼Œæ›´æ–°åº•å±‚ç¬¬ä¸€ä¸ªå…ƒç´ 
        Deque<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmp = queue.poll();
                itemList.add(tmp.val);
                if(tmp.left!=null) queue.offer(tmp.left);
                if(tmp.right!=null) queue.offer(tmp.right);
                len--;
            }
            res.add(itemList);
        }
        return res.get(res.size()-1).get(0);
    }
}
```

```java
// é€’å½’æ³•ï¼šç»´æŠ¤ä¸€ä¸ªDeepï¼Œè¿™æ ·æ¯æ¬¡ä¼ å…¥å­èŠ‚ç‚¹å’Œdeep+1ï¼Œä½ å«Deepå’Œdeep+1//
//è¿˜æ˜¯æ²¡ç†è§£é€
class Solution {
    private int Deep = -1;
    private int value = 0;
    public int findBottomLeftValue(TreeNode root) {//ä¸»å‡½æ•°
        value = root.val;
        findLeftValue(root,0);
        return value;
    }

    private void findLeftValue (TreeNode root,int deep) {
        if (root == null) return;
        if (root.left == null && root.right == null) {//å¦‚æœåˆ°äº†å¶å­ç»“ç‚¹ ,åªæœ‰è¿™ä¸€å±‚ç¬¬ä¸€ä¸ªå·¦ç»“ç‚¹æ»¡è¶³deepæ¡ä»¶ï¼Œ
            if (deep > Deep) {//å½“å‰deepå¤§äºDeepï¼Œä¿å­˜å€¼ï¼Œä¿®æ”¹deep
                value = root.val;
                Deep = deep;
            }
        }
        if (root.left != null) findLeftValue(root.left,deep + 1);//åªè¦è¿˜æœ‰å·¦ç»“ç‚¹ï¼Œå°±ä¸åœé€’å½’
        //å› ä¸ºæ¯ä¸€å±‚æœ€å·¦ä¾§çš„èŠ‚ç‚¹éƒ½æ˜¯ç¬¬ä¸€ä¸ªè¯»å–çš„ï¼Œåé¢åŒå±‚çš„èŠ‚ç‚¹å› ä¸ºdeepæ›´æ–°ï¼Œå…¶å€¼ä¸ä¼šè¯»å–ï¼Œé™¤édeepå˜å¤§
        if (root.right != null) findLeftValue(root.right,deep + 1);//ç„¶åé€’å½’å³èŠ‚ç‚¹
    }
}

/*
	é€’å½’æ–¹æ³•ï¼ˆèŠ‚ç‚¹ï¼Œå½“å‰æ·±åº¦ï¼‰{
		ä¸ºç©ºè¿”å›ï¼›
		å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹{
			æ£€æŸ¥å½“å‰æ·±åº¦æ˜¯å¦å¤§äºæœ€å¤§æ·±åº¦
				æ›´æ–°ç»“æœï¼Œæ›´æ–°æœ€å¤§æ·±åº¦ï¼ˆåŒä¸€å±‚çš„åªæœ‰æœ€å·¦èŠ‚ç‚¹æ‰ä¼šä¿®æ”¹å€¼ï¼‰
		}
		å¦‚æœè¿™ä¸ªèŠ‚ç‚¹è¿˜æœ‰å­èŠ‚ç‚¹{
			é€’å½’ï¼Œä¼ å…¥å­èŠ‚ç‚¹ï¼Œå½“å‰æ·±åº¦+1
		}
		é€’å½’å³èŠ‚ç‚¹
		{
			åŒç†
		}
	}

*/
```

### 112.è·¯å¾„æ€»å’ŒğŸŸ¥ğŸŸ¥

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° targetSum ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ targetSum ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
>
> å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> ```
> è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
> è¾“å‡ºï¼šfalse
> è§£é‡Šï¼šæ ‘ä¸­å­˜åœ¨ä¸¤æ¡æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼š
> (1 --> 2): å’Œä¸º 3
> (1 --> 3): å’Œä¸º 4
> ä¸å­˜åœ¨ sum = 5 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
> ```

```java
//å®Œæ•´çš„é€’å½’åˆ†æ
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        targetSum -=root.val;
        if(root.left==null&&root.right==null){
            return targetSum==0;
        }

        if(root.left!=null){
            if(hasPathSum( root.left,targetSum)){
                return true;
            }
        }

        if(root.right!=null){
            if(hasPathSum(root.right,targetSum)){
                return true;
            }
        }

        return false;
    }
}
```

```java
//é€’å½’æ³• ç²¾ç®€
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
         if(root==null) return false;
         if(root.left==null&&root.right==null) return root.val ==targetSum;//å½“å¶å­èŠ‚ç‚¹å’Œå‡å»çš„å€¼ç›¸ç­‰ï¼Œåˆšå¥½è·¯å¾„å¾—åˆ°
         return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
        //éå¶å­èŠ‚ç‚¹é€’å½’ï¼Œåªéœ€ä¼ å‡å»çš„å€¼ä¸‹å»
    }
}
```

```java
//è¿­ä»£æ³•
public boolean hasPathSum(TreeNode root, int targetSum){
    if(root==null) return false;
    Stack<TreeNode> stack1 = new LinkedList<>();
    Stack<Intager> stack2 = new LinkedList<>();
    stack1.push(root);
    stack2.push(root.val);
    while(!stack1.isEmpty()){
        int size = stack1.size();
        for(int i = 0;i<size;i++){//åŠ äº†è¿™æ—¶é—´æ›´å¿«
            TreeNode node = stack1.pop();
            int sum = stack2.pop();
            if(node.left==null&&node.right==null&&sum==targetSum) return true;
            if(node.right!=null){
                stack1.push(node.right);
                stack2.push(sum+node.right.val);
            }
            if(node.left!=null){
                stack1.push(node.left);
                stack2.push(sum+=node.left.val);
            }
        }
    }
    return false;
}
```

### [113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/)

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ `targetSum` ï¼Œæ‰¾å‡ºæ‰€æœ‰ **ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚
>
> **å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> <img src="../Resources/pathsumii1.jpg" alt="img" style="zoom:67%;" />
>
> ```
> è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> è¾“å‡ºï¼š[[5,4,11,2],[5,8,4,5]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> <img src="../Resources/pathsum2.jpg" alt="img" style="zoom:67%;" />
>
> ```
> è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
> è¾“å‡ºï¼š[]
> ```
>
> **ç¤ºä¾‹ 3ï¼š**
>
> ```
> è¾“å…¥ï¼šroot = [1,2], targetSum = 0
> è¾“å‡ºï¼š[]
> ```















### 106.ä»ä¸­åºå’Œååºæ„é€ äºŒå‰æ ‘ğŸŸ¨

> ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `inorder` å’Œ `postorder` ï¼Œå…¶ä¸­ `inorder` æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ `postorder` æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— äºŒå‰æ ‘ ã€‚
>
> ```
> è¾“å…¥ï¼šinorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> è¾“å‡ºï¼š[3,9,20,null,null,15,7]
> ```
>
> ç¤ºä¾‹ 2:
>
> ```
> è¾“å…¥ï¼šinorder = [-1], postorder = [-1]
> è¾“å‡ºï¼š[-1]
> ```

é¦–å…ˆå›å¿†ä¸€ä¸‹å¦‚ä½•æ ¹æ®ä¸¤ä¸ªé¡ºåºæ„é€ ä¸€ä¸ªå”¯ä¸€çš„äºŒå‰æ ‘ï¼Œç›¸ä¿¡ç†è®ºçŸ¥è¯†å¤§å®¶åº”è¯¥éƒ½æ¸…æ¥šï¼Œå°±æ˜¯ä»¥ ååºæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ä¸ºåˆ‡å‰²ç‚¹ï¼Œå…ˆåˆ‡ä¸­åºæ•°ç»„ï¼Œæ ¹æ®ä¸­åºæ•°ç»„ï¼Œåè¿‡æ¥åœ¨åˆ‡ååºæ•°ç»„ã€‚ä¸€å±‚ä¸€å±‚åˆ‡ä¸‹å»ï¼Œæ¯æ¬¡ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ å°±æ˜¯èŠ‚ç‚¹å…ƒç´ ã€‚è¯´åˆ°ä¸€å±‚ä¸€å±‚åˆ‡å‰²ï¼Œå°±åº”è¯¥æƒ³åˆ°äº†é€’å½’ã€‚

æ¥çœ‹ä¸€ä¸‹ä¸€å…±åˆ†å‡ æ­¥ï¼š

- ç¬¬ä¸€æ­¥ï¼šå¦‚æœæ•°ç»„å¤§å°ä¸ºé›¶çš„è¯ï¼Œè¯´æ˜æ˜¯ç©ºèŠ‚ç‚¹äº†ã€‚
- ç¬¬äºŒæ­¥ï¼šå¦‚æœä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå–ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºèŠ‚ç‚¹å…ƒç´ ã€‚
- ç¬¬ä¸‰æ­¥ï¼šæ‰¾åˆ°ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œä½œä¸ºåˆ‡å‰²ç‚¹
- ç¬¬å››æ­¥ï¼šåˆ‡å‰²ä¸­åºæ•°ç»„ï¼Œåˆ‡æˆä¸­åºå·¦æ•°ç»„å’Œä¸­åºå³æ•°ç»„ ï¼ˆé¡ºåºåˆ«æåäº†ï¼Œä¸€å®šæ˜¯å…ˆåˆ‡ä¸­åºæ•°ç»„ï¼‰
- ç¬¬äº”æ­¥ï¼šåˆ‡å‰²ååºæ•°ç»„ï¼Œåˆ‡æˆååºå·¦æ•°ç»„å’Œååºå³æ•°ç»„
- ç¬¬å…­æ­¥ï¼šé€’å½’å¤„ç†å·¦åŒºé—´å’Œå³åŒºé—´

```java
class Solution {ğŸ”´
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree1(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }
    public TreeNode buildTree1(int[] inorder, int inLeft, int inRight,
                               int[] postorder, int postLeft, int postRight) {
        // æ²¡æœ‰å…ƒç´ äº†
        if (inRight - inLeft < 1) {
            return null;
        }
        // åªæœ‰ä¸€ä¸ªå…ƒç´ äº†   
        if (inRight - inLeft == 1) {
            return new TreeNode(inorder[inLeft]);
        }
        // ååºæ•°ç»„postorderé‡Œæœ€åä¸€ä¸ªå³ä¸ºæ ¹ç»“ç‚¹
        int rootVal = postorder[postRight - 1];
        TreeNode root = new TreeNode(rootVal);
        int rootIndex = 0;
        // æ ¹æ®æ ¹ç»“ç‚¹çš„å€¼æ‰¾åˆ°è¯¥å€¼åœ¨ä¸­åºæ•°ç»„inorderé‡Œçš„ä½ç½®
        for (int i = inLeft; i < inRight; i++) {
            if (inorder[i] == rootVal) {
                rootIndex = i;
                break;
            }
        }
        // æ ¹æ®rootIndexåˆ’åˆ†å·¦å³å­æ ‘
        root.left = buildTree1(inorder, inLeft, rootIndex,
                postorder, postLeft, postLeft + (rootIndex - inLeft));
        root.right = buildTree1(inorder, rootIndex + 1, inRight,
                postorder, postLeft + (rootIndex - inLeft), postRight - 1);
        return root;
    }
}
```

```java
//æ¯”è¾ƒå¥½ç†è§£çš„æ–¹æ³•ï¼Œæ•ˆç‡ä½ğŸ”
public TreeNode buildTree(int[] inorder, int[] postorder) {
        int i_len = inorder.length;
        int p_len = postorder.length;//æ³¨æ„lengthæ˜¯å˜é‡ï¼Œä¸æ˜¯æ–¹æ³•ï¼Œæ²¡æœ‰ï¼ˆï¼‰
        if(i_len == 0 || p_len == 0){
            return null;
        }
        //é€šè¿‡ååºåºåˆ—ï¼ŒæŸ¥æ‰¾å­æ ‘çš„æ ¹èŠ‚ç‚¹
        int root_val = postorder[p_len - 1];
        //æ„é€ æ ¹èŠ‚ç‚¹
        TreeNode root = new TreeNode(root_val);
        //éå†ä¸­åºåºåˆ—ï¼Œç¡®å®šæ ¹ç»“ç‚¹åœ¨ä¸­åºåºåˆ—ä¸­çš„ä½ç½®ï¼Œä»è€Œç¡®å®šå·¦å³å­æ ‘
        int k = 0;
        for (int i = 0; i < i_len; i++) {
            if(root_val == inorder[i]){
                k = i;//è¿™ä¸ªkå°±æ˜¯æ ¹èŠ‚ç‚¹åœ¨ä¸­åºçš„ä½ç½®
                break;
            }
        }
        //åˆ†å‰²å·¦å³å­æ ‘ï¼Œåˆ†åˆ«åˆ›å»ºå·¦å³å­æ ‘çš„ä¸­åºã€ååºåºåˆ—
        int[] left_in = Arrays.copyOfRange(inorder, 0, k);
        int[] left_post = Arrays.copyOfRange(postorder, 0, k);
        root.left = buildTree(left_in,left_post);   //æ³¨æ„.left æ˜¯åŸŸï¼Œä¸æ˜¯æ–°èŠ‚ç‚¹ï¼Œä¸è¦TreeNode
        
        int[] right_in = Arrays.copyOfRange(inorder, k + 1, i_len);
        int[] right_post = Arrays.copyOfRange(postorder, k, p_len - 1);
        root.right = buildTree(right_in,right_post);
        return root;
    }
```

### 105.ä»å‰åºä¸ä¸­åºæ„é€ äºŒå‰æ ‘

> ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ preorder å’Œ inorder ï¼Œå…¶ä¸­ preorder æ˜¯äºŒå‰æ ‘çš„å…ˆåºéå†ï¼Œ inorder æ˜¯åŒä¸€æ£µæ ‘çš„ä¸­åºéå†ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

```java
//ç±»ä¼¼ä¸Šä¸€é¢˜çš„è§£æ³•
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int pre_length = preorder.length;
        int in_length = inorder.length;
        if(pre_length==0||in_length==0) return null;

        int root_val = preorder[0];
        TreeNode root = new TreeNode(root_val);
        int k = 0;
        for(int i = 0;i<in_length;i++){
            if(inorder[i]==root_val){
                k = i; break;
            }
        }
        //åˆ†å‰²
        int[] left_pre = Arrays.copyOfRange(preorder,1,k+1);
        int[] left_in = Arrays.copyOfRange(inorder,0,k);
        root.left = buildTree(left_pre,left_in);

        int[] right_pre = Arrays.copyOfRange(preorder,k+1,pre_length);
        int[] rigth_in = Arrays.copyOfRange(inorder,k+1,pre_length);
        root.right = buildTree(right_pre,rigth_in);
        return root;
    }
}
```

### 654.æœ€å¤§äºŒå‰æ ‘ğŸŸ¨

> ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º:
>
> åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚
> é€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚
> é€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚
> è¿”å› nums æ„å»ºçš„ æœ€å¤§äºŒå‰æ ‘ ã€‚

```java
//é‡‡ç”¨ä¸Šä¸€é¢˜çš„è§£æ³•å¯é€šè¿‡ï¼Œæ•ˆç‡è¾ƒä½
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length==0) return null;
        //æ‰¾åˆ°æœ€å¤§å€¼
        int max = 0;
        int max_index = 0;
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>max){
                max = nums[i];
                max_index = i;
            }
        }
        TreeNode root = new TreeNode(max);
        int[] left = Arrays.copyOfRange(nums,0,max_index);
        int[] right = Arrays.copyOfRange(nums,max_index+1,nums.length);
        root.left = constructMaximumBinaryTree(left);
        root.right = constructMaximumBinaryTree(right);
        return root;
    }
}
```

```java
//é¢˜è§£ï¼šç”¨æ—¶100%ï¼Œæƒ³æ³•ç±»ä¼¼ï¼Œæ–°æ·»åŠ åˆ¤æ–­ï¼šæ²¡æœ‰å…ƒç´ å’Œåªæœ‰ä¸€ä¸ªå…ƒç´ 
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return constructMaximumBinaryTree1(nums, 0, nums.length);
    }

    public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) {
        if (rightIndex - leftIndex < 1) {// æ²¡æœ‰å…ƒç´ äº†
            return null;
        }
        if (rightIndex - leftIndex == 1) {// åªæœ‰ä¸€ä¸ªå…ƒç´ 
            return new TreeNode(nums[leftIndex]);
        }
        int maxIndex = leftIndex;// æœ€å¤§å€¼æ‰€åœ¨ä½ç½®
        int maxVal = nums[maxIndex];// æœ€å¤§å€¼
        for (int i = leftIndex + 1; i < rightIndex; i++) {
            if (nums[i] > maxVal){
                maxVal = nums[i];
                maxIndex = i;
            }
        }
        TreeNode root = new TreeNode(maxVal);
        // æ ¹æ®maxIndexåˆ’åˆ†å·¦å³å­æ ‘
        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);
        root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);
        return root;
    }
}
```

### 617.åˆå¹¶äºŒå‰æ ‘ğŸŸ¨

> ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š root1 å’Œ root2 ã€‚
>
> æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œä¸ä¸º null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚
>
> è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚
>
> æ³¨æ„: åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null) return root2;
        if(root2==null) return root1;

        TreeNode root = new TreeNode(root1.val+root2.val);
        root.left = mergeTrees(root1.left,root2.left);
        root.right = mergeTrees(root1.right,root2.right);
        return root;
    }
}
```

### 700.äºŒå‰æ ‘ä¸­çš„æœç´¢ğŸŸ©

> ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°å€¼ valã€‚
>
> ä½ éœ€è¦åœ¨ BST ä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äº val çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› null ã€‚

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root ==null) return null;
        if(root.val == val) return root;
        if(root.val>val) return searchBST(root.left,val);
        if(root.val<val) return searchBST(root.right,val);
        return null;
    }
}
```

### 98.éªŒè¯äºŒå‰æœç´¢æ ‘ğŸŸ¥

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚
>
> æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
>
> èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
> èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
> æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

> <font color="red">æç¤ºï¼šé€’å½’æ—¶éœ€è¦è‡ªå·±ä¼ å…¥maxï¼Œminä½œä¸ºè¾¹ç•Œæ¡ä»¶ï¼Œä¸”é‡æ–°å†™ä¸ªé€’å½’å‡½æ•°ï¼Œæ— æ³•åœ¨åŸå‡½æ•°é€’å½’</font>
>
> é€’å½’å‚æ•°ï¼šå½“å‰èŠ‚ç‚¹ï¼Œminï¼Œmax

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
		if(root==null) return true;
        if(root.left!=null&&root.val<root.left.val) return false;
        if(root.right!=null&&root.val>root.right.val) return false;
        return (isValidBST(root.left)&&isValidBST(root.right));
    }
}
//é”™è¯¯ï¼Œè¾“å…¥ï¼š
//[2,2,2]
//è¾“å‡ºï¼š
//true
//é¢„æœŸç»“æœï¼š
//false
```

```java
public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean validate(TreeNode node, long min, long max) {
        if (node == null) {
            return true;
        }
        if (node.val <= min || node.val >= max) {
            return false;
        }
        return  validate(node.left, min, node.val) && validate(node.right, node.val, max);
    }
```

```java
class Solution {
    // è¿­ä»£ï¼šåˆ©ç”¨ä¸­åºéå†é¡ºåº
    public boolean isValidBST(TreeNode root) {
        if (root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;// å·¦
            }
            // ä¸­ï¼Œå¤„ç†
            TreeNode pop = stack.pop();
            if (pre != null && pop.val <= pre.val) {
                return false;
            }
            pre = pop;
            root = pop.right;// å³
        }
        return true;
    }
}
```

### 530.äºŒå‰æ ‘çš„æœ€å°ç»å¯¹å·®ğŸŸ¥

> ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› **æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼** ã€‚
>
> å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚

> <font color="red">ä½¿ç”¨ä¸Šä¸€é¢˜è§£æ³•ï¼Œé€’å½’ï¼Œæ¯æ¬¡ä¸å‰ä¸€ä¸ªæ¯”è¾ƒï¼Œæ¯”ä¸­åºéå†å¿«</font>

```java
class Solution {
    public int getMinimumDifference(TreeNode root) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode pre = null;
        int res = Integer.MAX_VALUE;
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root = root.left;
            }
            TreeNode pop = stack.pop();
            if(pre!=null&&res>pop.val-pre.val){
                res = pop.val-pre.val;
            }
            pre = pop;
            root=pop.right;
        }
        return res;
    }
}
```



```java
//ç›´æ¥ä¸­åºéå†ï¼šæ•ˆç‡æä½
class Solution {
    public int getMinimumDifference(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root,res);
        List<Integer> nums = new ArrayList<>();
        for(int i=0;i<res.size()-1;i++){
            nums.add(res.get(i+1)-res.get(i));
        }
        int min = Integer.MAX_VALUE;
        for(int i :nums){
            if(i<min) min = i;
        }
        return min;
    }

    public void inorder(TreeNode root,List<Integer> res){
        if(root==null) return;
        inorder(root.left,res);
        res.add(root.val);
        inorder(root.right,res);
    }
}
```

```java
//é€’å½’ï¼šé«˜æ•ˆç‡ï¼šåœ¨é€’å½’çš„åŒæ—¶å°±æ¯”ä»·å‰åºå…ƒç´ 
class Solution {
    TreeNode pre;// è®°å½•ä¸Šä¸€ä¸ªéå†çš„ç»“ç‚¹
    int result = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
       if(root==null)return 0;
       traversal(root);
       return result;
    }
    public void traversal(TreeNode root){
        if(root==null)return;
        //å·¦
        traversal(root.left);
        //ä¸­
        if(pre!=null){
            result = Math.min(result,root.val-pre.val);
        }
        pre = root;
        //å³
        traversal(root.right);
    }
}
```

### 501.äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

> ç»™ä½ ä¸€ä¸ªå«é‡å¤å€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ‰¾å‡ºå¹¶è¿”å› BST ä¸­çš„æ‰€æœ‰ ä¼—æ•°ï¼ˆå³ï¼Œå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
>
> å¦‚æœæ ‘ä¸­æœ‰ä¸æ­¢ä¸€ä¸ªä¼—æ•°ï¼Œå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚
>
> å‡å®š BST æ»¡è¶³å¦‚ä¸‹å®šä¹‰ï¼š
>
> ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å°äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼
> ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å¤§äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼
> å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘

```java
class Solution {
    ArrayList<Integer> resList;
    int maxCount;
    int count;
    TreeNode pre;

    public int[] findMode(TreeNode root) {
        resList = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;
        findMode1(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }

    public void findMode1(TreeNode root) {
        if (root == null) {
            return;
        }
        findMode1(root.left);

        int rootValue = root.val;
        // è®¡æ•°
        if (pre == null || rootValue != pre.val) {
            count = 1;
        } else {
            count++;
        }
        // æ›´æ–°ç»“æœä»¥åŠmaxCount
        if (count > maxCount) {
            resList.clear();
            resList.add(rootValue);
            maxCount = count;
        } else if (count == maxCount) {
            resList.add(rootValue);
        }
        pre = root;

        findMode1(root.right);
    }
}
```



### 235.äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆğŸŸ¨

> ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
>
> ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
>
> ä¾‹å¦‚ï¼Œç»™å®šå¦‚ä¸‹äºŒå‰æœç´¢æ ‘:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
> 
>
> ç¤ºä¾‹ 1:
>
> ```
> è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
> è¾“å‡º: 6 
> è§£é‡Š: èŠ‚ç‚¹ 2 å’ŒèŠ‚ç‚¹ 8 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯ 6ã€‚
> ```
>
> ç¤ºä¾‹ 2:
>
> ```
> è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
> è¾“å‡º: 2
> è§£é‡Š: èŠ‚ç‚¹ 2 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯ 2, å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
> ```



<font color="729900">æ ¹æ®æ€§è´¨ï¼Œå¾ˆç®€å•</font>





















```java
//é€’å½’æ³•
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```





### 236.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å‘Šç¥–å…ˆğŸŸ¥ğŸŸ¥

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
>
> ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€

```java
//å›æº¯è¿‡ç¨‹å°±æ˜¯è‡ªåº•å‘ä¸Š
//æ³¨æ„ï¼šé™¤äº†på’Œqæœ¬èº«å°±æ˜¯ç¥–å…ˆï¼Œå…¶ä»–æƒ…å†µpå’Œqä¸€å®šåœ¨æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å·¦å³å­æ ‘ä¸Š
//é€’å½’å¯»æ‰¾çš„å«ä¹‰
/*
	è¿”å›å€¼ï¼š TreeNode
	ä¸€å±‚è¿”å›æ¡ä»¶ï¼š æœ¬ç»“ç‚¹å°±æ˜¯è¦æ‰¾çš„pæˆ–qæˆ–æœ¬ç»“ç‚¹ä¸ºnull
	å®šä¹‰å·¦å³ï¼šé€’å½’è·å¾—ï¼šä¸”åªæœ‰ç¥–å…ˆæ‰èƒ½è¿”å›
	
*/
```





### 701.äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ

### 450.åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­èŠ‚ç‚¹

### 669.ä¿®å»ºäºŒå‰æœç´¢æ ‘

### 108.æœ‰åºæ•°ç»„è½¬åŒ–ä¸ºäºŒå‰æœç´¢æ ‘

### 538.äºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºç´¯åŠ æ ‘

### [å‰‘æŒ‡ Offer II 048. åºåˆ—åŒ–ä¸ååºåˆ—åŒ–äºŒå‰æ ‘](https://leetcode.cn/problems/h54YBf/)

> åºåˆ—åŒ–æ˜¯å°†ä¸€ä¸ªæ•°æ®ç»“æ„æˆ–è€…å¯¹è±¡è½¬æ¢ä¸ºè¿ç»­çš„æ¯”ç‰¹ä½çš„æ“ä½œï¼Œè¿›è€Œå¯ä»¥å°†è½¬æ¢åçš„æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ªæ–‡ä»¶æˆ–è€…å†…å­˜ä¸­ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥é€šè¿‡ç½‘ç»œä¼ è¾“åˆ°å¦ä¸€ä¸ªè®¡ç®—æœºç¯å¢ƒï¼Œé‡‡å–ç›¸åæ–¹å¼é‡æ„å¾—åˆ°åŸæ•°æ®ã€‚
>
> è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥å®ç°äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ã€‚è¿™é‡Œä¸é™å®šä½ çš„åºåˆ— / ååºåˆ—åŒ–ç®—æ³•æ‰§è¡Œé€»è¾‘ï¼Œåªéœ€è¦ä¿è¯ä¸€ä¸ªäºŒå‰æ ‘å¯ä»¥è¢«åºåˆ—åŒ–ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²å¹¶ä¸”å°†è¿™ä¸ªå­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºåŸå§‹çš„æ ‘ç»“æ„ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> <img src="../Resources/serdeser.jpg" alt="img" style="zoom:67%;" />
>
> ```
> è¾“å…¥ï¼šroot = [1,2,3,null,null,4,5]
> è¾“å‡ºï¼š[1,2,3,null,null,4,5]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šroot = []
> è¾“å‡ºï¼š[]
> ```
>
> **ç¤ºä¾‹ 3ï¼š**
>
> ```
> è¾“å…¥ï¼šroot = [1]
> è¾“å‡ºï¼š[1]
> ```
>
> **ç¤ºä¾‹ 4ï¼š**
>
> ```
> è¾“å…¥ï¼šroot = [1,2]
> è¾“å‡ºï¼š[1,2]
> ```
