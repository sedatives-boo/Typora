1️⃣：✅🔁🔴

2️⃣：🟩🟨🟥

3️⃣：🔰

https://github.com/sedatives-boo/Typora.git

## 数组

### 704.二分查找🟥🟨🟥

```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       下标
解释: 9 出现在 nums 中并且下标为 4，不在则返回-1
```

```java
class Solution{
            public int search(int[] nums,int target){
                int low,high,mid=-1;
                low = 0;
                high = nums.length-1;
                while(low<=high){
                    mid = (low+high)/2;
                    if(target==nums[mid])
                        return mid;
                    if(target>nums[mid])
                        low = mid +1;
                    else
                        high = mid -1;
                }
                return -1;
            }
        }
//时间效率100%，内存效率为42.2MB，6%
```

来自他人的解法：

```java
// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
```

<font color="red">二刷错误</font>:

```
left = nums.length; //没有-1
while(right<left)   //没有 =
```



### 34.在排序数组中查找元素的第一个和最后一个位置🟥

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

输入：nums = [], target = 0
输出：[-1,-1]
```

```java
//自己提交5次错的之后的结果，所有的用例都通过
class Solution {
    public int[] searchRange(int[] nums, int target) {
            int[] res = new int[]{-1,-1};
            int i = 0,j = 0;
            if(nums.length==0){
                return new int[]{-1,-1};
            }
            for(;nums[i]<target&&i<nums.length-1;i++);//找到第一个的下标
            if(i > nums.length) return new int[]{-1,-1};
            if(nums[i]==target){
                if(i == nums.length){
                    return new int[]{nums.length-1,nums.length-1};
                }
                for(j=i;j<nums.length&&nums[j]==target;j++);
                res = new int[]{i,j-1};
            }
            return res;
    }
}
//时间100%，内存44.8MB，8%
```

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
    int index = binarySearch(nums, target);
    if(index==-1){
        return new int[]{-1,-1};
    }
    int left = index;
    int right = index;
    //寻找左右边界
    while(left-1>=0&&nums[left-1]==nums[index]){
        left--;
    }
    while(right+1<nums.length&&nums[right+1]==nums[index]){
        right++;
    }
    return new int[] {left, right};
}

public int binarySearch(int[] nums,int target){
    int left = 0;
    int right = nums.length-1;
    int mid;
    while(left<=right){
        mid = (left+right)/2;
       if (nums[mid] == target) {
				return mid;
			} else if (nums[mid] < target) {
				left = mid + 1;
			} else {
				right = mid - 1; // 不变量：左闭右闭区间
			}
		}
		return -1; // 不存在
    }
}
```

### 27.移除元素🟥🟩

跳过暴力解法O(n<sup>2</sup>)，学习**双指针法**O(n)（快慢指针）：：快慢指针的思想！！！！

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并**原地**修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

```java
class Solution{
    int fastIndex = 0;
    int slowIndex;
    for(slowIndex = 0;fastIndex <nums.length;fastIndex++){//循环结束：快指针到末尾
        if(nums[fastIndex] !=val){// 快指针不等于val时，将快指针赋给慢指针
            nums[slowIndex] =nums[fastIndex];
            slowIndex++;
        }
        //当快指针等于val时，即可跳过
    }
    return slowIndex;
}
```

### 26.删除有序数组重复项🟥🟩

> 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
>
> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2,_]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

```java
//通过比对上一题做对
class Solution {
    public int removeDuplicates(int[] nums) {
        int fastIndex = 1;
        int slowIndex;
        for(slowIndex = 0;fastIndex<nums.length;fastIndex++){//快指针是遍历整个数组的，而慢指针保持于慢指针不同的前一个元素
            if(nums[fastIndex] != nums[fastIndex-1]){//在等的情况下，慢指针才能移动
                slowIndex++;
                nums[slowIndex] = nums[fastIndex];
                }
            }
        return slowIndex+1;
    }
}
//内存42.9MB，39%
```

### 283.移动0🟥🟥🟩

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> ```
> 输入: nums = [0]
> 输出: [0]
> ```

他人解法：采用快慢指针

```java
   //思路：设置一个index，表示非0数的个数，循环遍历数组，
    // 如果不是0，将非0值移动到第index位置,然后index + 1
    //遍历结束之后，index值表示为非0的个数，再次遍历，从index位置后的位置此时都应该为0
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[index] = nums[i];
                index++;
            }
        }

        for (int i = index; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
```

### 977.有序数组平方🟩

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
>
> 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
>
> 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]

采用双指针法

```java
class Solution{
    public int[] SortedSquare(int[] nums){
        if(nums.length==0) return nums;
        int i = 0, j = nums.length-1;
        int[] newArray = new int[nums.length];
        int k = j;
        while(i!=j){
            if(nums[i]*nums[i]>=nums[j]*nums[j]){
                newArray[k--] = nums[i]*nums[i];
                i++;
            }
            else{
                newArray[k--] = nums[j]*nums[j];
                j--;
            }
        }
        newArray[k] = nums[j]*nums[j];
        return newArray;
    }
}
```

注意设计测试所有用例

### 209.长度最小子数组🟥🟨🟩

学习**滑动窗口**

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
>
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
>
>  
>
> 示例 1：
>
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
>
> 示例 2：
> 输入：target = 4, nums = [1,4,4]
> 输出：1
>
> 示例 3：
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;//2147483647，其二进制为0111 1111 1111 1111 1111 1111 1111 1111
        //MIN_VALUE 的二进制为 1000 0000 0000 0000 0000 0000 0000 0000
        for(int right = 0;right<nums.length;right++){
            sum+=nums[right];
            while(sum>=target){
                result = Math.min(result, right - left  +1);
                sum -=nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0:result;
    }
}
```

### 904.水果成篮🟥🟥🟨🟩

> 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。
>
> 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
>
> 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
> 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
> 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
> 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
>
> 示例 1
>
> ```
> 输入：fruits = [1,2,1]
> 输出：3
> 解释：可以采摘全部 3 棵树。
> ```
>
> 示例 2：
>
> ```
> 输入：fruits = [0,1,2,2]
> 输出：3
> 解释：可以采摘 [1,2,2] 这三棵树。
> 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
> ```
>
> 示例 3：
>
> ```
> 输入：fruits = [1,2,3,2,2]
> 输出：4
> 解释：可以采摘 [2,3,2,2] 这四棵树。
> 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
> ```
>
> 示例 4：
>
> ```
> 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
> 输出：5
> 解释：可以采摘 [1,2,1,1,2] 这五棵树。
> ```

```java
//采用map，不用set，因为之前记录的个数不确定
 public int totalFruit(int[] fruits) {
     int l = 0;
     int r = 0;
     int res = 0;
     Map<Integer,Integer> map = new HashMap<>();
     for(;r<fruits.length;r++){
         map.put(fruits[r],map.getOrDefault(fruits[r],0)+1);
         while(map.size()>2){
             map.put(fruits[l],map.get(fruits[l])-1);
             if(map.get(fruits[l])==0){
                 map.remove(map.get(fruits[l]));
             }
             l++;
         }
         res =Math.max(res,r-l+1);
     }
     return res;
 }
```


### 76.最小覆盖字串🔴🔴

> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
>
> 注意：
>
> 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
> 如果 s 中存在这样的子串，我们保证它是唯一的答案。
>
>
> 示例 1：
>
> ```
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> ```
>
> 示例 2：
>
> ```
> 输入：s = "a", t = "a"
> 输出："a"
> ```
>
> 示例 3:
>
> ```
> 输入: s = "a", t = "aa"
> 输出: ""
> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，
> 因此没有符合条件的子字符串，返回空字符串。
> ```

```java
//两个map记录s和t中每个字母出现的数量，
class Solution {
    public String minWindow(String s, String t) {
        if(t.length()>s.length()){
            return "";
        }
        int[] map = new int[128];
        for(char c: t.toCharArray()){
            map[c]++;
        }
        int left = 0;
        int right = 0;
        int start = 0;//注意start 和 left的区别，left是遍历过程的，start才是符合条件的
        int min = Integer.MAX_VALUE;
        int count = t.length();//记录一共有多少个字母要找
        while(right<s.length()){
            char c = s.charAt(right);
            if(map[c]-->0){//t中有的
                count--;
            }
            right++;
            //找到之后
            while(count==0){
               if(min>right-left){//出现更小且符合的窗口，修改start位置
                   min = right-left;
                   start = left;
               }
                c = s.charAt(left++);//开始缩小窗口
                if(map[c]++>=0){
                    count++;
                }
            }
        }
        return min==Integer.MAX_VALUE ? "" : s.substring(start,start+min);
    }
}
```

```java
class Solution {
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            ori.put(c, ori.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        while (r < sLen) {
            ++r;
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
            }
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        Iterator iter = ori.entrySet().iterator(); 
        while (iter.hasNext()) { 
            Map.Entry entry = (Map.Entry) iter.next(); 
            Character key = (Character) entry.getKey(); 
            Integer val = (Integer) entry.getValue(); 
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        } 
        return true;
    }
}
```



### 59.螺旋矩阵Ⅱ🔴

> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
>
>  
>
> **示例 1：**
>
> ![img](../Resources/spiraln.jpg)
>
> ```
> 输入：n = 3
> 输出：[[1,2,3],[8,9,4],[7,6,5]]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：[[1]]
> ```

```java
//模拟过程
int[][] res = new int[n][n];
int loop = n/2;//循环次数
int startX = 0;//每次循环起始位置
int startY = 0;
int offset = 1;//偏移量
int count = 1;//填充数字
int mid = n/2;
while(loop>0){
    int i = startX;
    int j = startY;
    for(;j<startY +n-offset;++j){//从左到右
        res[startX][j]= count+;
    }
    for(;i<startX+n-offset;++i){
        res[i][j] = count++;
    }
    for(;j>startY;j--){
        res[i][j]= count++;
    }
    for(;i>startX;i--){
        res[i][j] = count++;
    }
    loop++;
    startX+=1;
    startY+=1;
    offset+=2;
}
if(n%2==1){
    res[mid][mid] = count;
}
return res;
```



### 54.螺旋矩阵🔴

> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```java

```



## 链表

链表定义

```java
public class ListNode{
    int val;//节点值
    ListNode next;
    //构造函数，无参，一参，二参
    public ListNode(){}
    public ListNode(int val){this.val = val;}
    public ListNode(int val){
        this.val = val;
        this.next = next;
    }
}
```

### 203.移除链表元素🟥

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 
>
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> 示例 2：
>
> 输入：head = [], val = 1
> 输出：[]
> 示例 3：
>
> 输入：head = [7,7,7,7], val = 7
> 输出：[]

改进：（注意原题有head指针）

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
		while(head !=null&&head.val ==val){//先把头结点为val的给排除
            head = head.next;
        }
        if(head == null){
            return head;
        }
        
        ListNode pre = head;
        ListNode cur = head.next;
        while(cur !=null){
            if(cur!=null&&cur.val == val){
                pre.next = cur.next;
            }
            else{
            pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }
}
```

### 707.设计链表🔁

> 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
>
> 在链表类中实现这些功能：
>
> get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
> addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
> addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
> addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
> deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。
>
>
> 示例：
>
> ```java
> MyLinkedList linkedList = new MyLinkedList();
> linkedList.addAtHead(1);
> linkedList.addAtTail(3);
> linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3(在第一个节点之前（3）添加元素)
> linkedList.get(1);            //返回2
> linkedList.deleteAtIndex(1);  //现在链表是1-> 3
> linkedList.get(1);            //返回3
> ```
>
> 
>

```java
class MyLinkedList {
		int size;
        ListNode head;
    public MyLinkedList() {
		size = 0;
        head = new ListNode(0);
    }
    
    public int get(int index) {
		if(index >= size||index <0) return -1;
        ListNode current = head;
        for(int i =0;i<=index;i++){
            current = current.next;
        }
        return current.val;   //错误：
    }
    
    public void addAtHead(int val) {
		 addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
		addAtIndex(size, val);
    }
    
    public void addAtIndex(int index, int val) {
        //先检查index
        if (index>size) return;
        if (index<0) index=0;
        size++;
        ListNode pred = head;
        for(int i =0;i<index;i++){
            pred = pred.next;
        }
        ListNode newAdd = new ListNode(val);
        newAdd.next = pred.next;
        pred.next = newAdd;

    }
    
    public void deleteAtIndex(int index) {
if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    } 
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

他人：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }
}
class MyLinkedList {
    //size存储链表元素的个数
    int size;
    //虚拟头结点
    ListNode head;

    //初始化链表
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    //获取第index个节点的数值
    public int get(int index) {
        //如果index非法，返回-1
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode currentNode = head;
        //包含一个虚拟头节点，所以查找第 index+1 个节点
        for (int i = 0; i <= index; i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }

    //在链表最前面插入一个节点
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    //在链表的最后插入一个节点
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果 index 大于链表的长度，则返回空
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        //找到要插入节点的前驱
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    }

    //删除第index个节点
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}

```

### 206.反转链表🟥

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
		if(head ==null) return head;
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = null;
        while(curr != null){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
            
        }
        return cur;//错误，，注意返回的是pre！
    }
}
```

学习递归

反向递归思想

```java
class Solution{
    ListNode reverseList(ListNode head){
        //递归，先写返回条件
        if(head == null) return null;
        if(head.next ==null) return head;
        
        ListNode last = reverstList(head.next);
        head.next.next = head;	//将该节点设为下一个节点的next，实现两个节点翻转
        head.next = null;//将当前结点设为尾
        return last;
    }
}
```

### 24.两两交换链表结点🟥

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy  = new ListNode(0);
        dummy.next = head;
        ListNode cur  = dummy;
        while(cur.next !=null && cur.next.next != null){
            ListNode tmp = cur.next;
            ListNode tmp1 = cur.next.next.next;
            cur.next = cur.next.next;
            cur.next.next = tmp;
            cur.next.next.next=tmp1;
            cur = cur.next.next;
        }
        return dummy.next;

    }
}
```

### 19.删除链表倒数第n个结点🟥🟥🟩

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点
>
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> 示例 2：
>
> 输入：head = [1], n = 1
> 输出：[]
> 示例 3：
>
> 输入：head = [1,2], n = 1
> 输出：[1]

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
		ListNode front = dummy;
        ListNode rear = dummy;
        for(int i = 0;i<n;i++){
            rear = rear.next;
        }
        while(rear.next!=null){
            front = front.next;
            rear = rear.next;
        }
        front.next = front.next.next;
        return dummy.next;
    }
}
//个人写第一次出错，原因是直接返回head，但应该使用dummy！
```

### 2.两数相加🟥🟨🟨

> 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```
>
> 示例 2：
>
> ```
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
> ```
>
> 示例 3：
>
> ```
> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
> 输出：[8,9,9,9,0,0,0,1]
> ```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        int carry = 0;
        while(l1!=null||l2!=null){
            int x = l1==null? 0 :l1.val;
            int y = l2==null? 0 :l2.val;
            
            int sum = x+y+carry;
            carry = sum/10;
            sum = sum %10;
            cur.next = new ListNode(sum);
            cur = cur.next;
            if(l1!=null){
                l1 = l1.next;
            }if(l2!=null){
                l2 = l2.next;
            }
        }
        if(carry==1){
            cur.next = new ListNode(1);
        }
        return dummy.next;
    }
}
```

### 面试题 02.07. 链表相交✅🔁

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 
>
> 题目数据 **保证** 整个链式结构中不存在环。
>
> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。

```java
 class Solution{
    public ListNode getIntersectionNode(ListNode headA, ListNode headB){
        //方法：求出链表长度，对其末尾
        //特殊情况检查
        if(headA==null||headB==null) return null;
        //一般情况
        ListNode curA = headA;
        ListNode curB = headB;
        int lengthA = 0; int lengthB = 0;
        //求长度
       while(curA !=null){
           lengthA++;
           curA = curA.next;
       }
        while(curB !=null){
           lengthB++;
           curB = curB.next;
       }
        //移动指针
        if(lengthA > lengthB){
            int temp = lengthA - lengthB;
            for(int i = 0;i<temp;i++){
                curA=curA.next;
            }
        }
        if(lengthA < lengthB){
            int temp = lengthB - lengthA;
            for(int i = 0;i<temp;i++){
                curB=curB.next;
            }
        }
       //开始遍历比较
        for(int i = 0;i<Math.min(lengthA,lengthB);i++){
            if(curA==curB){
                return curA;
            }
            else{
                curA=curA.next;
                curB=curB.next;
            }
        }
        return null;
    }
}
```

### 142.环形链表Ⅱ🚸

> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
>
> 不允许修改 链表
>





## 哈希表

### 242.有效的字母异位词🟩

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
>
> 示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
>
> 示例 2: 输入: s = "rat", t = "car" 输出: false
>
> **说明:** 你可以假设字符串只包含小写字母

```java
//26个字母的索引值可以通过 ch - 'a'获得
class Solution{
    public boolean isAnagram(String s, String t){
        int[] record = new int[26];
        for(char c : s.toCharArray()){
            record[c-'a']++;   
        }
        
        for(char c : t.toCharArray()){
            record[c-'a']--;
        }
        
        for(int i : record){
            if(i!=0) return false;
        }
        return true;
        
    }
}
```

区别c和java的数组：

- 创建时指定长度，java的数组自动填充0
- 取String的字符需要调用 toCharArray()

###  349. 两个数组的交集🟩

> 给定两个数组 nums1 和 nums2 ，返回它们的交集 。输出结果中的每个元素一定是唯一的。我们可以 不考虑输出结果的顺序 
>
> 示例 1：
>
> ```
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> ```
>
> 示例 2：
>
> ```
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
> 解释：[4,9] 也是可通过的
> ```

```java
class Solution{
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new Hashset<>();
        for(int i : nums1){
            set.add(i);
        }
        //新建一个数组        
        Set<Integer> res = new Hashset<>();
        for(int i :nums2){
            if(set.contains(i))
                res.add(i);
        }  
    }      
    }
```

解法正确，这里需学习将hashset转化为数组的过程

```java
//HashSet<Integer> res;
int[] output = new int[res.size()];
int index = 0;
for(int i : res){
    output[index++]=i;
}
return output;
```

二刷采用了效率更高的方式：

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        boolean[] container = new boolean[1001];
        List<Integer> list = new ArrayList<>();
        for(int i :nums1){
            container[i]=true;
        }
        for(int j :nums2){
            if(container[j]){
                list.add(j);
                container[j]=false;
            }
        }
        int[] res = new int[list.size()];
        for(int i= 0;i<list.size();i++){
            res[i] =  list.get(i);
        }
        return res;
    }
}
```



### 202.快乐数🟥🟨

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」 定义为：
>
> 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
> 如果这个过程 结果为 1，那么这个数就是快乐数。
> 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
>
> 示例 1：
>
> ```
> 输入：n = 19
> 输出：true
> 解释：
> 1^2 + 9^2 = 82
> 8^2 + 2^2 = 68
> ^62 + 8^2 = 100
> 1^2 + 0^2 + 0^2 = 1
> ```
>
> 示例 2：
>
> ```
> 输入：n = 2
> 输出：false
> ```
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> .
>
> 

思路：储存每一次的值，当发现已存在的就返回false。发现1就返回true

```java
class Solution {
        private int getSum(int n) {
            int sum = 0;
            while (n!=0) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            return sum;
        }

        public boolean isHappy(int n) {
            Set<Integer> set = new HashSet<>();
            while (n!=1&&!set.contains(n)) {
                set.add(n);
                n = getSum(n);
            }
            return n==1;
        }
    }
```

做的时候没有想到怎么求不定长数字的和。

### 1.两数之和🔰

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
> 示例 2：
>
> 输入：nums = [3,2,4], target = 6
> 输出：[1,2]
> 示例 3：
>
> 输入：nums = [3,3], target = 6
> 输出：[0,1]

要求使用set做

注意有索引值则需要用map而不是set

```java
class Solution {
        public int[] twoSum(int[] nums, int target) {
            HashMap<Integer,Integer> map = new HashMap<>();
            //添加的过程
            for(int i =0;i<nums.length;i++){
                map.put(nums[i],i);
            }
            int res  = -1;
            for(int i = 0;i<nums.length;i++){
                int t = target - nums[i];
                if(map.containsKey(t)&&map.get(t)!=i){
                    return new int[]{i,map.get(t)};
                }
            }
            throw new IllegalArgumentException();
        }
    }
```

做的时候还是有一些没想到，需要复习

### 454.四数相加Ⅱ🟥

> 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
>
> - 0 <= i, j, k, l < n
> - nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
>
>
> 示例 1：
>
> ```
> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 输出：2
> 解释：
> 两个元组如下：
> 
> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
> ```
>
> 示例 2：
>
> ```
> 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
> 输出：1
> ```

```java
//解法：用两个双重for循环，第一个双重for循环将nums1，nums2元素相加所有会出现的值，出现几次记录在map中
//   第二个双重for循环检查0-(nums3+nums4)的值是否出现在map中，返回这个值。
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        int temp = 0;
        for(int i : nums1){
            for(int j : nums2){
                temp = i+j;
                //注意采用map计数的方法：如果存在，这value+1，否则创建新的value=1
                if(map.containsKey(temp)){
                    map.put(temp,map.get(temp)+1);
                }else{
                    map.put(temp,1);
                }
            }
        }
        //统计剩余两数和
        for(int k :nums3){
            for(int l :nums4){
                temp = 0 - k - l;
                if(map.containsKey(temp)){
                    res = res +map.get(temp);
                }
            }
        }
        return res;
    }
}
```

### 383.赎金信🟩

> 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
>
> 如果可以，返回 true ；否则返回 false 。
>
> magazine 中的每个字符只能在 ransomNote 中使用一次。
>
> 示例 1：
>
> ```
> 输入：ransomNote = "a", magazine = "b"
> 输出：false
> ```
>
> 示例 2：
>
> ```
> 输入：ransomNote = "aa", magazine = "ab"
> 输出：false
> ```
>
> 示例 3：
>
> ```
> 输入：ransomNote = "aa", magazine = "aab"
> 输出：true
> ```

```java
//将两个字符串转化为字符数组并用hashmap记录magzine。遍历ransomnote每出现一个字符就减去相应value，直到出现value=-1，否则返回正确
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
		char[] ransomArray = ransomNote.toCharArray();
        char[] magazineArray = magazine.toCharArray();
        
        Map<Character,Integer> map = new HashMap<>();
        for(char c:magazineArray){
            if(map.containsKey(c)){
                map.put(c,map.get(c)+1);
            }else{
                map.put(c,1);
            }
        }
        //开始检查ransonNote
        for(char c:ransomArray){
            if(map.containsKey(c)){
                map.put(c,map.get(c)-1);
                if(map.get(c)<0) return false;
            }
            else{
                return false;
            }
        }
        return true;
    }
}
```

可用242题，记录26个字母的数组就行

### 15.三数之和🔁🔴

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>
> 示例 1：
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = []
> 输出：[]
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [0]
> 输出：[]
> ```
>

```java
//直接看解答：
//  hash方法不太好，需要去重，，采用双指针：
class Solution{
    public List<List<Integer>> threeSum(int[] nums){
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);//先排序数组
        
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>0) return result; //当前值为正，后面全为正数了，返回结果
            if(i>0&&nums[i]==nums[i-1]) continue;//跳过相等的数，去重
            
            int left = i+1;
            int right = nums.length-1;
            while(right>left){
                int sum = nums[i]+nums[left]+nums[right];
                if(sum>0){
                    right--;
                }else if (sum<0){
                    letf++;
                }else{//当sum ==0 时
                    result.add(Arrays.asList(nums[i],nums[right],nums[left]));//注意List的生成
                    //去重逻辑
                    while(right>left && nums[right]==nums[right-1]) right--;
                    while(right>left && nums[left]==nums[left+1]) left++;
                    //指针收缩
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
}
```

### 18.四数之和

> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> 0 <= a, b, c, d < n
> a、b、c 和 d 互不相同
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 你可以按 任意顺序 返回答案 。
>
> 示例 1：
>
> ```
> 输入：nums = [1,0,-1,0,-2,2], target = 0
> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [2,2,2,2,2], target = 8
> 输出：[[2,2,2,2]]
> ```




## 字符串

### 344.反转字符串🟩

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>
> 示例 1：
>
> ```
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]
> ```
>
> 示例 2：
>
> ```
> 输入：s = ["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]
> ```

```java
class Solution {
    public void reverseString(char[] s) {
		//反转数组
        int temp =s[0];
        for(int i=0;i<s.length/2;i++){
            temp = s[i];
            s[i] = s[s.length-1-i];
            s[s.length-1-i] = s[i];
        }
    }
}
```

### 剑指offer.05.替换空格🟩🟩

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> ```
> 输入：s = "We are happy."
> 输出："We%20are%20happy."
> ```

```java
//题解1：直接库函数
s.replace(" ","%20");
```

```java
//StringBuilder
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i =0;i<s.length;i++){
            char c = s.charAt(i);
            if(c==' ') sb.append("%20");
            else sb.append(c);
        }
        return sb.toString();
    }
}
```

### 151.反转字符串的单词✅🔁🔁

> 给你一个字符串 s ，颠倒字符串中 单词 的顺序。
>
> 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
>
> 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
>
> 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
>
> 示例 1：
>
> ```
> 输入：s = "the sky is blue"
> 输出："blue is sky the"
> ```
>
> 示例 2：
>
> ```
> 输入：s = "  hello world  "
> 输出："world hello"
> 解释：颠倒后的字符串中不能存在前导空格和尾随空格。
> ```
>
> 示例 3：
>
> ```
> 输入：s = "a good   example"
> 输出："example good a"
> 解释：如果两个单词间有多余的空格，颠倒后的字符串需要将单词间的空格减少到仅有一个
> ```

```java
//方法：split库函数，定义新的字符串，把单词倒叙相加
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
            String[] s_arr = s.split(" ");
            for(int i =s_arr.length-1;i>=0;i--){
                if(s_arr[i].equals("")) continue;
                sb.append(s_arr[i]);
                sb.append(" ");
            }
            return sb.substring(0,sb.length()-1);
    }
}
//自己调试很久通过了！！！！
//但是不知道 s.split(" ") 分割空格和s_arr[i].equals("")检查空格不一样！！
```

```java
//更好的方法，不用辅助空间：解答
//先反转整个字符串，再将单词次序反转
class Solution {
    /**
     * 思路：
     *	①反转字符串  "the sky is blue " => " eulb si yks eht"
     *	②遍历 " eulb si yks eht"，每次先对某个单词进行反转再移位
     *	   这里以第一个单词进行为演示：" eulb si yks eht" ==反转=> " blue si yks eht" ==移位=> "blue si yks eht"
     */
    public String reverseWords(String s) {
        //步骤1：字符串整体反转（此时其中的单词也都反转了）
        char[] initialArr = s.toCharArray();
        reverse(initialArr, 0, s.length() - 1);
        int k = 0;
        for (int i = 0; i < initialArr.length; i++) {
            if (initialArr[i] == ' ') {
                continue;
            }
            int tempCur = i;
            while (i < initialArr.length && initialArr[i] != ' ') {
                i++;
            }
            for (int j = tempCur; j < i; j++) {
                if (j == tempCur) { //步骤二：二次反转
                    reverse(initialArr, tempCur, i - 1);//对指定范围字符串进行反转，不反转从后往前遍历一个个填充有问题
                }
                //步骤三：移动操作
                initialArr[k++] = initialArr[j];
                if (j == i - 1) { //遍历结束
                    //避免越界情况，例如=> "asdasd df f"，不加判断最后就会数组越界
                    if (k < initialArr.length) {
                        initialArr[k++] = ' ';
                    }
                }
            }
        }
        if (k == 0) {
            return "";
        } else {
            //参数三：以防出现如"asdasd df f"=>"f df asdasd"正好凑满不需要省略空格情况
            return new String(initialArr, 0, (k == initialArr.length) && (initialArr[k - 1] != ' ') ? k : k - 1);
        }
    }
    public void reverse(char[] chars, int begin, int end) {
        for (int i = begin, j = end; i < j; i++, j--) {
            chars[i] ^= chars[j];
            chars[j] ^= chars[i];
            chars[i] ^= chars[j];
        }
    }
}
```

### 剑指offer.58.左旋转字符串✅🔁🔁

> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
>
> 示例 1：
>
> ```
> 输入: s = "abcdefg", k = 2
> 输出: "cdefgab"
> ```
>
> 示例 2：
>
> ```
> 输入: s = "lrloseumgh", k = 6
> 输出: "umghlrlose"
> ```

```java
//个人想法：保留前n。后面移位，再插入前n
class Solution {
    public String reverseLeftWords(String s, int n) {
        char[] c_arr = s.toCharArray();
            char[] temp = new char[n];
            for(int i = 0;i<n;i++){
                temp[i] = c_arr[i];
            }
            //后面移位
            for(int i = n;i<c_arr.length;i++){
                c_arr[i-n] = c_arr[i];
            }
            //再插入
            for(int i =c_arr.length-n;i<c_arr.length;i++){
                c_arr[i] = temp[i- c_arr.length+n];
            }
            return new String(c_arr);//注意数组转字符串的方法
    }
}
//内存效率不高
```

```java
//反转区间为前n的子串
//反转区间为n到末尾的子串
//反转整个字符串
class Solution {
    public String reverseLeftWords(String s, int n) {
        int len=s.length();
        StringBuilder sb=new StringBuilder(s);
        reverseString(sb,0,n-1);
        reverseString(sb,n,len-1);
        return sb.reverse().toString();
    }
     public void reverseString(StringBuilder sb, int start, int end) {
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
            }
        }
}
//时间效率不高
```

### 28.实现strStr()✅🔁🔴

> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
>
> 说明：
>
> 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
> 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
>
> 出处。
>
> 示例 1：
>
> ```
> 输入：haystack = "hello", needle = "ll"
> 输出：2
> ```
>
> 示例 2：
>
> ```
> 输入：haystack = "aaaaa", needle = "bba"
> 输出：-1
> ```
>
> 示例 3：
>
> ```
> 输入：haystack = "", needle = ""
> 输出：0
> ```

```java
//KMP算法已忘
class Solution {
    public void getNext(int[] next, String s){
        //求解next
        //1 初始化j和next[j]
        //2 大循环
        //    如果 前后缀相等，j前进
        //    如果不相等，且j>=0,j回退到next[j]的位置
        // 	  然后将j给next i
        int j = -1;
        int next[0] = j;
        for(int i = 1; i<s.length;i++){
            while(j>=0 && s.charAt(i)!=s.charAt(j+1){ j = next[j];}
            if(s.charAt(i)==s.charAt[j+1]) j++;
            next[i]=j;
        }
        
    }
   public int strStr(String haystack, String needle) {
      //模式匹配过程
       //特殊情况
       //创建next，求next过程
       //for
       		//和getNext 一样
       		//返回
       if(haystack.length()==0) return 0;
       int[] next = new int[needle.length()];
       getNext(next, needle);
       int j = -1;
       for(int i =0 ; i<haystack.length();i++){
           while(j>=0 && haystack.charAt(i)==needle.charAt(j+1) j = next[j];
           if(haystack.charAt(i)==needle.charAt(j+1)) j++;
           if(j == needle.length()-1)  return (i-needle.length()+1);
       }
    
   }
}
```

```java
//KMP算法--next数组
void getNext(){
	int j = -1;  //j是前缀长度
    next[0] = j;
    for(int i = 1;i<s.size();i++){
        while(j>=0 && s[i]!= s[j+1])	j = next[j];	//前后缀不同，向前回退
        if(s[i]==s[j+1]) j++;  //找相同的前后缀
        next[i] = j;    //前缀长度赋给next
    }
}
```

```java
//滑动窗口法
public int strStr(String haystack, String needle){
    //特殊检查
    int m = needle.length();
    if(m==0) return 0;
    int n = haystack.length();
    if(n<m) return -1;
    //
    int i =0;
    int j =0;
    while(i<n-m+1){
        while(i<n&&haystack.charAt(i)!=needle.charAt(j))  i++;
        if(i==n) return -1;
        //遍历后续字符
        i++;
        j++;
        while(i<n && j<m &&haystack.charAt(i)==needle.charAt(j)){
            i++;j++;
        }
        if(j == m) return i - j;//已找到
        else{
            i -= j - 1;
            j =0;
        }
    }
    return -1;
}
```

### 459.重复的子字符串🔁🔁🔴

> 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
>
>  示例 1:
>
> ```
>输入: s = "abab"
> 输出: true
> 解释: 可由子串 "ab" 重复两次构成。
> ```
> 
> 示例 2:
>
> ```
>输入: s = "aba"
> 输出: false
> ```
> 
> 示例 3:
>
> ```
>输入: s = "abcabcabcabc"
> 输出: true
> 解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
> ```

```java
public boolean repeatedSubstringPattern(String s){
    if(s.equals("")) return false;
    int len = s.length();
    s = " "+s;// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了
    char[] chars = s.toCharArray();
    int[] next = new int[len +1];
    for(int i = 2, j = 0;i<=len;i++){ // 构造 next 数组过程，j从0开始(空格)，i从2开始
        while(j >0 && chars[i] != chars[j+1]) j = next[j]; // 匹配不成功，j回到前一位置 next 数组所对应的值
        if(chars[i] == chars[j+1]) j++;    // 匹配成功，j往后移
        next[i] = j;
    }
     // 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值
    if(next[len]>0 && len%(len -next[len]) == 0){
        return true;
    }
    return false;
}
```

### 567.字符串的排列🔴

> 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
>
> 换句话说，s1 的排列之一是 s2 的 子串 。
>
>  
>
> 示例 1：
>
> 输入：s1 = "ab" s2 = "eidbaooo"
> 输出：true
> 解释：s2 包含 s1 的排列之一 ("ba").
> 示例 2：
>
> 输入：s1= "ab" s2 = "eidboaoo"
> 输出：false

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int n = s1.length(), m = s2.length();
        if (n > m) {
            return false;
        }
        int[] cnt = new int[26];
        for (int i = 0; i < n; ++i) {
            --cnt[s1.charAt(i) - 'a'];//先把s1 的记录（负数）
        }
        int left = 0;
        for (int right = 0; right < m; ++right) {
            int x = s2.charAt(right) - 'a';
            ++cnt[x];
            while (cnt[x] > 0) {//当字符多出来了，就滑动左指针
                --cnt[s2.charAt(left) - 'a'];
                ++left;
            }
            if (right - left + 1 == n) {//当长度符合时就是说明找到了,不然前面的while循环无法通过
                return true;
            }
        }
        return false;
    }
}
```

### 541

### 607

### 601

### 596

### 586

### 584









## 双指针法

本小节均为已完成的题目，现要求只用双指针法求解

### 27.移除元素✅✅

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并**原地**修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

```java
class Solution {
        public int removeElement(int[] nums, int val) {
            //这里是在原数组上修改
            int slow = 0;
            for(int fast = 0;fast<nums.length;fast++){
                if(nums[fast] == val) continue;
                else if(fast == slow){
                    slow++;
                }else{
                    nums[slow]=nums[fast];
                    slow++;
                }
            }
            return slow;
        }
    }
```

### 剑指offer.05.替换空格✅

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> ```
> 输入：s = "We are happy."
> 输出："We%20are%20happy."
> ```

原解法：库函数；StringBuilder。

```java
class Solution {
    public String replaceSpace(String s) {
        //双指针法
        if(s==null||s.length()==0) return s;
        StringBuilder sb = new StringBuilder();
        //检查空格
        for(int i =0 ;i<s.length();i++){
            if(s.charAt(i)==' ')
                sb.append("  ");
        }
        if(sb.length()==0) return s;
        //正经开始
        //设立左右指针
        int left = s.length()-1;
        s += sb.toString();
        int right = s.length()-1;
        char[] cs = s.toCharArray();
        while(left>=0){
            if(cs[left]==' '){
                cs[right--]='0';
                cs[right--]='2';
                cs[right]='%';
            }else{
                cs[right]=cs[left];
            }
            left--;
            right--;
        }
        return new String(cs);
    }
}
```

### 206.反转链表✅

常规做法省略，递归法

```java
public ListNode reverseList(ListNode head) {
    return reverse(null,head);
}
//类似双指针，开始相当于把pre=null, cur=head 传入
private ListNode reverse(ListNode prev, ListNode cur) {
    if(cur==null) return pre;//此时cur到原链表尾，pre就是新链表头			//递归出口
    ListNode temp = null;
    temp = cur.next;//保存下一个结点
    cur.next = prev;//反转
    
    return reverse(cur, temp);//进行下一次递归					//循环
}
```

### 19.删除链表倒数第n个结点✅

解法：

1. 先定义dummy

2. 将rear后移n位

3. 同时移动rear和front，当rear到表尾时，front就到了倒数n个节点

   ```java
   public ListNode removeNthFromEnd(ListNode head, int n) {
       ListNode dummy = new ListNode(0);
       dummy.next = head;
       ListNode front = dummy;
       ListNode rear = dummy;
       for(int i = 0;i<n;i++){
           rear =rear.next;
       }
       while(rear.next!=null){
           front = front.next;
           rear = rear.next;
       }
       front.next = front.next.next;
       return dummy.next;
   }
   ```

### 15.三数之和✅🔁

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中**不可以包含重复**的三元组。
>
> 示例 1：
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = []
> 输出：[]
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [0]
> 输出：[]
> ```

题解：将数组排序

```java
/**
*先将数组排序
*返回条件：当前值大于0
*去重：消除连续又相等的值
*定义左，右指针
*
*/
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
       Arrays.sort(nums);
       List<List<Integer>> result = new ArrayList<>();
        
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>0) return result;
            if(i>0 && nums[i]==nums[i-1]) continue;
            
            int left = i+1;
            int right = nums.length-1;
            while(right>left){
                int sum = nums[i]+nums[left]+nums[right];
                if(sum>0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    //添加元素
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    //然后去重
                    while(right>left && nums[left]==nums[left+1]) left++;
                    while(right>left && nums[right]==nums[right-1]) right--;
                    left++;
                    right--;
                }
            }
        }

    }
}
```



## 栈与队列

### 155·剑指 Offer 30. 包含min函数的栈🔁

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

```java
 private Node head;
    public MinStack() {
    }
    public void push(int x) {
        if (head == null)
            head = new Node(x, x, null);
        else
            head = new Node(x, Math.min(head.min, x), head);
    }

    public void pop() {
        head = head.next;
    }

    public int top() {
        return head.val;
    }

    public int min() {
        return head.min;
    }

    private class Node {
        int val;
        int min;
        Node next;

        public Node(int val, int min, Node next) {
            this.val = val;
            this.min = min;
            this.next = next;
        }
    }
```



### 232.用栈实现队列✅✅✅

> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：
>
> 实现 MyQueue 类：
>
> void push(int x) 将元素 x 推到队列的末尾
> int pop() 从队列的开头移除并返回元素
> int peek() 返回队列开头的元素
> boolean empty() 如果队列为空，返回 true ；否则，返回 false

```java
class MyQueue {
    
    Stack<Integer> stackIn;
    Stack<Integer> stackOit;
    public MyQueue() {
		stacjIn = new Stack<>();
        stackOut = new Stack<>();
    }
    
    public void push(int x) {
		stackIn.push(x);
    }
    
    public int pop() {
        //定义一个方法将In全都进入out栈
		dumpstackIn();
        return stackOut.pop();
    }
    
    public int peek() {
		dumpstackIn();
        return stackOut.peek();
    }
    
    public boolean empty() {
		return stackIn.isEmpth()&&stackOut.isEmpty();
    }
    //定义新方法
    private void dumpstackIn(){
        if(!stackOut.isEmpty()) return;//注意out要空的才能压入栈，否则输出pop,peek有问题
        while(!stackIn.isEmpty()){
            stackOut.push(stackIn.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```



### 225.用队列实现栈🔁✅

> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
>
> 实现 MyStack 类：
>
> void push(int x) 将元素 x 压入栈顶。
> int pop() 移除并返回栈顶元素。
> int top() 返回栈顶元素。
> boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

 常用的LinkedList集合，实现了Queue接口

> 1、`boolean offer(E e)`和`boolean add(E e)`的区别
> add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！
>
> 2、`E peek()`和`E element()`的区别
> peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。
>
> 3、`E poll()`和`E remove()`的区别
> poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。

本题保证了栈不会为空，因此没有什么区别

```java
class MyStack {
	Queue<Integer> queue1;
    Queue<Integer> queue2;
    public MyStack() {
		queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int x) {
		queue2.offer(x);// 先放在辅助队列中
        while(!queue1.isEmpty()){//queue1 非空时
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp ;
        temp = queue1;
        queue1 = queue2;
        queue2 = temp;// 最后交换queue1和queue2，将元素都放到queue1中
    }
    
    public int pop() {
		return queue1.poll();
    }
    
    public int top() {
		return queue1.peek();
    }
    
    public boolean empty() {
		return queue1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```



### 20.有效的括号🟩

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
>
>
> 示例 1：
>
> ```
> 输入：s = "()"
> 输出：true
> ```
>
> 示例 2：
>
> ```
> 输入：s = "()[]{}"
> 输出：true
> ```
>
> 示例 3：
>
> ```
> 输入：s = "(]"
> 输出：false
> ```
>
> 示例 4：
>
> ```
> 输入：s = "([)]"
> 输出：false
> ```
>
> 示例 5：
>
> ```
> 输入：s = "{[]}"
> 输出：true
> ```

```java
//左括号入栈，右括号出栈
class Solution {
    public boolean isValid(String s){
            char[] arr = s.toCharArray();
            Stack<Character> stack = new Stack<>();
            for(char c : arr){
                if(c=='('||c=='{'||c=='[') stack.push(c);
                else{
                    if(stack.isEmpty()) return false;
                    char temp = stack.pop();
                    if(temp=='('&&c==')') ;
                    else if(temp=='{'&&c=='}') ;
                    else if(temp=='['&&c==']') ;
                    else return false;
                }
            }
            if(!stack.isEmpty()) return false;
            return true;
        }
}
```

### 1047.删除字符串中的所有相邻重复项✅🔁

> 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
>
> 在 S 上反复执行重复项删除操作，直到无法继续删除。
>
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
>
>  
>
> 示例：
>
> ```
> 输入："abbaca"
> 输出："ca"
> ```
>
> 解释：
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

```java
//思路：入栈，每次和栈顶元素比较
class Solution{
        public String removeDuplicates(String s){
            if(s.length()==0) return s;
            Stack<Character> stack = new Stack<>();
            char[] char_arr = s.toCharArray();
            int length = 0;
            //检查当前元素和栈顶元素，如果不等，则压入栈，相等则取出。
            for(char c :char_arr){
                if(!stack.isEmpty()&&stack.peek()==c){
                    stack.pop();
                    length--;
                }else{
                    stack.push(c);
                    length++;
                }
            }
            //将整个栈打印出来，注意要逆序
           char[] output = new char[length];
            for(int i = 0;i<length;i++){
                output[i] = stack.pop();
            }
            char temp = output[0];
            for(int i = 0;i<output.length/2;i++){
                temp = output[i];
                output[i] = output[output.length-1-i];
                output[output.length-1-i] = temp;
            }
            return new String(output);
        }
    }
//错误
```

```java
//解答：
class Solution {
    public String removeDuplicates(String s) {
        // 将 res 当做栈
        StringBuffer res = new StringBuffer();
        // top为 res 的长度
        int top = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            // 当 top > 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--
            if (top >= 0 && res.charAt(top) == c) {
                res.deleteCharAt(top);
                top--;
            // 否则，将该字符 入栈，同时top++
            } else {
                res.append(c);
                top++;
            }
        }
        return res.toString();
    }
}
```



### 150.逆波兰表达式求值✅🔁

也称（后缀表达式）

> 根据 逆波兰表示法，求表达式的值。
>
> 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
>
> 注意 两个整数之间的除法只保留整数部分。
>
> 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
>
> 示例 1：
>
> ```
> 输入：tokens = ["2","1","+","3","*"]
> 输出：9
> 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
> ```
>
> 示例 2：
>
> ```
> 输入：tokens = ["4","13","5","/","+"]
> 输出：6
> 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
> ```
>
> 示例 3：
>
> ```
> 输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
> 输出：22
> 解释：该算式转化为常见的中缀算术表达式为：
>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
> = ((10 * (6 / (12 * -11))) + 17) + 5
> = ((10 * (6 / -132)) + 17) + 5
> = ((10 * 0) + 17) + 5
> = (0 + 17) + 5
> = 17 + 5
> = 22
> ```

**注意：java不同于c++。不要进行String 转 int，而是String做计算会自动转成int**

注意泛型是int ！！！ 不是String

不使用  == 而用 equals

不要使用Stack类，而使用Deque类构造对象，**Stack类已经过时**

普通队列(一端进另一端出):
`Queue<> queue = new LinkedList<>()或Deque<> deque = new LinkedList<>()`
双端队列(两端都可进出)
`Deque<> deque = new LinkedList<>()`
堆栈
`Deque<> deque = new LinkedList<>()`

| **饰符和返回值** | **方法名**                        | **描述**                                     |
| ---------------- | --------------------------------- | -------------------------------------------- |
| **添加功能**     |                                   |                                              |
| void             | **push**(E)                       | 向队列头部插入一个元素,失败时抛出异常        |
| void             | **addFirst**(E)                   | 向队列头部插入一个元素,失败时抛出异常        |
| void             | **addLast**(E)                    | 向队列尾部插入一个元素,失败时抛出异常        |
| boolean          | **offerFirst**(E)                 | 向队列头部加入一个元素,失败时返回false       |
| boolean          | **offerLast**(E)                  | 向队列尾部加入一个元素,失败时返回false       |
| **获取功能**     |                                   |                                              |
| E                | **getFirst**()                    | 获取队列头部元素,队列为空时抛出异常          |
| E                | **getLast**()                     | 获取队列尾部元素,队列为空时抛出异常          |
| E                | **peekFirst**()                   | 获取队列头部元素,队列为空时返回null          |
| E                | **peekLast**()                    | 获取队列尾部元素,队列为空时返回null          |
| **删除功能**     |                                   |                                              |
| boolean          | **removeFirstOccurrence**(Object) | 删除第一次出现的指定元素,不存在时返回false   |
| boolean          | **removeLastOccurrence**(Object)  | 删除最后一次出现的指定元素,不存在时返回false |
| **弹出功能**     |                                   |                                              |
| E                | **pop**()                         | 弹出队列头部元素,队列为空时抛出异常          |
| E                | **removeFirst**()                 | 弹出队列头部元素,队列为空时抛出异常          |
| E                | **removeLast**()                  | 弹出队列尾部元素,队列为空时抛出异常          |
| E                | **pollFirst**()                   | 弹出队列头部元素,队列为空时返回null          |
| E                | **pollLast**()                    | 弹出队列尾部元素,队列为空时返回null          |
| **迭代器**       |                                   |                                              |
| Iterator<E>      | **descendingIterator**()          | 返回队列反向迭代器                           |

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> deque = new LinkedList<>();
        int length=tokens.length;
        int sum = 0;
        for(int i = 0;i<length;++i){
            if("*".equals(tokens[i])||"/".equals(tokens[i])||"-".equals(tokens[i])||"+".equals(tokens[i])){
                int a = deque.pop();
                int b = deque.pollFirst();
                if(tokens[i]=="*") deque.push(a*b);
                if(tokens[i]=="+") deque.push(a+b);
                if(tokens[i]=="-") deque.push(b-a);
                if(tokens[i]=="b") deque.push(b/a);
            }else{
                deque.push(Integer.valueOf(tokens[i]));
            }
        }
        return deque.peek();
    }
}
```

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList();
        for (int i = 0; i < tokens.length; ++i) {
            if ("+".equals(tokens[i])) {
                stack.push(stack.pop() + stack.pop());
            } else if ("-".equals(tokens[i])) {
                stack.push(-stack.pop() + stack.pop());
            } else if ("*".equals(tokens[i])) {
                stack.push(stack.pop() * stack.pop());
            } else if ("/".equals(tokens[i])) {
                int temp1 = stack.pop();
                int temp2 = stack.pop();
                stack.push(temp2 / temp1);
            } else {
                stack.push(Integer.valueOf(tokens[i]));
            }
        }
        return stack.pop();
    }
}
```



### 239.滑动窗口最大值✅🔁🔁🟥

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
>
> 返回 滑动窗口中的最大值 。
>
> 示例 1：
>
> ```
>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> 
> ---------------               -----
> 
> [1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7
> ```
> 
> 示例 2：
>
> ```
>输入：nums = [1], k = 1
> 输出：[1]
> ```

介绍一下`ArrayDeque`，不是性能安全的，作为栈时比Stack性能好，作为队列时比Queue性能好

ArrayDeque和Java的LinkedList都实现了Deque接口。但是，它们之间存在一些差异。

- LinkedList支持空元素，而ArrayDeque不支持。
- 链表中的每个节点都包含到其他节点的链接。这就是LinkedList比ArrayDeque需要更多存储空间的原因。
- 如果要实现队列或双端队列数据结构，则ArrayDeque可能比LinkedList快。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        //利用双端队列手动实现单调队列
        /**
   		  * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可
 		* 单调队列类似 （tail -->） 3 --> 2 --> 1 --> 0 (--> head) (右边为头结点，元素存的是下标)*/
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res =new int[nums.length-k+1];
        int idx = 0;
        for(int i = 0;i<n;i++){
             // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点
            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出。节点索引在窗口内
            while(!deque.isEmpty()&&deque.peek()< i-k+1){//队顶元素已经超出Deque范围
                deque.poll();//队顶出队
            }
            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则原末尾弹出//这步是关键！！，deque并不是有k个元素
            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {//注意是while循环！
                deque.pollLast();//队尾出队
            }

            deque.offer(i);

            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了
            if(i >= k - 1){//当队列满了就可以开始检查了
                res[idx++] = nums[deque.peek()];//取队顶元素记入结果
            }
        }
        return res;
    }
}
```

### 347.前 K 个高频元素✅🔁🔁

> 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。
>
>  示例 1:
>
> ```
>输入: nums = [1,1,1,2,2,3], k = 2
> 输出: [1,2]
>```
> 
> 示例 2:
> 
> ```
>输入: nums = [1], k = 1
> 输出: [1]
>```

`Entry` 将键值对的对应关系封装成对象，这样在遍历时，可以通过Entry获取对应信息。

`Set<Map.Entry<K,V>> entrySet();`返回Set集合，里面装Entry

> 实现步骤：
>
> 1，调用Map集合中的entrySet()方法，将集合中的映射关系对象存储到Set集合中
>
> 2，迭代Set集合
>
> 3，获取Set集合的元素，是映射关系的对象
>
> 4，通过映射关系对象的方法，getKey()和getValue(),获取键值对

这里的优先队列就是一个堆，因为优先队列从队头取元素，从队尾加元素，其内部元素自动依照权值排列

> ```
> peek()//返回队首元素
> poll()//返回队首元素，队首元素出队列
> add()//添加元素
> size()//返回队列元素个数
> isEmpty()//判断队列是否为空，为空返回true,不空返回false
> ```

```java
//他人题解
class Solution{
    public int[] topKFrequent(int[] nums, int k){
        int[] result = new int[k];
        Hashmap<Integer, Integer> map = new HashMap<>();
        for(int num:nums){
            map.put(num, map.getOrDefault(num, 0)+1);//将元素和出现次数记录
        }
        
        Set<Map.Entry<Integer,Integer>> entries = map.entrySet();
        //根据map的value值正序排，相当于一个小顶堆
        PriorityQueue<Map.Entry<Integer,Integer>> queue = new PriorityQueue<>((o1,o2)->o1.getValue()-o2.getValue());
        for(Map.Entry<Integer,Integer> entry:entries){
            queue.offer(entry);
            if(queue.size()>k) queue.poll();
        }
        //小顶堆，取出前面value小的，剩下的k个就是结果
        for(int i = k-1;i>=0;i--){
            result[i] = queue.poll().getKey();
        }
        return result;
    }
}
```




## 二叉树

### 144.二叉树前序遍历✅🔁🔴

> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。
>
> ```
> 输入：root = [1,null,2,3]
> 输出：[1,2,3]
> 示例 2：
> 
> 输入：root = []
> 输出：[]
> 示例 3：
> 
> 输入：root = [1]
> 输出：[1]
> 
> 输入：root = [1,null,2]
> 输出：[1,2]
> 
> 输入：root = [1,2]
> 输出：[1,2]
> ```
>
> ```java
> /**
>  * Definition for a binary tree node.
>  * public class TreeNode {
>  *     int val;
>  *     TreeNode left;
>  *     TreeNode right;
>  *     TreeNode() {}
>  *     TreeNode(int val) { this.val = val; }
>  *     TreeNode(int val, TreeNode left, TreeNode right) {
>  *         this.val = val;
>  *         this.left = left;
>  *         this.right = right;
>  *     }
>  * }
>  */
> ```

```java
//需要： 一个递归函数，当val=null时结束，如果不是null则加入List中
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
		List<Integer> result = new ArrayList<>();
        preorder(root.val, result);
		return result;
    }
    
    public void preorder(TreeNode root,List<Integer> result){
        if(root == null) return;
        result.add(root);
        preorder(root.left,result);
        preorder(root.right,result);
    }
}
```

使用栈（迭代遍历）

```java
//先将根节点入栈
//每次迭代：出栈顶元素，再将该元素的右左孩子压栈
public List<Integer> preorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();		//注意创建的时候需要泛型
    List<Integer> result = new ArrayList<>();
    if(root==null) return result;
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode top = stack.pop();
        result.add(top.val);
        if(top.right!=null)		//解题时遗漏的点，需要检查非空才入栈，和递归不一样，递归再函数开头就有空值返回
        	stack.push(top.right);
        if(top.left!=null)
        	stack.push(top.left);
    }
    return result;
    }
```

### 94.二叉树中序遍历✅🔁🔴

递归法和上题类似

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    inorder(root,res);
    return res;
}
public void inorder(TreeNode root, List<Integer> res){
    if(root==null) return;
    inorder(root.left,res);
    res.add(root.val);
    inorder(root.right,res);
}
```

现学习迭代法

```java
//超内存
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();		
    List<Integer> result = new ArrayList<>();
    if(root==null) return result;
    TreeNode cur = root;
    while(!stack.isEmpty()||cur!=null){   
       if(cur!=null){
           stack.push(cur);
           cur = cur.left;
       }else{
           cur=stack.pop();
           result.add(cur.val);
           stack.push(cur.right);//问题在此，，注意好 栈和指针的关系
       }
    }
    return result;
}
}
```

```java
//解答
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
           if (cur != null){
               stack.push(cur);
               cur = cur.left;
           }else{
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right;
           }
        }
        return result;
    }
}
```



### 145.二叉树后序遍历✅🔁🔴🔴

采用迭代法

```java
// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        if(root==null) return result;
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.left!=null) stack.push(node.left);
            if(node.right!=null) stack.push(node.right);
        }
        Collections.reverse(result);
        return result;
    }
}
```

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(!stack.isEmpty()||cur!=null){
            while(cur!=null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.peek();
            if(cur.right==null||cur.right==pre){
                list.add(cur.val);
                stack.pop();
                pre = cur;
                cur = null;
            }else{
                cur = cur.right;
            }
        }    
        return list;
    }
}
```



### 二叉树层序遍历

##### 102.二叉树层序遍历✅🔁🔴

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

```java
public List<List<Integer>> resList = new ArrayList<List<Integer>>();
 public List<List<Integer>> levelOrder(TreeNode root) {
     //checkFun01(root,0)
        checkFun02(root);//用的迭代方法
        return resList;
    }

public void checkFun02(TreeNode node){
    if(node==null) return;
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(node);
    while(!queue.isEmpty()){
        List<Integer> itemList = new ArrayList<>();
        int len = queue.size();			//通过size函数就能求得这一层多少个节点，而不是每加一个+1
        while(len>0){
            TreeNode tmpNode = queue.poll();
            itemList.add(tmpNode.val);
            if (tmpNode.left != null) queue.offer(tmpNode.left);
            if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
        }
        resList.add(tmpList);
    }
}
```

```java
//递归方式
public void checkFun01(TreeNode node,Integer deep){
    if(root==null) return ;
    deep++;
    if(resList.size()<deep){//当层级增加时，list的Item也增加，利用list的索引值进行层级界定
        List<Integer> item = new ArrayList<>();
        resList.add(item);
    }
    resList.get(deep-1).add(node.val);
    
    checkFun01(node.left,deep);
    checkFun01(node.right,deep);
}
```

##### 107.二叉树层序遍历Ⅱ✅🔁

相比于上一题，逆转List输出，本题需全程手打

```java
//这里忘了怎么逆转链表了！！！！
//直接新建一个新链表，从原链表后往前遍历加入！！
//ArrayList 是数组，支持随机存储！！！
list.get(i); //根据下标读取
list.add();	//加入当前末尾
```

##### 199.二叉树的右视图✅

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
> ```
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,null,3]
> 输出: [1,3]
> ```
>
> 相当于层序遍历的每层最后一个节点

```java
//层序遍历的稍作修改即可
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        //仅加入层序遍历每层最后一个节点
        List<Integer> itemList = new ArrayList<>();
        if(root==null) return itemList;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
        	int len = queue.size();			//通过size函数就能求得这一层多少个节点，而不是每加一个+1
        	while(len>0){
            	TreeNode tmpNode = queue.poll();
            	if(len==1) itemList.add(tmpNode.val);
            	if (tmpNode.left != null) queue.offer(tmpNode.left);
            	if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
        	}
        
    	}
   		return itemList;
    }
}
```

##### 637.二叉树的层平均值✅

> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[3.00000,14.50000,11.00000]
> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
> 因此返回 [3, 14.5, 11] 。
> ```

```java
//类似层序遍历，只不过将itemlist求得后算一遍平均值
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
	List<Double> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            int listSize = itemList.size();
            double sum = 0;
            for(int i = 0;i<listSize;i++){
                sum+=itemList.get(i);
            }
            double ave = sum/listSize;
            res.add(ave);    
        }
        return res;
    }
}
```

##### 515.每个树行的最大值✅✅✅

> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。
>
> ```
> 输入: root = [1,3,2,5,3,null,9]
> 输出: [1,3,9]
> ```
>
> **示例2：**
>
> ```
> 输入: root = [1,2,3]
> 输出: [1,3]
> ```

```java
//ArrayList 有求最大值的内置方法吗？
class Solution {
    public List<Integer> largestValues(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if(root==null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            //通过得到的itemList，找到其最大值，加入到res中
            int listSize = itemList.size();
            int max=itemList.get(0);
            for(Integer i : itemList){
                if(i>max) max=i;
            }
            res.add(max);
        }
        return res;
    }
}
```

##### 429.N叉树层序遍历✅

> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。
>
> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
>
> ```java
> /*
> // Definition for a Node.
> class Node {
>     public int val;
>     public List<Node> children;
> 
>     public Node() {}
> 
>     public Node(int _val) {
>         val = _val;
>     }
> 
>     public Node(int _val, List<Node> _children) {
>         val = _val;
>         children = _children;
>     }
> };
> */
> 
> ```

```java
//root.children 得到的是List，则利用root.children.get(i)获取第i个孩子节点
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
         List<List<Integer>> res = new ArrayList<>();
        if(root==null) return res;
        Deque<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                Node tmpNode = queue.poll();
                itemList.add(tmpNode.val);
                int numOfChildren = tmpNode.children.size();
                for(int i = 0;i<numOfChildren;i++){
                    queue.offer(tmpNode.children.get(i));
                }
                len--;
            }
            res.add(itemList);
        }
        return res;
    }
}
```



##### 116.填充每个节点的下一个右侧节点指针🟥

> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if(root==null) return root;
        Deque<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>1){
                Node tmpNode = queue.poll();
                tmpNode.next = queue.peek();
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            Node tmpNode = queue.poll();
            tmpNode.next = null;
            if(tmpNode.left!=null) queue.offer(tmpNode.left);
            if(tmpNode.right!=null) queue.offer(tmpNode.right);
        }
        return root;
    }
}
```

##### 117填充每个节点的下一个右侧节点指针Ⅱ✅

> 给定一个二叉树
>
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。
>
> ```
> 和 116一样代码
> ```

##### 104.二叉树最大深度✅

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> 示例：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
>         3
>        / \
>       9  20
>         /  \
>        15   7
>    返回它的最大深度 3 。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            depth++;
        }
        return depth;
    }
}
```

##### 111.二叉树最小深度✅

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。

```java
//想法：与上一题类似，当遇到节点没有左右节点，返回当前深度+1
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len>0){
                TreeNode tmpNode = queue.poll();
                if(tmpNode.left==null&&tmpNode.right==null) return depth+1;
                if(tmpNode.left!=null) queue.offer(tmpNode.left);
                if(tmpNode.right!=null) queue.offer(tmpNode.right);
                len--;
            }
            depth++;
        }
        return depth;
    }
}
```

### 226.翻转二叉树✅

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```
>
> ```
> 输入：root = [2,1,3]
> 输出：[2,3,1]
> ```

```java
//思路：无论以什么顺序遍历完就行，每个节点反转左右子节点
class Solution {//这是前序遍历
    public TreeNode invertTree(TreeNode root) {
        preorder(root);
        return root;
    }
    public void preorder(TreeNode node){
        if(node==null) return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preorder(node.right);
        preorder(node.left);
        
    }
}
```

### 101.对称二叉树🔁

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称

```java
//这是错误解法，因为单纯一个层序遍历无法得出唯一的树形！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
//本题特例：   [1,2,2,null,3,null,3]
//先反转一下，在检查
class Solution {
    public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> queue = new LinkedList<>();
        List<Integer> res1 = new ArrayList<>();
        List<Integer> res2 = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            res1.add(tmp.val);
            if(tmp.left!=null) queue.offer(tmp.left);
            if(tmp.right!=null) queue.offer(tmp.right);
        }
        //这里已经得到了树的层序遍历，现在反转一下，再遍历一遍，就可以对比了
        preorder(root);//反转函数
        Deque<TreeNode> queue2 = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            res2.add(tmp.val);
            if(tmp.left!=null) queue.offer(tmp.left);
            if(tmp.right!=null) queue.offer(tmp.right);
        }
        //q1和q2对比
        int len = res1.size();
        for(int i = 0;i<len;i++){
            if(res1.get(i)!=res2.get(i)) return false;
        }
        return true;
    }
    public void preorder(TreeNode node){
        if(node==null) return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preorder(node.right);
        preorder(node.left);       
    }
}
```

```java
//题解：递归法
public boolean isSymmetric(TreeNode root){
    return compare(root.left, root.right);
}

private boolean compare(TreeNode left, TreeNode right){//同时传入两个节点
    if(left==null&&right!=null) return false;
    if(left!=null&&right==null) return false;
    if(left==null&&right==null) return true;
    if(letf.val!=right.val) return false;//排除了所有的错误情况，开始递归
    //比较外侧
    boolean compareOutside = compare(left.left,right.right);
    //比较内侧
    boolean compareInside = compare(left.right, right.left);
    return compareOutside&&compareInside;
}
```

```java
//题解：迭代法
public boolean isSymmetric(TreeNode root){
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offerFirst(root.left);
    deque.offerLast(root.right);
    while(!deque.isEmpty()){
        TreeNode leftNode = deque.pollFirst();
        TreeNode rightNode = deque.pollLast();
        if(leftNode == null & rightNode ==null) continue;
        if(leftNode==null||right==null||leftNode.val!=rightNode.val) return false;
        deque.offerFirst(leftNode.left);
        deque.offerFirst(leftNode.right);
        deque.offerLast(rightNode.right);
        deque.offerLast(rightNode.left);
    }
    return true;
}
```



### 222.完全二叉树的节点个数✅🔁

> 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
>
> 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1 ~ $2^h$ 个节点

```java
//遍历树用时过高     用时击败8%
//题解：利用性质     用时击败100%
class Solution{
    public int countNodes(TreeNode root){
        if(root == null) return 0;
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        if(leftDepth == rightDepth){//此时左子树是满二叉树
            return (1<<leftDepth) +countNodes(root.right);    // 1(根节点) + (1 << ld)-1(左完全左子树节点数) + 右子树节点数量       
        }else{//此时右子树必然是满二叉树，rightDepth+1=leftDepth
            return (1<<rightDepth) +countNodes(root.left);  // 1(根节点) + (1 << rd)-1(右完全右子树节点数) + 左子树节点数量
        }
    }
    
    private int getDepth(TreeNode root){
        int depth = 0;
        while(root!=null){
            root= root.left;
            depth++
        }
        return depth;
    }
 }
```

### 110.平衡二叉树🔁🔁🔴

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：
>
> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```java
//可以理解的解法
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;//空树为平衡
        if(Math.abs(depth(root.left)-depth(root.right))>1) return false;//左右子树高度差大于1
        return isBalanced(root.left)&&isBalanced(root.right);//本树判断完，再递归判断子树
    }
    public int depth(TreeNode root){//求子树高度
        if(root==null) return 0;
        int left = depth(root.left);//分别求左右子树高度
        int right = depth(root.right);

        return Math.max(right,left)+1;//得出本树的高度
    }
}
```



```java
class Solution {
   /**
     * 递归法
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        // 左右子树高度差大于1，return -1表示已经不是平衡树了
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

```javascript
class Solution {
   /**
     * 迭代法，效率较低，计算高度时会重复遍历
     * 时间复杂度：O(n^2)
     */
    public boolean isBalanced(TreeNode root) {
        if(root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root!= null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 比较左右子树的高度差，输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 层序遍历，求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null)   return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null)    deque.offer(poll.left);
                if (poll.right != null)   deque.offer(poll.right);
            }
        }
        return depth;
    }
}
```

```java
class Solution {
   /**
     * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历
     * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。
     * 时间复杂度：O(n)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null)   return 0;
        int leftHeight = root.left != null ? root.left.val : 0;
        int rightHeight = root.right != null ? root.right.val : 0;
        int height = Math.max(leftHeight, rightHeight) + 1;
        root.val = height;// 用TreeNode.val来保存当前结点的高度
        return height;
    }
}
```

### 257.二叉树的所有路径✅✅🔁

> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> ```
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：["1"]
> ```

```java
//递归+回溯🔁
class Solution {
    /**
     * 递归法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null)  return res;
        List<Integer> paths = new ArrayList<>();
        traversal(root, paths, res);
        return res;
    }
    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {
        paths.add(root.val);
        // 叶子结点
        if (root.left == null && root.right == null) {   // 输出
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));
            res.add(sb.toString());
            return;
        }
        if (root.left != null) {
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);// 回溯，移除path这个数组的最后一个元素，就相当于把第一行加入的节点（此节点移除）
        }
        if (root.right != null) {
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
    }
}
```

```java
// 解法2
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)  return result;
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```



### 404.左叶子之和✅🔁🔴

> 给定二叉树的根节点 `root` ，返回所有左叶子之和。
>
> 输入: root = [3,9,20,null,null,15,7] 
> 输出: 24 
> 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

常用递归遍历

```java
//通过父节点寻找，if(node.left!=null&&node.left.left==null&&node.left.right==null)
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
	    if(root==null) return 0;
        int sum =0;
        if(root.left!=null&&root.left.left==null&&root.left.right==null){
            sum+=root.left.val;
        }
        return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
}
```

### 513.找树的左下角的值🟥

> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。
>
> 假设二叉树中至少有一个节点。

```java
//层序遍历解法，效率极低
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        //层序遍历，更新底层第一个元素
        Deque<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> itemList = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode tmp = queue.poll();
                itemList.add(tmp.val);
                if(tmp.left!=null) queue.offer(tmp.left);
                if(tmp.right!=null) queue.offer(tmp.right);
                len--;
            }
            res.add(itemList);
        }
        return res.get(res.size()-1).get(0);
    }
}
```

```java
// 递归法：维护一个Deep，这样每次传入子节点和deep+1，你叫Deep和deep+1//
//还是没理解透
class Solution {
    private int Deep = -1;
    private int value = 0;
    public int findBottomLeftValue(TreeNode root) {
        value = root.val;
        findLeftValue(root,0);
        return value;
    }

    private void findLeftValue (TreeNode root,int deep) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            if (deep > Deep) {
                value = root.val;
                Deep = deep;
            }
        }
        if (root.left != null) findLeftValue(root.left,deep + 1);
        //因为每一层最左侧的节点都是第一个读取的，后面同层的节点因为deep更新，其值不会读取，除非deep变大
        if (root.right != null) findLeftValue(root.right,deep + 1);
    }
}
```

### 112.路径总和🔁🔁🔴

> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
>
> 叶子节点 是指没有子节点的节点。
>
> ```
> 输入：root = [1,2,3], targetSum = 5
> 输出：false
> 解释：树中存在两条根节点到叶子节点的路径：
> (1 --> 2): 和为 3
> (1 --> 3): 和为 4
> 不存在 sum = 5 的根节点到叶子节点的路径。
> ```

```java
//无法输出正确结果
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
//遍历所有已知节点，再比较。方法同257打印所有路径
        List<Integer> path = new ArrayList<>();
        boolean res = traversal(root,path,targetSum);
        return res;
    }
    public boolean traversal(TreeNode root, List<Integer> path,int targetSum){
        path.add(root.val);
      if(root.left==null&&root.right==null){
          int sum = 0;
          for(int i :path){
              sum+=i;
          }
          if(sum==targetSum) return true;
      }
        if(root.left!=null){
            traversal(root.left,path,targetSum);
            path.remove(path.size()-1);
        }
        if(root.right!=null){
            traversal(root.right,path,targetSum);
            path.remove(path.size()-1);
        }
        return false;
    }
}
```

```java
//递归法
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
         if(root==null) return false;
         if(root.left==null&&root.right==null) return root.val ==targetSum;//当叶子节点和减去的值相等，刚好路径得到
         return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
        //非叶子节点递归，只需传减去的值下去
    }
}
```

```java
//迭代法
public boolean hasPathSum(TreeNode root, int targetSum){
    if(root==null) return false;
    Stack<TreeNode> stack1 = new LinkedList<>();
    Stack<Intager> stack2 = new LinkedList<>();
    stack1.push(root);
    stack2.push(root.val);
    while(!stack1.isEmpty()){
        int size = stack1.size();
        for(int i = 0;i<size;i++){
            TreeNode node = stack1.pop();
            int sum = stack2.pop();
            if(node.left==null&&node.right==null&&sum==target) return true;
            if(node.right!=null){
                stack1.push(node.rigth);
                stack2.push(sum+node.right.val);
            }
            if(node.left!=null){
                stack1.push(node.left);
                stack2.push(sum+=node.left.val);
            }
        }
    }
    return false;
}
```

### 106.从中序和后序构造二叉树🔁🔁🔴

> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
>
> ```
> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> 输出：[3,9,20,null,null,15,7]
> ```
>
> 示例 2:
>
> ```
> 输入：inorder = [-1], postorder = [-1]
> 输出：[-1]
> ```

首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。说到一层一层切割，就应该想到了递归。

来看一下一共分几步：

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

```java
class Solution {🔴
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree1(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }
    public TreeNode buildTree1(int[] inorder, int inLeft, int inRight,
                               int[] postorder, int postLeft, int postRight) {
        // 没有元素了
        if (inRight - inLeft < 1) {
            return null;
        }
        // 只有一个元素了
        if (inRight - inLeft == 1) {
            return new TreeNode(inorder[inLeft]);
        }
        // 后序数组postorder里最后一个即为根结点
        int rootVal = postorder[postRight - 1];
        TreeNode root = new TreeNode(rootVal);
        int rootIndex = 0;
        // 根据根结点的值找到该值在中序数组inorder里的位置
        for (int i = inLeft; i < inRight; i++) {
            if (inorder[i] == rootVal) {
                rootIndex = i;
                break;
            }
        }
        // 根据rootIndex划分左右子树
        root.left = buildTree1(inorder, inLeft, rootIndex,
                postorder, postLeft, postLeft + (rootIndex - inLeft));
        root.right = buildTree1(inorder, rootIndex + 1, inRight,
                postorder, postLeft + (rootIndex - inLeft), postRight - 1);
        return root;
    }
}
```

```java
//比较好理解的方法，效率低🔁
public TreeNode buildTree(int[] inorder, int[] postorder) {
        int i_len = inorder.length;
        int p_len = postorder.length;//注意length是变量，不是方法，没有（）
        if(i_len == 0 || p_len == 0){
            return null;
        }
        //通过后序序列，查找子树的根节点
        int root_val = postorder[p_len - 1];
        //构造根节点
        TreeNode root = new TreeNode(root_val);
        //遍历中序序列，确定根结点在中序序列中的位置，从而确定左右子树
        int k = 0;
        for (int i = 0; i < i_len; i++) {
            if(root_val == inorder[i]){
                k = i;//这个k就是根节点在中序的位置
                break;
            }
        }
        //分割左右子树，分别创建左右子树的中序、后序序列
        int[] left_in = Arrays.copyOfRange(inorder, 0, k);
        int[] left_post = Arrays.copyOfRange(postorder, 0, k);
        root.left = buildTree(left_in,left_post);   //注意.left 是域，不是新节点，不要TreeNode
        
        int[] right_in = Arrays.copyOfRange(inorder, k + 1, i_len);
        int[] right_post = Arrays.copyOfRange(postorder, k, p_len - 1);
        root.right = buildTree(right_in,right_post);
        return root;
    }
```

### 105.从前序与中序构造二叉树✅🔁

> 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

```java
//类似上一题的解法
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int pre_length = preorder.length;
        int in_length = inorder.length;
        if(pre_length==0||in_length==0) return null;

        int root_val = preorder[0];
        TreeNode root = new TreeNode(root_val);
        int k = 0;
        for(int i = 0;i<in_length;i++){
            if(inorder[i]==root_val){
                k = i; break;
            }
        }
        //分割
        int[] left_pre = Arrays.copyOfRange(preorder,1,k+1);
        int[] left_in = Arrays.copyOfRange(inorder,0,k);
        root.left = buildTree(left_pre,left_in);

        int[] right_pre = Arrays.copyOfRange(preorder,k+1,pre_length);
        int[] rigth_in = Arrays.copyOfRange(inorder,k+1,pre_length);
        root.right = buildTree(right_pre,rigth_in);
        return root;
    }
}
```

### 654.最大二叉树✅

> 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:
>
> 创建一个根节点，其值为 nums 中的最大值。
> 递归地在最大值 左边 的 子数组前缀上 构建左子树。
> 递归地在最大值 右边 的 子数组后缀上 构建右子树。
> 返回 nums 构建的 最大二叉树 。
>

```java
//采用上一题的解法可通过，效率较低
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length==0) return null;
        //找到最大值
        int max = 0;
        int max_index = 0;
        for(int i = 0;i<nums.length;i++){
            if(nums[i]>max){
                max = nums[i];
                max_index = i;
            }
        }
        TreeNode root = new TreeNode(max);
        int[] left = Arrays.copyOfRange(nums,0,max_index);
        int[] right = Arrays.copyOfRange(nums,max_index+1,nums.length);
        root.left = constructMaximumBinaryTree(left);
        root.right = constructMaximumBinaryTree(right);
        return root;
    }
}
```

```java
//题解：用时100%，想法类似，新添加判断：没有元素和只有一个元素
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return constructMaximumBinaryTree1(nums, 0, nums.length);
    }

    public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) {
        if (rightIndex - leftIndex < 1) {// 没有元素了
            return null;
        }
        if (rightIndex - leftIndex == 1) {// 只有一个元素
            return new TreeNode(nums[leftIndex]);
        }
        int maxIndex = leftIndex;// 最大值所在位置
        int maxVal = nums[maxIndex];// 最大值
        for (int i = leftIndex + 1; i < rightIndex; i++) {
            if (nums[i] > maxVal){
                maxVal = nums[i];
                maxIndex = i;
            }
        }
        TreeNode root = new TreeNode(maxVal);
        // 根据maxIndex划分左右子树
        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);
        root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);
        return root;
    }
}
```

### 617.合并二叉树🔁🔁🔴

> 给你两棵二叉树： root1 和 root2 。
>
> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
>
> 返回合并后的二叉树。
>
> 注意: 合并过程必须从两个树的根节点开始。
>

```java

class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null) return root2;
        if(root2==null) return root1;

        TreeNode root = new TreeNode(root1.val+root2.val);
        root.left = mergeTrees(root1.left,root2.left);
        root.right = mergeTrees(root1.right,root2.right);
        return root;
    }
}
```

### 700.二叉树中的搜索✅

> 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
>
> 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
>

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root ==null) return null;
        if(root.val == val) return root;
        if(root.val>val) return searchBST(root.left,val);
        if(root.val<val) return searchBST(root.right,val);
        return null;
    }
}
```

### 98.验证二叉搜索树🔁🔴

> 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
>
> 有效 二叉搜索树定义如下：
>
> 节点的左子树只包含 小于 当前节点的数。
> 节点的右子树只包含 大于 当前节点的数。
> 所有左子树和右子树自身必须也是二叉搜索树。
>

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
		if(root==null) return true;
        if(root.left!=null&&root.val<root.left.val) return false;
        if(root.right!=null&&root.val>root.right.val) return false;
        return (isValidBST(root.left)&&isValidBST(root.right));
    }
}
//错误，输入：
//[2,2,2]
//输出：
//true
//预期结果：
//false
```

```java
public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean validate(TreeNode node, long min, long max) {
        if (node == null) {
            return true;
        }
        if (node.val <= min || node.val >= max) {
            return false;
        }
        return  validate(node.left, min, node.val) && validate(node.right, node.val, max);
    }
```

```java
class Solution {
    // 迭代：利用中序遍历顺序
    public boolean isValidBST(TreeNode root) {
        if (root == null)   return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;// 左
            }
            // 中，处理
            TreeNode pop = stack.pop();
            if (pre != null && pop.val <= pre.val) {
                return false;
            }
            pre = pop;
            root = pop.right;// 右
        }
        return true;
    }
}
```

### 530.二叉树的最小绝对差✅🔁

> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
>
> 差值是一个正数，其数值等于两值之差的绝对值。

```java
//直接中序遍历：效率极低
class Solution {
    public int getMinimumDifference(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root,res);
        List<Integer> nums = new ArrayList<>();
        for(int i=0;i<res.size()-1;i++){
            nums.add(res.get(i+1)-res.get(i));
        }
        int min = Integer.MAX_VALUE;
        for(int i :nums){
            if(i<min) min = i;
        }
        return min;
    }

    public void inorder(TreeNode root,List<Integer> res){
        if(root==null) return;
        inorder(root.left,res);
        res.add(root.val);
        inorder(root.right,res);
    }
}
```

```java
//递归：高效率：在递归的同时就比价前序元素
class Solution {
    TreeNode pre;// 记录上一个遍历的结点
    int result = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
       if(root==null)return 0;
       traversal(root);
       return result;
    }
    public void traversal(TreeNode root){
        if(root==null)return;
        //左
        traversal(root.left);
        //中
        if(pre!=null){
            result = Math.min(result,root.val-pre.val);
        }
        pre = root;
        //右
        traversal(root.right);
    }
}
```

### 501.二叉搜索树中的众数🔁

> 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
>
> 如果树中有不止一个众数，可以按 任意顺序 返回。
>
> 假定 BST 满足如下定义：
>
> 结点左子树中所含节点的值 小于等于 当前节点的值
> 结点右子树中所含节点的值 大于等于 当前节点的值
> 左子树和右子树都是二叉搜索树
>

```java
class Solution {
    ArrayList<Integer> resList;
    int maxCount;
    int count;
    TreeNode pre;

    public int[] findMode(TreeNode root) {
        resList = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;
        findMode1(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }

    public void findMode1(TreeNode root) {
        if (root == null) {
            return;
        }
        findMode1(root.left);

        int rootValue = root.val;
        // 计数
        if (pre == null || rootValue != pre.val) {
            count = 1;
        } else {
            count++;
        }
        // 更新结果以及maxCount
        if (count > maxCount) {
            resList.clear();
            resList.add(rootValue);
            maxCount = count;
        } else if (count == maxCount) {
            resList.add(rootValue);
        }
        pre = root;

        findMode1(root.right);
    }
}
```



### 236.二叉树的最近公告祖先

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>

```java
//回溯过程就是自底向上
//注意：除了p和q本身就是祖先，其他情况p和q一定在最近公共祖先的左右子树上

```



### 235.二叉搜索树的最近公共祖先🚸

> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
> 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
>  
>
> 示例 1:
>
> ```
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
> 输出: 6 
> 解释: 节点 2 和节点 8 的最近公共祖先是 6。
> ```
>
> 示例 2:
>
> ```
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
> 输出: 2
> 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
> ```

```java
//递归法
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```



### 701.二叉搜索树中的插入操作

### 450.删除二叉搜索树中节点

### 669.修建二叉搜索树

### 108.有序数组转化为二叉搜索树

### 538.二叉搜索树转化为累加树

## 回溯法

### 77.组合🟥🟨🟩

> 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
>
> 你可以按 任何顺序 返回答案。
>
> 示例 1：
>
> ```
> 输入：n = 4, k = 2
> 输出：
> [[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]
> ```
>
> 示例 2：
>
> ```
> 输入：n = 1, k = 1
> 输出：[[1]]
> ```

> <font color=red>二刷关键点</font>：
>
> - 声明List 和声明LinkedList，能使用的方法不同！
> - 将List转ArrayList
> - 注意下次的迭代的起始下标
> - 剪枝：
>   - i<=n
>   - i <= n - (k-path.size())+1

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));//注意这里添加
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){  //提交 i <=n 也行，但是消耗时间巨大！ 这是没有剪枝
            path.add(i);
            combineHelper(n, k, i + 1);
            path.removeLast();
        }
    }
}
```

### 39.组合总和🟥🟨

> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
>
> candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 target 的不同组合数少于 150 个。
>
> 示例 1：
>
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```
>
> 示例 2：
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```
>
> 示例 3：
>
> ```
> 输入: candidates = [2], target = 1
> 输出: []
> ```
>
> <font color=red>二刷关键点</font>：
>
> - 别以为可重复就不需要index！！！  注意startindex 和 for 起始位置上的关系
> - poll 默认 removeFirst

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target,0,0);
        return res;
    }

    public void backtracking(int[] candidates, int target, int sum ,int startIndex){
        if(sum > target) return;
        if(sum == target){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = startIndex;i<candidates.length;i++){
            path.addFirst(candidates[i]);		//注意下addFirst和poll对应
            sum+=candidates[i];
            backtracking(candidates,target,sum,i);
            sum -= candidates[i];
            path.poll();
        }
    }
}
```



### 216.组合总和Ⅲ🟥

相当于39题：确定了数组 ，确定了树的深度

> 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
>
> 只使用数字1到9
> 每个数字 最多使用一次 
> 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
> 示例 1:
>
> ```
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> 解释:
> 1 + 2 + 4 = 7
> 没有其他符合的组合了。
> ```
>
> 示例 2:
>
> ```
> 输入: k = 3, n = 9
> 输出: [[1,2,6], [1,3,5], [2,3,4]]
> 解释:
> 1 + 2 + 6 = 9
> 1 + 3 + 5 = 9
> 2 + 3 + 4 = 9
> 没有其他符合的组合了。
> ```
>
> 示例 3:
>
> ```
> 输入: k = 4, n = 1
> 输出: []
> 解释: 不存在有效的组合。
> 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
> ```

```java
//模仿39题做出
class Solution {
    int[] nums = {1,2,3,4,5,6,7,8,9};
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    //n = target;
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(nums,n,0,k,0);
        return res;
    }

    public void backtracking(int[] nums,int n,int sum,int k, int startIndex){
        if(sum>n || path.size()>k) return;//这里的剪枝可以省去大量时间
        if(sum==n && path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = startIndex; i < 9;i++){
            path.addFirst(nums[i]);
            sum += nums[i];
            backtracking(nums,n,sum, k,i+1);
            sum -= nums[i];
            path.poll();
        }
    }
}
```

### 17.电话号码字母组合🟥

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> 电话九宫格对应按键：
>
> | 1 -        | 2 abc     | 3 def      |
> | ---------- | --------- | ---------- |
> | **4 ghi**  | **5 jkl** | **6 mno**  |
> | **7 pqrs** | **8 tuv** | **9 wxyz** |
> | *          | **0**     | #          |
>
> 示例 1：
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> 示例 2：
>
> ```
> 输入：digits = ""
> 输出：[]
> ```
>
> 示例 3：
>
> ```
> 输入：digits = "2"
> 输出：["a","b","c"]
> ```

```java
/**
*@param : list： 存结果的list
		digits： 题目给定的号码
		numString： 预先存好的号码对应关系
		temp： 用来存结果的StringBuilder
		num：当前遍历到号码的第几个数字，和index不太一样
		str：该号码的对应字符串
*/
//先存一个号码和字符串映射
class Solution{
   List<String> list = new ArrayList<>();
    
    public List<String> letterCombination(String digits){
        if(digits ==null || digits.length()==0) return list;//不符合返回空
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backtracking(digits,numString,0);
        return list;
    }
    
    StringBuilder temp = new StringBuilder();  //这个要放在外面，不然先遇到结束检查就找不到temp
    
    public void backtracking(String digits, String[] numString, int num){
        //结束条件
        if(num == digits.length()){
            list.add(temp.toString());
            return;
        }
        //先从映射表里读出来该数字对应的字符串
        String str = numString[digits.charAt(num) -'0']; // -'0' 是转为int型
        //回溯内容：
        for(int i = 0;i<str.length();i++){//根本没理解 num和i表示什么
            temp.append(str.charAt(i));
            backtracking(digits,numString, num+1);
            temp.deleteCharAt(temp.length()-1);//注意删除stringbuilder末尾元素
        }
        
    }
}
```

### 40.组合总和Ⅱ✅🔁🔁🔴

**该题写两次都是超时报错，缺少剪枝！！！**

> 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用 一次 。
>
> 注意：解集不能包含重复的组合。 
>
> 示例 1:
>
> ```
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 输出:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> ```
>
> 示例 2:
>
> ```
> 输入: candidates = [2,5,2,1,2], target = 5,
> 输出:
> [
> [1,2,2],
> [5]
> ]
> ```

```java
//和39一样，只是不能重复，递归下标+1
//[[1, 2, 5], [2, 1, 5]] 会重复输出，而set集合不能分辨，除非按顺序排好
//把所有集合求出来再去重容易超时，因此需要在搜寻过程去重
```

```java
//题解：使用标记数组
class Solution {
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> deque = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        //为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        //加标志数组，用来辅助判断同层节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        backTracking(candidates, target, 0, flag);
        return lists;
    }

    public void backTracking(int[] arr, int target, int index, boolean[] flag) {
        if (sum == target) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = index; i < arr.length && arr[i] + sum <= target; i++) {//arr[i] + sum <= target 是剪枝，不能不加！！！
            //出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && arr[i] == arr[i - 1] && !flag[i - 1]) {
                continue;
            }
            flag[i] = true;
            sum += arr[i];
            deque.push(arr[i]);
            //每个节点仅能选择一次，所以从下一位开始
            backTracking(arr, target, i + 1, flag);
            int temp = deque.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```

```java
//自己重写，但是超时！🔴🔴🔴🔴🔴缺少剪枝！！
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        boolean[] flag = new boolean[candidates.length];
        backtracking(candidates, target, 0, flag);
        return res;
    }
    public void backtracking(int[] candidates, int target, int index, boolean[] flag){
        if(sum == target){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i= index;i <candidates.length;i++){//这里缺少剪枝过程
            //先判断是否是重复元素
            if(i>0&&candidates[i]==candidates[i-1]&&!flag[i-1]) continue;
            flag[i] = true;
            sum += candidates[i];
            path.addLast(candidates[i]);
            backtracking(candidates,target,i+1,flag);
            sum -= candidates[i];
            flag[i] = false;
            path.pollLast();
        }
    }
}
```



```java
//题解：不使用标记数组
class Solution {
  List<List<Integer>> res = new ArrayList<>();
  LinkedList<Integer> path = new LinkedList<>();
  int sum = 0;
  
  public List<List<Integer>> combinationSum2( int[] candidates, int target ) {
    //为了将重复的数字都放到一起，所以先进行排序
    Arrays.sort( candidates );
    backTracking( candidates, target, 0 );
    return res;
  }
  
  private void backTracking( int[] candidates, int target, int start ) {
    if ( sum == target ) {
      res.add( new ArrayList<>(path));
      return;
    }
    for (int i = start; i < candidates.length && sum + candidates[i] <= target; i++ ) {
      //正确剔除重复解的办法
      //跳过同一树层使用过的元素
      if ( i > start && candidates[i] == candidates[i - 1] ) {
        continue;
      }
      sum += candidates[i];
      path.add( candidates[i] );
      // i+1 代表当前组内元素只选取一次
      backTracking( candidates, target, i + 1 );

      int temp = path.getLast();
      sum -= temp;
      path.removeLast();
    }
  }
}
```

### 131.分割回文串🔁🔁🔴🔴

> 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
>
> 回文串 是正着读和反着读都一样的字符串。
>
> 示例 1：
>
> ```
> 输入：s = "aab"
> 输出：[["a","a","b"],["aa","b"]]
> ```
>
> 示例 2：
>
> ```
> 输入：s = "a"
> 输出：[["a"]]
> ```

```java
class Solution{
    List<List<String>> res = new ArrayList<>();
    Deque<String> path = new LinkedList<>();
    
    //回文判断
    public boolean isPalindrome(String s, int start, int end){//左闭右闭的区间
        for(int i =start,j = end;i<j; i++,j--){
            if(s.charAt(i)!=s.charAt(j))
                return false;
        }
        return true;
    }
   //backtracking
    public void backtracking(String s,int index){
        //结束条件：已经分割到字符串尾部
        if(index >= s.length()){
            res.add(new ArrayList<>(path));
            return;
        }
        //递归
        for(int i = index;i < s.length(); i++){
            //先检查是否是回文
            if(isPalindrome(s,index,i)){//是的就将这个字串加入path
                String str = s.substring(index, i +1);//左闭右开的区间
                path.addLast(str);
            }else{//不是的直接跳过
                continue;
            }
            //回溯
            backtracking(s,i+1);
            path.pollLast();
        }
    }
    //
    public List<List<String>> partition(String s){
        backtracking(s,0);
        return res;
    }
}
```

### 93.复原IP地址🔁🔁🔁🔴

> 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
> 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
>
> 示例 1：
>
> ```
> 输入：s = "25525511135"
> 输出：["255.255.11.135","255.255.111.35"]
> ```
>
> 示例 2：
>
> ```
> 输入：s = "0000"
> 输出：["0.0.0.0"]
> ```
>
> 示例 3：
>
> ```
> 输入：s = "101023"
> 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
> ```

```java
//和131.分割回文串类似，每次都要检查分割后的是否满足条件
List<String> res = new ArrayList<>();
//判断数值
public boolean isValid(String s,int start, int end){
    /*1.检查start和end
    2.不能以0开头
    3.比0小或比9大的字符
    4.计算和不大于255*/
    if(start>end) return false;
    if(s.charAt(start)=='0'&&start!=end) return false;
    int num = 0;
    for(int i = start;i<=end;i++){
        if(s.charAt(i)<'0'||s.charAt(i)>'9')
            return false;
        num = num*10 +(s.charAt(i)-'0');
        if(num>255)
            return false;
    }
    return true;
    
}
//回溯
public void backtracking(String s, int index, int pointNum){
    //逗号3个时，进行最后一段字串检查和返回
    if(pointNum==3){
        if(isValid(s,index,s.length()-1)){
            result.add(s);
        }
        return;
    }
    for(int i = index;i<s.length()-1;i++){
        //更新i之后都要进行检查，然后才能进行下面的步骤
        if(isValid(s,index,i)){
            s = s.substring(0,i+1)+"."+s.substring(i+1);//在str后面加入一个逗号
            pointNum++;
            backtracking(s,i+2,pointNum);
            pointNum--;
            s = s.substring(0,i+1)+s.substring(i+2);
        }else{
            break;
        }
    }
}


public List<String> restoreIpAddress(String s){
    if(s.length()>12) return res;//初步的检查
    backtracking(s,0,0);
    return res;
}
```

```java
//效率更好的方式
```

### 78.子集✅

> 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
>
>  
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums,0);
        return res;
    }
    public void backtracking(int[] nums,int index){

        res.add(new ArrayList<>(temp));//这里不需要出口条件，不是组合问题，而是所有的情况都加进去

        for(int i = index;i<nums.length;i++){
            temp.addFirst(nums[i]);
            backtracking(nums,i+1);
            temp.pollFirst();
        }
    }
}
```

### 90.子集Ⅱ✅

> 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,2]
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```

```java
//类似于40题，需要flag来判断
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length];
        backtracking(nums,flag,0);
        return res;
    }
     public void backtracking(int[] nums,boolean[]flag,int index){

        res.add(new ArrayList<>(temp));//这里不需要出口条件，不是组合问题，而是所有的情况都加进去

        for(int i = index;i<nums.length;i++){
            if(i>0&&nums[i]==nums[i-1]&&!flag[i-1]){
                continue;
            }else{
                temp.addFirst(nums[i]);
                flag[i]=true;
                backtracking(nums,flag,i+1);
                flag[i]=false;
                temp.pollFirst();
            }
        }
    } 
}
```

### 491.递增子序列🔴

> 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
>
> 示例 1：
>
> ```
> 输入：nums = [4,6,7,7]
> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [4,4,3,2,1]
> 输出：[[4,4]]
> ```

```java
//出口条件：长度>1
List<List<Integer>> res = new ArrayList<>();
Deque<Integer> path = new LinkedList<>();

public List<List<Integer>> findSubsequences(int[] nums) {
 	backtracking(nums,0);
    return res;
}

 public void backtracking(int[] nums,){
     if(path.size()>1){
         res.add(new ArrayList<>(path));
         //不要加return
     }
     //单层搜索逻辑：同一层相同元素不能复用：使用set去重
     int[] used = new int[201];
     for(int i=start;i<nums.length;i++){
         if(!path.isEmpty(i)&&nums[i]<path.get(path.size()-1)||(used[nums[i]]+100==1)) continue;
         used[nums[i]+100] =1;
         path.add(nums[i]);
         backtracking(nums,i+1);
         path.remove(path.size()-1);
     }
 }
```

```java
//法二：使用map
class Solution {
    //结果集合
    List<List<Integer>> res = new ArrayList<>();
    //路径集合
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        getSubsequences(nums,0);
        return res;
    }
    private void getSubsequences( int[] nums, int start ) {
        if(path.size()>1 ){
            res.add( new ArrayList<>(path) );
            // 注意这里不要加return，要取树上的节点
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=start ;i < nums.length ;i++){
            if(!path.isEmpty() && nums[i]< path.getLast()){
                continue;
            }
            // 使用过了当前数字
            if ( map.getOrDefault( nums[i],0 ) >=1 ){
                continue;
            }
            map.put(nums[i],map.getOrDefault( nums[i],0 )+1);
            path.add(nums[i]);
            getSubsequences(nums,i+1);
            path.removeLast();
        }
    }
}
```




### 46.全排列🟥

> 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
>
> 示例 1：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [1]
> 输出：[[1]]
> ```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] flag = new boolean[nums.length];//全排列每次都是从0开始搜，因此需要记录有没有用过这个数
        backtracking(nums,flag);
        return res;

    }

    public void backtracking(int[] nums,boolean[] flag){
        if(path.size()==nums.length){
            res.add(new ArrayList<>(path));
        }
        for(int i = 0;i<nums.length;i++){
            if(!flag[i]){
                path.addFirst(nums[i]);
                flag[i] = true;
                backtracking(nums,flag);
                flag[i] = false;
                path.pollFirst();
            }
        }
    }
}
```

### 47.全排列Ⅱ✅

> 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
>
> 示例 1：
>
> ```
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```

```java
//首先全排列就要将自己给排除，然后这里还要检查
//去重一定对元素排列，比较相邻元素
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length];
        backtracking(nums,flag);
        return res;
    }

    public void backtracking(int[] nums,boolean[] flag){
        if(path.size()==nums.length){
            res.add(new ArrayList<>(path));
        }
        for(int i = 0;i< nums.length;i++){
            //去重检查,和之前的一样
            if(i>0&&nums[i]==nums[i-1]&&!flag[i-1]){
                continue;
            }
            if(!flag[i]){
                path.addFirst(nums[i]);
                flag[i] = true;
                backtracking(nums,flag);
                flag[i] = false;
                path.pollFirst();
            }
        }
    }
}
```

### 332.重新安排行程🔴

> 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
>
> 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
>
> 例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
>
>  
>
> 示例 1：
>
> ```
> 输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
> 输出：["JFK","MUC","LHR","SFO","SJC"]
> ```
>
>
> 示例 2：
>
> ```
> 输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
> 输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
> 解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
> ```

```java
class Solution {
    private Deque<String> res;
    private Map<String, Map<String, Integer>> map;

    private boolean backTracking(int ticketNum){
        if(res.size() == ticketNum + 1){
            return true;
        }
        String last = res.getLast();
        if(map.containsKey(last)){//防止出现null
            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){
                int count = target.getValue();
                if(count > 0){
                    res.add(target.getKey());
                    target.setValue(count - 1);
                    if(backTracking(ticketNum)) return true;
                    res.removeLast();
                    target.setValue(count);
                }
                
            }
        }
        return false;
    }

    public List<String> findItinerary(List<List<String>> tickets) {
        map = new HashMap<String, Map<String, Integer>>();
        res = new LinkedList<>();
        for(List<String> t : tickets){
            Map<String, Integer> temp;
            if(map.containsKey(t.get(0))){
                temp = map.get(t.get(0));
                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);
            }else{
                temp = new TreeMap<>();//升序Map
                temp.put(t.get(1), 1);
            }
            map.put(t.get(0), temp);

        }
        res.add("JFK");
        backTracking(tickets.size());
        return new ArrayList<>(res);
    }
}
```

### 51.N皇后✅🔁🔁🔴🔴

> n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
>
> 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
>
> 1. 不能同行
> 2. 不能同列
> 3. 不能同斜线
>
> ```
> 输入：n = 4
> 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
> 解释：如上图所示，4 皇后问题存在两个不同的解法。
> ```
>
> 示例 2：
>
> ```
> 输入：n = 1
> 输出：[["Q"]]
> ```

```c
//回溯三部曲
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
///////////////////////////////////////
void backtracking(棋盘大小n，当前行数row，结果矩阵chessboard){//一行一行取，到最后一行即结束
    if(row==n){
        result.add(chessboard);return;
    }
    //每次从新的一行开始，col控制列
    for(int col = 0;col<n;col++){
        if(isValid(row,col,chessboard,n)){
            chessboard[row][col] = 'Q';
            backtracking(n,row+1,chessboard);//确定本行的皇后后，开始进入下一行
            chessboard[row][col] = '.';
        }
    }
}
/////////////////验证是否合法
bool isValid(行，列，棋盘chessboard，大小n){
    //三步检测：本列；45°；135°//注意只有左上和右上需要检查，下面的行还不会有皇后
    for(int i = 0;i<row;i++){
        if(chessboard[i][col]=='Q') return false;
    }
    for(int i = row-1,j = col -1; i>=0&&j>=0;i--,j--){
        if(chessboard[i][j]=='Q') return false;
    }
    for(int i = row-1,j =col+1;i>=0&&j<n;i--,j++){
         if(chessboard[i][j]=='Q') return false;
    }
    return true;
}
///////////////////还需要一个方法将char[][]转化为list
 public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }
```

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for(char[] c : chessboard){//棋盘初始化
            Arrays.fill(c,'.');
        }
        backtracking(n,0,chessboard);
        return res;
    }
    //
    public void backtracking(int n,int row,char[][] chessboard){//当前第几行
        if(row == n){
            res.add(Array2List(chessboard));
            return;
        }
        //单层递归
        for(int col = 0;col<n;col++){
            if(isValid(n,row,col,chessboard)){//当前位置有效,把Q放下，进入下一次递归，然后取出Q
                chessboard[row][col] = 'Q';
                backtracking(n,row+1,chessboard);
                chessboard[row][col] = '.';
            }//不需要else continue，因为后面没有代码了
        }
    }

    public boolean isValid(int n,int row, int col, char[][] chessboard){
        //检查本列是否存在
        for(int i = 0;i<row;i++){
            if(chessboard[i][col]=='Q') return false;
        }
        //45°区域
        for(int i = row-1,j = col-1;i>=0&&j>=0;i--,j--){
            if(chessboard[i][j] == 'Q') return false;
        }
        //135°区域
        for(int i = row-1,j = col+1;i>=0&&j<=n-1;i--,j++){
            if(chessboard[i][j] == 'Q') return false;
        }
        return true;
    }
    //将数组转化为list的函数
    public List Array2List(char[][] chessboard){
        List<String> list = new ArrayList<>();
        for(char[] c : chessboard){
            list.add(String.copyValueOf(c));
        }
        return list;
    }
}
```

### 37.解数独🔁🔴🔴

> 编写一个程序，通过填充空格来解决数独问题。
>
> 数独的解法需 遵循如下规则：
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。
>
> ```
> 输入：
> board = 
> [["5","3",".",".","7",".",".",".","."],
> ["6",".",".","1","9","5",".",".","."],
> [".","9","8",".",".",".",".","6","."],
> ["8",".",".",".","6",".",".",".","3"],
> ["4",".",".","8",".","3",".",".","1"],
> ["7",".",".",".","2",".",".",".","6"],
> [".","6",".",".",".",".","2","8","."],
> [".",".",".","4","1","9",".",".","5"],
> [".",".",".",".","8",".",".","7","9"]]
> 输出：
> [["5","3","4","6","7","8","9","1","2"],
> ["6","7","2","1","9","5","3","4","8"],
> ["1","9","8","3","4","2","5","6","7"],
> ["8","5","9","7","6","1","4","2","3"],
> ["4","2","6","8","5","3","7","9","1"],
> ["7","1","3","9","2","4","8","5","6"],
> ["9","6","1","5","3","7","2","8","4"],
> ["2","8","7","4","1","9","6","3","5"],
> ["3","4","5","2","8","6","1","7","9"]]
> ```

```java
class Solution {
    public void solveSudoku(char[][] board) {
        dfs(board);
    }

    public boolean dfs(char[][] board){
        for(int i = 0;i<9;i++){
            for(int j = 0;j<9;j++){
                if(board[i][j]!='.') continue;
                for(char k ='1';k<='9';k++){
                    if(isValid(i,j,k,board)){
                        board[i][j] = k;
                        if(dfs(board)){
                            return true;
                        }
                        board[i][j]='.';
                    }
                }
                return false;//9个位置都试了还没找到说明棋盘无解
            }
        }
        return true;
    }

    /////////////////////////////////
    public boolean isValid(int row,int col, char val,char[][] board){
        for(int i = 0;i<9;i++){
            if(board[row][i]==val) return false;
        }
        for(int j = 0;j<9;j++){
            if(board[j][col]==val) return false;
        }
        //检查宫
        int startRow = (row/3)*3;
        int startCol = (col/3)*3;
        for(int i = startRow;i<startRow+3;i++){
            for(int j = startCol;j<startCol+3;j++){
                if(board[i][j]==val) return false;
            }
        }
        return true;
    }
}
```



## 贪心算法

### 455.分发饼干✅

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
>
> 示例 1:
>
> ```
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```
>
> 示例 2:
>
> ```
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
> ```

```java
class Solution {
     public int findContentChildren(int[] g, int[] s) {
            Arrays.sort(g);
            Arrays.sort(s);
            int j = 0;
            //要求s>=g,
            int num = 0;//以满足的数量
            for(int i = 0;i<s.length;i++){
                if(g[j]<=s[i]){
                    num++;j++;
                }
                if(j==g.length) break;
            }

            return num;
        }
}
```



### 376.摆动序列✅🔁🔁

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
>
> 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
> 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
>
> 
>
> 示例 1：
>
> ```
> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
> ```

局部最优：当前差值和上一次差值一正一负

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            //得到当前差值
            curDiff = nums[i] - nums[i - 1];
            //如果当前差值和上一个差值为一正一负
            //等于0的情况表示初始时的preDiff
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {//注意在preDiff为0时
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```


### 53.最大子数组和🟩

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 子数组 是数组中的一个连续部分。
>
>  示例 1：
>
> ```
>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
> 
> 示例 2：
>
> ```
>输入：nums = [1]
> 输出：1
> ```
> 
> 示例 3：
>
> ```
>输入：nums = [5,4,-1,7,8]
> 输出：23
> ```

局部最优：当连续和为负时立刻放弃

全局最优：选取最大的局部连续和

```java
//本题返回值即可，不需要记录位置
class Solution {
    public int maxSubArray(int[] nums) {
        int count = 0  ;
        int result = Integer.MIN_VALUE;
        for(int i = 0;i<nums.length;i++){
            count += nums[i];
            if(count> result){
                result = count;
            }
            if(count<=0){
                count=0;
            }
        }
        return result;
    }
}
```



### 122.买股票最佳时机Ⅱ✅🔁

> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
>
> 返回 你能获得的 最大利润 。
>
> 示例 1：
>
> ```
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>      总利润为 4 + 3 = 7 。
> ```
>
> 示例 2：
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      总利润为 4 。
> ```
>
> 示例 3：
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
> ```

```java
//？？？已崩溃：只要今天比昨天大，就计入利润
```

### 55.跳跃游戏🔁🔴

> 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
> 数组中的每个元素代表你在该位置可以跳跃的**最大**长度。
>
> 判断你是否能够到达最后一个下标。
>
>  
>
> 示例 1：
>
> ```
> 输入：nums = [2,3,1,1,4]
> 输出：true
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [3,2,1,0,4]
> 输出：false
> 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
> ```

```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length==1) return true;
        int range = nums[0];
        for(int i = 0;i<=range;i++){
            if(nums[i]+i>range) range = nums[i]+i;
            if(range>=nums.length-1) return true;
        }
        return false;
    }
}
```

### 45.跳跃游戏Ⅱ🔁🔴

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。
>
>  
>
> 示例 1:
>
> ```
> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```
>
> 示例 2:
>
> ```
> 输入: nums = [2,3,0,1,4]
> 输出: 2
> ```

每跳一次更新下覆盖范围，直到可接触到终点，没到就步数+1

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length==1) return 0; 
        int curRange = 0;
        int nextRange = 0;
        int step = 0;
        for(int i = 0;i<nums.length-1;i++){
            nextRange = Math.max(i +nums[i],nextRange);
            if(i==curRange){
                curRange = nextRange;
                step++;
            }
        }
        return step;
    }
}
```




### 1005.K次取反后最大化的数组和🔁

> 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
>
> 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
> 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
>
> 以这种方式修改数组后，返回数组 可能的最大和 。
>
> 示例 1：
>
> ```
> 输入：nums = [4,2,3], k = 1
> 输出：5
> 解释：选择下标 1 ，nums 变为 [4,-2,3] 。
> ```
>
> 示例 2：
>
> ```
> 输入：nums = [3,-1,0,2], k = 3
> 输出：6
> 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
> ```
>
> 示例 3：
>
> ```
> 输入：nums = [2,-3,-1,5,-4], k = 2
> 输出：13
> 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
> ```

```java
class Solution {
    public int largestSumAfterKNegations(int[] A, int k) {
        if (A.length == 1) return k % 2 == 0 ? A[0] : -A[0];
        Arrays.sort(A);
        int sum = 0;
        int idx = 0;
        for (int i = 0; i < K; i++) {
            if (i < A.length - 1 && A[idx] < 0) {
                A[idx] = -A[idx];
                if (A[idx] >= Math.abs(A[idx + 1])) idx++;
                continue;
            }
            A[idx] = -A[idx];
        }

        for (int i = 0; i < A.length; i++) {
            sum += A[i];
        }
        return sum;
    }
}
```

```java
//解法二 效率很低
class Solution {
    public int largestSumAfterKNegations(int[] nums, int K) {
    	// 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
	nums = IntStream.of(nums)
		     .boxed()
		     .sorted((o1, o2) -> Math.abs(o2) - Math.abs(o1))
		     .mapToInt(Integer::intValue).toArray();
	int len = nums.length;	    
	for (int i = 0; i < len; i++) {
	    //从前向后遍历，遇到负数将其变为正数，同时K--
	    if (nums[i] < 0 && K > 0) {
	    	nums[i] = -nums[i];
	    	K--;
	    }
	}
	// 如果K还大于0，那么反复转变数值最小的元素，将K用完

	if (K % 2 == 1) nums[len - 1] = -nums[len - 1];
	return Arrays.stream(nums).sum();

    }
}
```

### 134.加油站✅

> 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
>
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
>
>  
>
> 示例 1:
>
> ```
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> ```
>
> 示例 2:
>
> ```
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
> ```

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //初始检查
        int len = gas.length;
        int sum = 0;
        int curRest = 0;
        int start = 0;

        for(int i = 0;i<len;i++){
            curRest += (gas[i]-cost[i]);
            sum +=(gas[i]-cost[i]);
            if(curRest<0){
                curRest = 0;
                start = i+1;
            }
        }
        if(sum<0) return -1;
        if(start>=len) return -1;
        return start;
    }
}
```



### 135.分发糖果🔁

> n 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
>
> 你需要按照以下要求，给这些孩子分发糖果：
>
> 每个孩子至少分配到 1 个糖果。
> 相邻两个孩子评分更高的孩子会获得更多的糖果。
> 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
>
> 示例 1：
>
> ```
> 输入：ratings = [1,0,2]
> 输出：5
> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
> ```
>
> 示例 2：
>
> ```
> 输入：ratings = [1,2,2]
> 输出：4
> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
>      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
> ```

```java
//思路一样，出错,都是前后循环一遍，注意
class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] candy = new int[len];
        candy[0] = 1;
        for(int i = 1;i<len;i++){
            if(ratings[i]>ratings[i-1]){
                candy[i] = candy[i-1]+1;
            }else{
                candy[i] = 1;
            }
        }
        for(int j = len-2;j>=0;j--){
            if(ratings[j]>ratings[j+1]){
                candy[j] = Math.max(candy[j],candy[j+1]+1);
            }
        }
        int sum=0;
        for(int c : candy){
            sum+=c;
        }
        return sum;
    }
}
```



### 860.柠檬水找零✅

> 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
>
> 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
>
> 注意，一开始你手头没有任何零钱。
>
> 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
>
> 示例 1：
>
> ```
> 输入：bills = [5,5,5,10,20]
> 输出：true
> 解释：
> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
> 由于所有客户都得到了正确的找零，所以我们输出 true。
> ```
>
> 示例 2：
>
> ```
> 输入：bills = [5,5,10,10,20]
> 输出：false
> 解释：
> 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
> 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
> 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
> 由于不是每位顾客都得到了正确的找零，所以答案是 false。
> ```

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        //纯模拟
    int five = 0;
    int ten =0;
    int twenty = 0;
    for(int i : bills){
        if(i ==5 ) five++;
        if(i == 10){
            five--;
            if(five<0) return false;
            ten++;
        }
        if(i == 20){
            //先用10块的找
            if(ten>0&&five>0){
                ten--;five--;
            }else if(five<=0){
                return false;
            }else if(ten<=0&&five>=3){
                five-=3;
            }else{
                return false;
            }
        }
    }
    return true;
    }
}
```

### 406.根据身高重建队列🔁🔁

> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
>
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
>
> 示例 1：
>
> ```
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> 解释：
> 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
> 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
> 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
> 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
> 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
> ```
>
> 示例 2：
>
> ```
> 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
> 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
> ```

```java
//先学习Arrays.sort
Arrays.sort(people,(a,b)->{
    if(a[0]==b[0])return a[1]-b[1];//这是升序
    return b[0]-a[0];//这是降序
})
```

```java
LinkedList<int[]> que = new LinkedList<>();
for(int[] p : people){
    que.add(p[1],p);//插到第几个位置就保证了前面有几个更大的。
}
return que.toArray(new int[people.length][]);
```

### 452.用最少数量的箭引爆气球🔁🔁🔴

> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。
>
> 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。
>
> 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。
>
>
> 示例 1：
>
> ```
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> -在x = 6处射出箭，击破气球[2,8]和[1,6]。
> -在x = 11处发射箭，击破气球[10,16]和[7,12]。
> ```
>
> 示例 2：
>
> ```
> 输入：points = [[1,2],[3,4],[5,6],[7,8]]
> 输出：4
> 解释：每个气球需要射出一支箭，总共需要4支箭。
> ```
>
> 示例 3：
>
> ```
> 输入：points = [[1,2],[2,3],[3,4],[4,5]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> 
> 在x = 2处发射箭，击破气球[1,2]和[2,3]。
> 在x = 4处射出箭，击破气球[3,4]和[4,5]。
> ```

```java
if(points.length==0) return 0;
Arrays.sort(points,(o1,o2)->Integer.compare(o1[0],o2[0]));

int count =1;
for(int i = 1;i<points.length;i++){
    if(points[i][0]>points[i-1][1]){
        count++;
    }else{
        points[i][1] = Math.min(points[i][1],points[i-1][1]);//很关键的点，每次处理最小的点就能
    }
}
return count;
```



```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length ==0) return 0;
        Arrays.sort(points,(o1,o2)->Integer.compare(o1[0]-o2[0]));

        int res = 1;
        for(int i = 1;i<points.length;i++){
            if(points[i-1][1]<points[i][0]){
                res++;
            }else{
                points[i][1] = Math.min(points[i-1][1],points[i][1]);
            }
        }
        return res;
    }
}
```



### 435.无重叠区间🔴

> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。
>
> 示例 1:
>
> ```
> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
> 输出: 1
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。
> ```
>
> 示例 2:
>
> ```
> 输入: intervals = [[1,2], [1,2],[1,2]]
> 输出: 2
> 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
> ```
>
> 示例 3:
>
> ```
> 输入: intervals = [[1,2],[2,3]]
> 输出: 0
> 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
> ```
>
>
> 

### 763.划分字母区间✅

> 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
>
> 示例：
>
> ```
> 输入：S = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca", "defegde", "hijhklij"。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
> ```

```java
//自己想的
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> result = new ArrayList<>();
        if(s.length()==1){
            result.add(1);
            return result;
        }
        List<List<Integer>> range = getRange(s);
        int start = 0;
        int end = 0;
        int startP = range.get(0).get(0);
        for(List<Integer> arr : range){
            if(arr.get(0)>end) {
                result.add(end-startP+1);
                startP = arr.get(0);
            }        
            end = Math.max(end,arr.get(1));
        }
        result.add(end-startP+1);
         return result;
    }
    public List<List<Integer>> getRange(String s){
            boolean[] flag = new boolean[26];//用于存放所有字母之后出现的set
            List<List<Integer>> range = new ArrayList<>();
            for(int i = 0;i<s.length();i++){
                char c = s.charAt(i);
                if(!flag[c - 'a']){//第一次出现
                    //1、修改flag数组
                    //2、得出最后的坐标，写入range
                    flag[c-'a'] = true;
                    List<Integer> temp = new ArrayList<>();
                    temp.add(i);
                    temp.add(s.lastIndexOf(c));
                    range.add(temp);
                }
            }
            return range;//得到的已经是按起始位置排好序的
        }
}
```

```java
//他人解法
class Solution {
    public List<Integer> partitionLabels(String S) {
        List<Integer> list = new LinkedList<>();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }
        int idx = 0;
        int last = -1;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i] - 'a']);
            if (i == idx) {
                list.add(i - last);
                last = i;
            }
        }
        return list;
    }
}
```

### 56.合并区间🔴 

> 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
>
> 示例 1：
>
> ```
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```
>
> 示例 2：
>
> ```
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        List<int[]> ans = new ArrayList<>();
        //  先对区间进行排序
        Arrays.sort(intervals,(o1,o2)->{
            if(o1[0]==o2[0]){
                return o1[1]-o2[1];//升序
            }
            return o1[0]-o2[0];
        });
        for(int i=0;i<n;){
            int[] inval = intervals[i];
            int l = inval[0], r = inval[1];
            while(i<n && intervals[i][0] <= r){
                r =  Math.max(r, intervals[i][1]);
                i++;
            }
            ans.add(new int[]{l, r});
        }
        int[][] res = new int[ans.size()][2];
        int idx = 0;
        for(int[] tmp : ans){
            res[idx][0] = tmp[0];
            res[idx++][1] = tmp[1];
        }
        return res;
    }
}
```



### 738.单调递增的数字🔁

> 复习 `String.valueOf()`
>
> ​	`Integer.parseInt()`

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);//整型转string
        int len = s.length();
        char[] chars = s.toCharArray();
        int flag = len;
        for(int i = len-1;i>=1;i--){
            if(chars[i]<chars[i-1]){
                flag = i;
                chars[i-1]--;
            }
        }
        for(int i  = flag;i<len;i++){
            chars[i] ='9';
        }
        return Integer.parseInt(new String(chars));
    }
}
```



### 714.买股票最佳时机含手续费

### 968.监控二叉树

### 



## 前缀树

### 208.实现前缀树🔁

> **[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
>
> 请你实现 Trie 类：
>
> - `Trie()` 初始化前缀树对象。
> - `void insert(String word)` 向前缀树中插入字符串 `word` 。
> - `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
> - `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。
>
> **示例：**
>
> ```
> 输入
> ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
> [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
> 输出
> [null, null, true, false, true, null, true]
> 
> 解释
> Trie trie = new Trie();
> trie.insert("apple");
> trie.search("apple");   // 返回 True
> trie.search("app");     // 返回 False
> trie.startsWith("app"); // 返回 True
> trie.insert("app");
> trie.search("app");     // 返回 True
> ```
>
>  

```java
class Trie {

private class TrieNode{
    private boolean isEnd;
    private TrieNode[] son ;
    public TrieNode(){
        isEnd = false;
        son = new TrieNode[26];
    }
}

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        //拆入单词
        TrieNode cur = root;//都是从根节点开始
        for(int i = 0,len = word.length(),ch;i<len;i++){
            ch = word.charAt(i)-'a';
            if(cur.son[ch]==null){
                cur.son[ch] = new TrieNode();
            }
            cur = cur.son[ch];
        }
        //结束后加上end
        cur.isEnd = true;
    }
    
    public boolean search(String word) {
        //一直找下去，返回end
        TrieNode cur = root;
        for(char c:word.toCharArray()){
            c-='a';
            if(cur.son[c]==null){
                return false;
            }
            cur = cur.son[c];
        }
        return cur.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for(char c:prefix.toCharArray()){
            c -='a';
            if(cur.son[c]==null){
                return false;
            }
            cur = cur.son[c];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

### [648. 单词替换](https://leetcode.cn/problems/replace-words/)

> 在英语中，我们有一个叫做 `词根`(root) 的概念，可以词根**后面**添加其他一些词组成另一个较长的单词——我们称这个词为 `继承词`(successor)。例如，词根`an`，跟随着单词 `other`(其他)，可以形成新的单词 `another`(另一个)。
>
> 现在，给定一个由许多**词根**组成的词典 `dictionary` 和一个用空格分隔单词形成的句子 `sentence`。你需要将句子中的所有**继承词**用**词根**替换掉。如果**继承词**有许多可以形成它的**词根**，则用**最短**的词根替换它。
>
> 你需要输出替换之后的句子。
>
>  
>
> **示例 1：**
>
> ```
> 输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
> 输出："the cat was rat by the bat"
> ```
>
> **示例 2：**
>
> ```
> 输入：dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
> 输出："a a b c"
> ```
>

### [1894. 找到需要补充粉笔的学生编号](https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/)

> 一个班级里有 `n` 个学生，编号为 `0` 到 `n - 1` 。每个学生会依次回答问题，编号为 `0` 的学生先回答，然后是编号为 `1` 的学生，以此类推，直到编号为 `n - 1` 的学生，然后老师会重复这个过程，重新从编号为 `0` 的学生开始回答问题。
>
> 给你一个长度为 `n` 且下标从 `0` 开始的整数数组 `chalk` 和一个整数 `k` 。一开始粉笔盒里总共有 `k` 支粉笔。当编号为 `i` 的学生回答问题时，他会消耗 `chalk[i]` 支粉笔。如果剩余粉笔数量 **严格小于** `chalk[i]` ，那么学生 `i` 需要 **补充** 粉笔。
>
> 请你返回需要 **补充** 粉笔的学生 **编号** 。
>
>  **示例 1：**
>
> ```
> 输入：chalk = [5,1,5], k = 22
> 输出：0
> 解释：学生消耗粉笔情况如下：
> - 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。
> - 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。
> - 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。
> - 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。
> - 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。
> - 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。
> 编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。
> ```
>
> **示例 2：**
>
> ```
> 输入：chalk = [3,4,1,2], k = 25
> 输出：1
> 解释：学生消耗粉笔情况如下：
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。
> - 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。
> - 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。
> - 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。
> - 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。
> - 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。
> - 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。
> 编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。
> ```
>
>  





### 211

### 677

### 676

### 745
